import {
  _assertThisInitialized,
  _setPrototypeOf
} from "./chunk-CQ3PGAZU.js";
import {
  _typeof,
  toPropertyKey
} from "./chunk-4P4SLGZP.js";
import {
  ALL,
  Channel,
  DateSeparator,
  EmojiReactions,
  FileViewer,
  FileViewerView,
  FrozenNotification,
  GroupChannelHeaderView,
  GroupChannelUIView,
  LinkLabel,
  MENTION_USER_LABEL_CLASSNAME,
  MessageBody,
  MessageEmojiMenu,
  MessageHeader,
  MessageInput,
  MessageInputKeys,
  MessageInputWrapperView,
  MessageMenu,
  MessageProfile,
  MessageProvider,
  MessageStatus,
  MessageView,
  MobileMenu,
  MultipleFilesMessageItemBody,
  RemoveMessageModalView,
  SuggestedMentionListView,
  TextFragment,
  ThreadMessageKind,
  ThreadReplySelectType,
  TypingIndicatorBubble,
  TypingIndicatorText,
  TypingIndicatorType,
  UnreadCount,
  VoiceMessageInputWrapper,
  VoiceMessageItemBody,
  compareIds as compareIds2,
  compareMessagesForGrouping,
  compressImages,
  format,
  getCaseResolvedReplyType,
  getCaseResolvedThreadReplySelectType,
  getChannelPreviewMessage,
  getChannelTitle,
  getChannelTitle2,
  getChannelUnreadMessageCount,
  getComponentKeyFromMessage,
  getIsReactionEnabled,
  getLastMessageCreatedAt,
  getLastMessageText,
  getMessageFirstFileName,
  getMessageFirstFileUrl,
  getMessagePartsInfo,
  getMessageTopOffset,
  getModalDeleteMessageTitle,
  getNicknamesMapFromMembers,
  getParentMessageFrom,
  getTotalMembers,
  isAboutSame as isAboutSame2,
  isContextMenuClosed,
  isDisabledBecauseFrozen,
  isDisabledBecauseMuted,
  isSameDay,
  isThisYear,
  isToday,
  isYesterday,
  scrollIntoLast,
  tokenizeMessage,
  useDirtyGetMentions,
  useElementObserver,
  useFileInfoListWithUploaded,
  useGlobalModalContext,
  useHandleOnScrollCallback,
  useLongPress,
  useReconnectOnIdle,
  useSendMultipleFilesMessage,
  useThreadMessageKindKeySelector,
  useVoicePlayerContext
} from "./chunk-ELYTTIPP.js";
import {
  Badge,
  ChannelSettings
} from "./chunk-JJFSYBLM.js";
import {
  APP_LAYOUT_ROOT,
  Avatar$1,
  ButtonTypes,
  ChannelAvatar,
  Colors,
  ContextMenu,
  EMOJI_MENU_ROOT_ID,
  Header$1,
  Icon,
  IconButton,
  IconColors,
  IconTypes,
  ImageRenderer,
  Input,
  InputLabel,
  K,
  Label,
  LabelColors,
  LabelTypography,
  Loader,
  LocalizationContext,
  MENU_OBSERVING_CLASS_NAME,
  MENU_ROOT_ID,
  MenuItem,
  MenuItems,
  Modal,
  ModalFooter,
  PUBSUB_TOPICS,
  PlaceHolder,
  PlaceHolderTypes,
  PublishingModuleType,
  S,
  TextButton,
  UserListItem,
  UserProfile,
  UserProfileProvider,
  __assign,
  __awaiter,
  __generator,
  __rest,
  __spreadArray,
  classnames,
  compareIds,
  createStore,
  delay,
  deleteNullish,
  filterChannelListParams,
  getChannelsWithUpsertedChannel,
  getClassName,
  getCreateGroupChannel,
  getHTMLTextDirection,
  getObservingId,
  getSdk,
  getSenderName,
  getSuggestedReplies,
  getUIKitFileType,
  getUIKitMessageType,
  getUIKitMessageTypes,
  isAboutSame,
  isChannelJustCreated,
  isDefaultChannelName,
  isDisabledBecauseFrozen as isDisabledBecauseFrozen2,
  isDisabledBecauseMuted as isDisabledBecauseMuted2,
  isEditedMessage,
  isEqual$1,
  isFileMessage,
  isGifMessage,
  isImage,
  isMultipleFilesMessage,
  isOGMessage,
  isSendableMessage,
  isSentMessage,
  isThumbnailMessage,
  isUserMessage,
  isVideo,
  isVideoMessage,
  isVoiceMessage,
  noop,
  openURL,
  pubSubTopics,
  shimExports,
  shouldPubSubPublishToThread,
  truncateString,
  useAsyncEffect,
  useAsyncLayoutEffect,
  useGroupChannelHandler,
  useGroupChannelList,
  useGroupChannelMessages,
  useIIFE,
  useLocalization,
  useMediaQueryContext,
  useOnScrollPositionChangeDetector,
  useSendbird,
  useStore,
  useUserProfileContext,
  uuidv4
} from "./chunk-G45O5RRC.js";
import {
  DELIVERY_RECEIPT,
  META_ARRAY_MESSAGE_TYPE_KEY,
  META_ARRAY_MESSAGE_TYPE_VALUE__VOICE,
  META_ARRAY_VOICE_DURATION_KEY,
  ONE_MiB,
  SCROLL_BOTTOM_DELAY_FOR_SEND,
  SCROLL_BUFFER,
  VOICE_MESSAGE_FILE_NAME,
  VOICE_MESSAGE_MIME_TYPE
} from "./chunk-5WPCGI6B.js";
import {
  require_react_dom
} from "./chunk-G52XTN3B.js";
import {
  Ae
} from "./chunk-7RQKLDUL.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  Ye,
  hn
} from "./chunk-JVBXJ32W.js";
import {
  E
} from "./chunk-NLX4ICU2.js";
import {
  Ve,
  qs,
  wi
} from "./chunk-TTFJWE4I.js";
import {
  G,
  H,
  Q,
  Z,
  z
} from "./chunk-KXGQOUB2.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/@sendbird/uikit-react/chunks/bundle-DipRMv-6.js
var import_react = __toESM(require_react(), 1);
var RESET_CHANNEL_LIST = "RESET_CHANNEL_LIST";
var CREATE_CHANNEL = "CREATE_CHANNEL";
var LEAVE_CHANNEL_SUCCESS = "LEAVE_CHANNEL_SUCCESS";
var SET_CURRENT_CHANNEL = "SET_CURRENT_CHANNEL";
var FETCH_CHANNELS_START = "FETCH_CHANNELS_START";
var FETCH_CHANNELS_SUCCESS = "FETCH_CHANNELS_SUCCESS";
var FETCH_CHANNELS_FAILURE = "FETCH_CHANNELS_FAILURE";
var INIT_CHANNELS_START = "INIT_CHANNELS_START";
var INIT_CHANNELS_SUCCESS = "INIT_CHANNELS_SUCCESS";
var REFRESH_CHANNELS_SUCCESS = "REFRESH_CHANNELS_SUCCESS";
var INIT_CHANNELS_FAILURE = "INIT_CHANNELS_FAILURE";
var ON_USER_JOINED = "ON_USER_JOINED";
var ON_CHANNEL_DELETED = "ON_CHANNEL_DELETED";
var ON_LAST_MESSAGE_UPDATED = "ON_LAST_MESSAGE_UPDATED";
var ON_USER_LEFT = "ON_USER_LEFT";
var ON_CHANNEL_CHANGED = "ON_CHANNEL_CHANGED";
var ON_CHANNEL_ARCHIVED = "ON_CHANNEL_ARCHIVED";
var ON_CHANNEL_FROZEN = "ON_CHANNEL_FROZEN";
var ON_CHANNEL_UNFROZEN = "ON_CHANNEL_UNFROZEN";
var ON_READ_RECEIPT_UPDATED = "ON_READ_RECEIPT_UPDATED";
var ON_DELIVERY_RECEIPT_UPDATED = "ON_DELIVERY_RECEIPT_UPDATED";
var CHANNEL_LIST_PARAMS_UPDATED = "CHANNEL_LIST_PARAMS_UPDATED";
var DELIVERY_RECEIPT2 = "delivery_receipt";
var createEventHandler = function(_a) {
  var sdk = _a.sdk, sdkChannelHandlerId = _a.sdkChannelHandlerId, channelListDispatcher = _a.channelListDispatcher, logger = _a.logger;
  var ChannelHandler = new Ye({
    onChannelChanged: function(channel) {
      if (channel.isGroupChannel()) {
        logger.info("ChannelList: onChannelChanged", channel);
        channelListDispatcher({
          type: ON_CHANNEL_CHANGED,
          payload: channel
        });
      }
    },
    onChannelDeleted: function(channelUrl) {
      logger.info("ChannelList: onChannelDeleted", channelUrl);
      channelListDispatcher({
        type: ON_CHANNEL_DELETED,
        payload: channelUrl
      });
    },
    onUserJoined: function(channel) {
      logger.info("ChannelList: onUserJoined", channel);
      channelListDispatcher({
        type: ON_USER_JOINED,
        payload: channel
      });
    },
    onUserBanned: function(channel, user) {
      var _a2;
      if (channel.isGroupChannel()) {
        logger.info("Channel: onUserBanned", channel);
        var isMe = user.userId === ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a2 === void 0 ? void 0 : _a2.userId);
        channelListDispatcher({
          type: ON_USER_LEFT,
          payload: { channel, isMe }
        });
      }
    },
    onUserLeft: function(channel, user) {
      var _a2;
      logger.info("ChannelList: onUserLeft", channel);
      var isMe = user.userId === ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a2 === void 0 ? void 0 : _a2.userId);
      channelListDispatcher({
        type: ON_USER_LEFT,
        payload: { channel, isMe }
      });
    },
    onUnreadMemberStatusUpdated: function(channel) {
      logger.info("ChannelList: onUnreadMemberStatusUpdated", channel);
      channelListDispatcher({
        type: ON_READ_RECEIPT_UPDATED,
        payload: channel
      });
    },
    onUndeliveredMemberStatusUpdated: function(channel) {
      logger.info("ChannelList: onUndeliveredMemberStatusUpdated", channel);
      if (channel.lastMessage) {
        channelListDispatcher({
          type: ON_DELIVERY_RECEIPT_UPDATED,
          payload: channel
        });
      }
    },
    onMessageUpdated: function(channel, message) {
      var _a2;
      if (channel.isGroupChannel() && ((_a2 = channel.lastMessage) === null || _a2 === void 0 ? void 0 : _a2.isEqual(message))) {
        logger.info("ChannelList: onMessageUpdated", channel);
        channelListDispatcher({
          type: ON_LAST_MESSAGE_UPDATED,
          payload: channel
        });
      }
    },
    onChannelHidden: function(channel) {
      logger.info("ChannelList: onChannelHidden", channel);
      channelListDispatcher({
        type: ON_CHANNEL_ARCHIVED,
        payload: channel
      });
    },
    onChannelFrozen: function(channel) {
      if (channel.isGroupChannel()) {
        logger.info("ChannelList: onChannelFrozen", channel);
        channelListDispatcher({
          type: ON_CHANNEL_FROZEN,
          payload: channel
        });
      }
    },
    onChannelUnfrozen: function(channel) {
      if (channel.isGroupChannel()) {
        logger.info("ChannelList: onChannelUnfrozen", channel);
        channelListDispatcher({
          type: ON_CHANNEL_UNFROZEN,
          payload: channel
        });
      }
    }
  });
  logger.info("ChannelList: Added channelHandler");
  sdk.groupChannel.addGroupChannelHandler(sdkChannelHandlerId, ChannelHandler);
};
var createChannelListQuery = function(_a) {
  var sdk = _a.sdk, _b = _a.userFilledChannelListQuery, userFilledChannelListQuery = _b === void 0 ? {} : _b;
  var params = {
    includeEmpty: false,
    limit: 20,
    // The value of pagination limit could be set up to 100.
    order: E.LATEST_LAST_MESSAGE
  };
  if (userFilledChannelListQuery) {
    Object.keys(userFilledChannelListQuery).forEach(function(key) {
      params[key] = userFilledChannelListQuery[key];
    });
  }
  return sdk.groupChannel.createMyGroupChannelListQuery(params);
};
function setupChannelList(_a) {
  var _b, _c, _d, _e;
  var sdk = _a.sdk, sdkChannelHandlerId = _a.sdkChannelHandlerId, channelListDispatcher = _a.channelListDispatcher, setChannelSource = _a.setChannelSource, onChannelSelect = _a.onChannelSelect, userFilledChannelListQuery = _a.userFilledChannelListQuery, logger = _a.logger, sortChannelList = _a.sortChannelList, disableAutoSelect = _a.disableAutoSelect, markAsDeliveredScheduler = _a.markAsDeliveredScheduler, disableMarkAsDelivered = _a.disableMarkAsDelivered;
  if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {
    createEventHandler({
      sdk,
      channelListDispatcher,
      sdkChannelHandlerId,
      logger
    });
  } else {
    logger.warning("ChannelList - createEventHandler: sdk or sdk.ChannelHandler does not exist", sdk);
  }
  logger.info("ChannelList - creating query", { userFilledChannelListQuery });
  var channelListQuery = createChannelListQuery({ sdk, userFilledChannelListQuery });
  logger.info("ChannelList - created query", channelListQuery);
  setChannelSource(channelListQuery);
  channelListDispatcher({
    type: INIT_CHANNELS_START,
    payload: {
      currentUserId: (_c = (_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId) !== null && _c !== void 0 ? _c : ""
    }
  });
  if (userFilledChannelListQuery) {
    logger.info("ChannelList - setting up channelListQuery", channelListQuery);
    channelListDispatcher({
      type: CHANNEL_LIST_PARAMS_UPDATED,
      payload: {
        channelListQuery,
        currentUserId: (_e = (_d = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId) !== null && _e !== void 0 ? _e : ""
      }
    });
  }
  logger.info("ChannelList - fetching channels");
  if (channelListQuery.hasNext) {
    channelListQuery.next().then(function(channelList) {
      var _a2, _b2;
      logger.info("ChannelList - fetched channels", channelList);
      logger.info("ChannelList - highlight channel", channelList[0]);
      var sortedChannelList = channelList;
      if (sortChannelList && typeof sortChannelList === "function") {
        sortedChannelList = sortChannelList(channelList);
        logger.info("ChannelList - channel list sorted", sortedChannelList);
      }
      if (!disableAutoSelect) {
        onChannelSelect === null || onChannelSelect === void 0 ? void 0 : onChannelSelect(sortedChannelList[0]);
      }
      channelListDispatcher({
        type: INIT_CHANNELS_SUCCESS,
        payload: {
          channelList: sortedChannelList,
          disableAutoSelect
        }
      });
      var canSetMarkAsDelivered = (_b2 = (_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a2 === void 0 ? void 0 : _a2.premiumFeatureList) === null || _b2 === void 0 ? void 0 : _b2.find(function(feature) {
        return feature === DELIVERY_RECEIPT2;
      });
      if (canSetMarkAsDelivered && !disableMarkAsDelivered) {
        sortedChannelList.forEach(function(channel) {
          markAsDeliveredScheduler.push(channel);
        });
      }
    }).catch(function(err) {
      if (err) {
        logger.error("ChannelList - couldnt fetch channels", err);
        channelListDispatcher({
          type: INIT_CHANNELS_FAILURE
        });
      }
    });
  } else {
    logger.info("ChannelList - there are no more channels");
  }
}
var pubSubHandleRemover = function(subscriber) {
  subscriber.forEach(function(s) {
    try {
      s.remove();
    } catch (_a) {
    }
  });
};
var pubSubHandler = function(pubSub, channelListDispatcher) {
  var subscriber = /* @__PURE__ */ new Map();
  if (!pubSub)
    return subscriber;
  subscriber.set(pubSubTopics.CREATE_CHANNEL, pubSub.subscribe(pubSubTopics.CREATE_CHANNEL, function(_a) {
    var channel = _a.channel;
    channelListDispatcher({
      type: CREATE_CHANNEL,
      payload: channel
    });
  }));
  subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function(_a) {
    var _b;
    var channel = _a.channel, message = _a.message;
    if (channel.isGroupChannel() && ((_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.messageId) === message.messageId) {
      channel.lastMessage = message;
      channelListDispatcher({
        type: ON_LAST_MESSAGE_UPDATED,
        payload: channel
      });
    }
  }));
  subscriber.set(pubSubTopics.LEAVE_CHANNEL, pubSub.subscribe(pubSubTopics.LEAVE_CHANNEL, function(msg) {
    var channel = msg.channel;
    channelListDispatcher({
      type: LEAVE_CHANNEL_SUCCESS,
      payload: channel === null || channel === void 0 ? void 0 : channel.url
    });
  }));
  return subscriber;
};
var getNextChannel = function(_a) {
  var channel = _a.channel, currentChannel = _a.currentChannel, allChannels = _a.allChannels, disableAutoSelect = _a.disableAutoSelect;
  var nextChannel = null;
  if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {
    if (!disableAutoSelect && allChannels.length > 0) {
      var firstChannel = allChannels[0], _b = allChannels[1], secondChannel = _b === void 0 ? null : _b;
      nextChannel = firstChannel.url === channel.url ? secondChannel : firstChannel;
    }
  } else {
    nextChannel = currentChannel;
  }
  return nextChannel;
};
var initialState = {
  // we might not need this initialized state -> should remove
  initialized: false,
  loading: true,
  allChannels: [],
  currentChannel: null,
  channelListQuery: null,
  currentUserId: "",
  disableAutoSelect: false
};
function channelListReducer(state, action) {
  return K(action).with({ type: INIT_CHANNELS_START }, function(_a) {
    var payload = _a.payload;
    return __assign(__assign({}, state), { loading: true, currentUserId: payload.currentUserId });
  }).with({ type: RESET_CHANNEL_LIST }, function() {
    return initialState;
  }).with({ type: INIT_CHANNELS_SUCCESS }, function(action2) {
    var _a = action2.payload, channelList = _a.channelList, disableAutoSelect = _a.disableAutoSelect;
    return __assign(__assign({}, state), { initialized: true, loading: false, allChannels: channelList, disableAutoSelect, currentChannel: !disableAutoSelect && channelList && channelList.length && channelList.length > 0 ? channelList[0] : state.currentChannel });
  }).with({ type: REFRESH_CHANNELS_SUCCESS }, function(action2) {
    var _a = action2.payload, channelList = _a.channelList, currentChannel = _a.currentChannel;
    return __assign(__assign({}, state), { loading: false, allChannels: channelList, currentChannel });
  }).with({ type: FETCH_CHANNELS_SUCCESS }, function(action2) {
    var currentChannels = state.allChannels.map(function(c) {
      return c.url;
    });
    var filteredChannels = action2.payload.filter(function(_a) {
      var url = _a.url;
      return !currentChannels.find(function(c) {
        return c === url;
      });
    });
    return __assign(__assign({}, state), { allChannels: __spreadArray(__spreadArray([], state.allChannels, true), filteredChannels, true) });
  }).with({ type: CREATE_CHANNEL }, function(action2) {
    var _a;
    var channel = action2.payload;
    var allChannels = state.allChannels, currentUserId = state.currentUserId, channelListQuery = state.channelListQuery;
    if (channelListQuery) {
      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {
        return __assign(__assign({}, state), { currentChannel: channel, allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });
      }
      return __assign(__assign({}, state), { currentChannel: channel });
    }
    return __assign(__assign({}, state), { currentChannel: channel, allChannels: __spreadArray([channel], allChannels.filter(function(ch) {
      return ch.url !== (channel === null || channel === void 0 ? void 0 : channel.url);
    }), true) });
  }).with({ type: ON_CHANNEL_ARCHIVED }, function(action2) {
    var _a;
    var channel = action2.payload;
    var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;
    if (channelListQuery) {
      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {
        return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });
      }
    }
    var nextChannel = getNextChannel({
      channel,
      currentChannel,
      allChannels,
      disableAutoSelect
    });
    return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function(_a2) {
      var url = _a2.url;
      return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
    }) });
  }).with({ type: S.union(LEAVE_CHANNEL_SUCCESS, ON_CHANNEL_DELETED) }, function(action2) {
    var _a;
    var channelUrl = action2.payload;
    var allChannels = state.allChannels.filter(function(_a2) {
      var url = _a2.url;
      return url !== channelUrl;
    });
    return __assign(__assign({}, state), { currentChannel: channelUrl === ((_a = state.currentChannel) === null || _a === void 0 ? void 0 : _a.url) ? allChannels[0] : state.currentChannel, allChannels });
  }).with({ type: ON_USER_LEFT }, function(action2) {
    var _a;
    var _b = action2.payload, channel = _b.channel, isMe = _b.isMe;
    var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;
    var nextChannels = __spreadArray([], allChannels, true);
    var nextChannel = channel;
    if (isMe || channelListQuery && !filterChannelListParams(channelListQuery, channel, currentUserId)) {
      var channelAt = allChannels.findIndex(function(ch) {
        return ch.url === channel.url;
      });
      if (channelAt > -1) {
        nextChannels.splice(channelAt, 1);
        nextChannel = getNextChannel({
          channel,
          currentChannel,
          allChannels,
          disableAutoSelect
        });
      }
    } else {
      nextChannels = getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order);
      if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {
        nextChannel = channel;
      }
    }
    return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: nextChannels });
  }).with({
    type: S.union(ON_USER_JOINED, ON_CHANNEL_CHANGED, ON_READ_RECEIPT_UPDATED, ON_DELIVERY_RECEIPT_UPDATED)
  }, function(action2) {
    var _a, _b, _c;
    var channel = action2.payload;
    var _d = state.allChannels, allChannels = _d === void 0 ? [] : _d, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;
    var unreadMessageCount = channel.unreadMessageCount;
    if (channelListQuery) {
      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {
        return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });
      }
      if (isChannelJustCreated(channel)) {
        return state;
      }
      var nextChannel = getNextChannel({
        channel,
        currentChannel,
        allChannels,
        disableAutoSelect
      });
      return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function(_a2) {
        var url = _a2.url;
        return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
      }) });
    }
    if (
      // When marking as read the channel
      unreadMessageCount === 0 && ((_c = (_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.sender) === null || _c === void 0 ? void 0 : _c.userId) !== currentUserId
    ) {
      return __assign(__assign({}, state), { allChannels: allChannels.map(function(ch) {
        return ch.url === (channel === null || channel === void 0 ? void 0 : channel.url) ? channel : ch;
      }) });
    }
    return __assign(__assign({}, state), { allChannels: __spreadArray([channel], allChannels.filter(function(_a2) {
      var url = _a2.url;
      return url !== channel.url;
    }), true) });
  }).with({ type: SET_CURRENT_CHANNEL }, function(action2) {
    return __assign(__assign({}, state), { currentChannel: action2.payload });
  }).with({ type: ON_LAST_MESSAGE_UPDATED }, function(action2) {
    return __assign(__assign({}, state), { allChannels: state.allChannels.map(function(channel) {
      return (channel === null || channel === void 0 ? void 0 : channel.url) === action2.payload.url ? action2.payload : channel;
    }) });
  }).with({ type: ON_CHANNEL_FROZEN }, function(action2) {
    var _a;
    var channel = action2.payload;
    var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;
    if (channelListQuery) {
      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {
        return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });
      }
      var nextChannel = getNextChannel({
        channel,
        currentChannel,
        allChannels,
        disableAutoSelect
      });
      return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function(_a2) {
        var url = _a2.url;
        return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
      }) });
    }
    return __assign(__assign({}, state), { allChannels: allChannels.map(function(ch) {
      if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        ch.isFrozen = true;
        return ch;
      }
      return ch;
    }) });
  }).with({ type: ON_CHANNEL_UNFROZEN }, function(action2) {
    var _a;
    var channel = action2.payload;
    var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;
    if (channelListQuery) {
      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {
        return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });
      }
      var nextChannel = getNextChannel({
        channel,
        currentChannel,
        allChannels,
        disableAutoSelect
      });
      return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function(_a2) {
        var url = _a2.url;
        return url !== (channel === null || channel === void 0 ? void 0 : channel.url);
      }) });
    }
    return __assign(__assign({}, state), { allChannels: allChannels.map(function(ch) {
      if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        ch.isFrozen = false;
        return ch;
      }
      return ch;
    }) });
  }).with({ type: CHANNEL_LIST_PARAMS_UPDATED }, function(action2) {
    return __assign(__assign({}, state), { channelListQuery: action2.payload.channelListQuery, currentUserId: action2.payload.currentUserId });
  }).otherwise(function() {
    return state;
  });
}
function useActiveChannelUrl(_a, _b) {
  var activeChannelUrl = _a.activeChannelUrl, channels = _a.channels, sdk = _a.sdk;
  var logger = _b.logger, channelListDispatcher = _b.channelListDispatcher;
  return (0, import_react.useEffect)(function() {
    var _a2;
    if (activeChannelUrl) {
      logger.info("ChannelListProvider: looking for active channel", { activeChannelUrl });
      var activeChannel = channels === null || channels === void 0 ? void 0 : channels.find(function(channel) {
        return channel.url === activeChannelUrl;
      });
      if (activeChannel) {
        channelListDispatcher({
          type: SET_CURRENT_CHANNEL,
          payload: activeChannel
        });
      } else {
        logger.info("ChannelListProvider: searching backend for active channel", { activeChannelUrl });
        (_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.getChannel(activeChannelUrl).then(function(channel) {
          channelListDispatcher({
            type: FETCH_CHANNELS_SUCCESS,
            payload: [channel]
          });
          channelListDispatcher({
            type: SET_CURRENT_CHANNEL,
            payload: channel
          });
        }).catch(function() {
          logger.warning("ChannelListProvider: Active channel not found");
        });
      }
    }
  }, [activeChannelUrl]);
}
var useFetchChannelList = function(_a, _b) {
  var channelSource = _a.channelSource, disableMarkAsDelivered = _a.disableMarkAsDelivered;
  var channelListDispatcher = _b.channelListDispatcher, logger = _b.logger, markAsDeliveredScheduler = _b.markAsDeliveredScheduler;
  return (0, import_react.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var channelList, error_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!(channelSource === null || channelSource === void 0 ? void 0 : channelSource.hasNext)) {
              logger.info("ChannelList: not able to fetch");
              return [
                2
                /*return*/
              ];
            }
            logger.info("ChannelList: starting fetch");
            channelListDispatcher({
              type: FETCH_CHANNELS_START,
              payload: null
            });
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, channelSource.next()];
          case 2:
            channelList = _a2.sent();
            logger.info("ChannelList: succeeded fetch", { channelList });
            channelListDispatcher({
              type: FETCH_CHANNELS_SUCCESS,
              payload: channelList
            });
            if (!disableMarkAsDelivered) {
              logger.info("ChannelList: mark as delivered to fetched channels");
              channelList === null || channelList === void 0 ? void 0 : channelList.forEach(function(channel) {
                if ((channel === null || channel === void 0 ? void 0 : channel.unreadMessageCount) > 0) {
                  markAsDeliveredScheduler.push(channel);
                }
              });
            }
            return [3, 4];
          case 3:
            error_1 = _a2.sent();
            logger.error("ChannelList: failed fetch", { error: error_1 });
            channelListDispatcher({
              type: FETCH_CHANNELS_FAILURE,
              payload: error_1
            });
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [
    channelSource,
    disableMarkAsDelivered
  ]);
};
function useHandleReconnectForChannelList(_a) {
  var isOnline = _a.isOnline, reconnectOnIdle = _a.reconnectOnIdle, logger = _a.logger, sdk = _a.sdk, currentGroupChannel = _a.currentGroupChannel, channelListDispatcher = _a.channelListDispatcher, setChannelSource = _a.setChannelSource, userFilledChannelListQuery = _a.userFilledChannelListQuery, sortChannelList = _a.sortChannelList, disableAutoSelect = _a.disableAutoSelect, markAsDeliveredScheduler = _a.markAsDeliveredScheduler, disableMarkAsDelivered = _a.disableMarkAsDelivered;
  var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;
  (0, import_react.useEffect)(function() {
    return function() {
      var _a2, _b, _c, _d;
      if (shouldReconnect) {
        logger.info("ChannelList refresh - creating query", { userFilledChannelListQuery });
        var channelListQuery = createChannelListQuery({ sdk, userFilledChannelListQuery });
        logger.info("ChannelList refresh - created query", channelListQuery);
        setChannelSource(channelListQuery);
        channelListDispatcher({
          type: INIT_CHANNELS_START,
          payload: {
            currentUserId: (_b = (_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a2 === void 0 ? void 0 : _a2.userId) !== null && _b !== void 0 ? _b : ""
          }
        });
        if (userFilledChannelListQuery) {
          logger.info("ChannelList refresh - setting up channelListQuery", channelListQuery);
          channelListDispatcher({
            type: CHANNEL_LIST_PARAMS_UPDATED,
            payload: {
              channelListQuery,
              currentUserId: (_d = (_c = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId) !== null && _d !== void 0 ? _d : ""
            }
          });
        }
        logger.info("ChannelList refresh - fetching channels");
        if (channelListQuery.hasNext) {
          channelListQuery.next().then(function(channelList) {
            var _a3, _b2;
            logger.info("ChannelList refresh - fetched channels", channelList);
            var sortedChannelList = channelList;
            if (sortChannelList && typeof sortChannelList === "function") {
              sortedChannelList = sortChannelList(channelList);
              logger.info("ChannelList refresh - channel list sorted", sortedChannelList);
            }
            var newCurrentChannel = !disableAutoSelect ? sortedChannelList[0] : null;
            if (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) {
              var foundChannel = sortedChannelList.find(function(channel) {
                return channel.url === currentGroupChannel.url;
              });
              if (foundChannel) {
                newCurrentChannel = foundChannel;
              }
            }
            logger.info("ChannelList refresh - highlight channel", newCurrentChannel);
            channelListDispatcher({
              type: REFRESH_CHANNELS_SUCCESS,
              payload: {
                channelList: sortedChannelList,
                currentChannel: newCurrentChannel
              }
            });
            var canSetMarkAsDelivered = (_b2 = (_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a3 === void 0 ? void 0 : _a3.premiumFeatureList) === null || _b2 === void 0 ? void 0 : _b2.find(function(feature) {
              return feature === DELIVERY_RECEIPT;
            });
            if (canSetMarkAsDelivered && !disableMarkAsDelivered) {
              sortedChannelList.forEach(function(channel) {
                markAsDeliveredScheduler.push(channel);
              });
            }
          }).catch(function(err) {
            if (err) {
              logger.error("ChannelList refresh - could not fetch channels", err);
              channelListDispatcher({
                type: INIT_CHANNELS_FAILURE
              });
            }
          });
        } else {
          logger.info("ChannelList refresh - there are no more channels");
        }
      }
    };
  }, [shouldReconnect]);
}
var ChannelListContext = import_react.default.createContext(null);
var ChannelListProvider = function(props) {
  var _a, _b;
  var children = props.children, className = props.className, disableUserProfile = props.disableUserProfile, allowProfileEdit = props.allowProfileEdit, queries = props.queries, onProfileEditSuccess = props.onProfileEditSuccess, onThemeChange = props.onThemeChange, onBeforeCreateChannel = props.onBeforeCreateChannel, sortChannelList = props.sortChannelList, overrideInviteUser = props.overrideInviteUser, activeChannelUrl = props.activeChannelUrl, _c = props.isTypingIndicatorEnabled, isTypingIndicatorEnabled = _c === void 0 ? null : _c, _d = props.isMessageReceiptStatusEnabled, isMessageReceiptStatusEnabled = _d === void 0 ? null : _d, reconnectOnIdle = props.reconnectOnIdle;
  var disableAutoSelect = (props === null || props === void 0 ? void 0 : props.disableAutoSelect) || !!activeChannelUrl;
  var onChannelSelect = (props === null || props === void 0 ? void 0 : props.onChannelSelect) || noop;
  var state = useSendbird().state;
  var config = state.config, stores = state.stores;
  var sdkStore = stores.sdkStore;
  var pubSub = config.pubSub, logger = config.logger;
  var markAsDeliveredScheduler = config.markAsDeliveredScheduler, _e = config.disableMarkAsDelivered, disableMarkAsDelivered = _e === void 0 ? false : _e, isOnline = config.isOnline;
  var sdk = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.sdk;
  var _f = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) !== null && _a !== void 0 ? _a : {}).premiumFeatureList, premiumFeatureList = _f === void 0 ? [] : _f;
  var enableEditProfile = allowProfileEdit || config.allowProfileEdit;
  var userFilledChannelListQuery = queries === null || queries === void 0 ? void 0 : queries.channelListQuery;
  var userFilledApplicationUserListQuery = queries === null || queries === void 0 ? void 0 : queries.applicationUserListQuery;
  var sdkIntialized = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;
  var _g = (0, import_react.useReducer)(channelListReducer, initialState), channelListStore = _g[0], channelListDispatcher = _g[1];
  var currentChannel = channelListStore.currentChannel;
  var _h = (0, import_react.useState)(null), channelSource = _h[0], setChannelSource = _h[1];
  var _j = (0, import_react.useState)([]), typingChannels = _j[0], setTypingChannels = _j[1];
  (0, import_react.useEffect)(function() {
    var subscriber = pubSubHandler(pubSub, channelListDispatcher);
    return function() {
      pubSubHandleRemover(subscriber);
    };
  }, [sdkIntialized]);
  (0, import_react.useEffect)(function() {
    var _a2;
    var sdkChannelHandlerId = uuidv4();
    if (sdkIntialized) {
      logger.info("ChannelList: Setup channelHandlers");
      setupChannelList({
        sdk,
        sdkChannelHandlerId,
        channelListDispatcher,
        setChannelSource,
        onChannelSelect,
        userFilledChannelListQuery: __assign({}, userFilledChannelListQuery),
        logger,
        sortChannelList,
        disableAutoSelect,
        markAsDeliveredScheduler,
        disableMarkAsDelivered
      });
    } else {
      logger.info("ChannelList: Removing channelHandlers");
      if ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.removeGroupChannelHandler) {
        sdk.groupChannel.removeGroupChannelHandler(sdkChannelHandlerId);
      }
      setChannelSource(null);
      channelListDispatcher({
        type: RESET_CHANNEL_LIST,
        payload: null
      });
    }
    return function() {
      var _a3, _b2;
      logger.info("ChannelList: Removing channelHandlers");
      if ((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler) {
        (_b2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b2 === void 0 ? void 0 : _b2.removeGroupChannelHandler(sdkChannelHandlerId);
      }
    };
  }, [
    sdkIntialized,
    sortChannelList,
    Object.entries(userFilledChannelListQuery !== null && userFilledChannelListQuery !== void 0 ? userFilledChannelListQuery : {}).map(function(_a2) {
      var key = _a2[0], value = _a2[1];
      return key + value;
    }).join()
  ]);
  (0, import_react.useEffect)(function() {
    var _a2, _b2;
    var typingHandlerId = "";
    if ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.addGroupChannelHandler) {
      typingHandlerId = uuidv4();
      var handler = new Ye({
        onTypingStatusUpdated: function(channel) {
          var _a3;
          var typingMemberCount = (_a3 = channel === null || channel === void 0 ? void 0 : channel.getTypingUsers()) === null || _a3 === void 0 ? void 0 : _a3.length;
          var channelList = typingChannels.filter(function(ch) {
            return ch.url !== channel.url;
          });
          if (typingMemberCount > 0) {
            setTypingChannels(__spreadArray(__spreadArray([], channelList, true), [channel], false));
          } else {
            setTypingChannels(channelList);
          }
        },
        onUnreadMemberStatusUpdated: function(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
        },
        onUndeliveredMemberStatusUpdated: function(channel) {
          channelListDispatcher({
            type: ON_LAST_MESSAGE_UPDATED,
            payload: channel
          });
        },
        onMessageUpdated: function(channel) {
          if (channel.isGroupChannel()) {
            channelListDispatcher({
              type: ON_LAST_MESSAGE_UPDATED,
              payload: channel
            });
            sdk.groupChannel.getChannelWithoutCache(channel.url).then(function(ch) {
              channelListDispatcher({
                type: ON_LAST_MESSAGE_UPDATED,
                payload: ch
              });
            });
          }
        },
        onMentionReceived: function(channel) {
          if (channel.isGroupChannel()) {
            channelListDispatcher({
              type: ON_LAST_MESSAGE_UPDATED,
              payload: channel
            });
            sdk.groupChannel.getChannelWithoutCache(channel.url).then(function(ch) {
              channelListDispatcher({
                type: ON_LAST_MESSAGE_UPDATED,
                payload: ch
              });
            });
          }
        }
      });
      (_b2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b2 === void 0 ? void 0 : _b2.addGroupChannelHandler(typingHandlerId, handler);
    }
    return function() {
      var _a3;
      if (((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler) && typingHandlerId !== "") {
        sdk.groupChannel.removeGroupChannelHandler(typingHandlerId);
      }
    };
  }, [(_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId]);
  var queries_ = (0, import_react.useMemo)(function() {
    return {
      applicationUserListQuery: userFilledApplicationUserListQuery,
      channelListQuery: userFilledChannelListQuery
    };
  }, [userFilledApplicationUserListQuery, userFilledChannelListQuery]);
  var allChannels = channelListStore.allChannels;
  var sortedChannels = sortChannelList && typeof sortChannelList === "function" ? sortChannelList(allChannels) : allChannels;
  if (sortedChannels.length !== allChannels.length) {
    var warning = "ChannelList: You have removed/added extra channels on sortChannelList\n      this could cause unexpected problems";
    console.warn(warning, { before: allChannels, after: sortedChannels });
    logger.warning(warning, { before: allChannels, after: sortedChannels });
  }
  (0, import_react.useEffect)(function() {
    if (!sdk || !sdk.groupChannel) {
      return;
    }
    if (!(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
      onChannelSelect(null);
      return;
    }
    sdk.groupChannel.getChannel(currentChannel.url).then(function(groupChannel) {
      if (groupChannel) {
        onChannelSelect(groupChannel);
      } else {
        onChannelSelect(null);
      }
    });
  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);
  useActiveChannelUrl({
    activeChannelUrl,
    channels: sortedChannels,
    sdk
  }, {
    logger,
    channelListDispatcher
  });
  useHandleReconnectForChannelList({
    isOnline,
    reconnectOnIdle,
    logger,
    sdk,
    currentGroupChannel: currentChannel,
    channelListDispatcher,
    setChannelSource,
    userFilledChannelListQuery,
    sortChannelList,
    disableAutoSelect,
    markAsDeliveredScheduler,
    disableMarkAsDelivered
  });
  var fetchChannelList = useFetchChannelList({
    channelSource,
    disableMarkAsDelivered: disableMarkAsDelivered || !premiumFeatureList.some(function(feature) {
      return feature === DELIVERY_RECEIPT;
    })
  }, {
    channelListDispatcher,
    logger,
    markAsDeliveredScheduler
  });
  return import_react.default.createElement(
    ChannelListContext.Provider,
    { value: __assign(__assign({ className, disableUserProfile, queries: queries_, onProfileEditSuccess, onThemeChange, onBeforeCreateChannel, overrideInviteUser, onChannelSelect, sortChannelList, allowProfileEdit: enableEditProfile, channelListDispatcher, channelSource }, channelListStore), { allChannels: sortedChannels, typingChannels, isTypingIndicatorEnabled: isTypingIndicatorEnabled !== null && isTypingIndicatorEnabled !== void 0 ? isTypingIndicatorEnabled : config.groupChannelList.enableTypingIndicator, isMessageReceiptStatusEnabled: isMessageReceiptStatusEnabled !== null && isMessageReceiptStatusEnabled !== void 0 ? isMessageReceiptStatusEnabled : config.groupChannelList.enableMessageReceiptStatus, fetchChannelList }) },
    import_react.default.createElement(
      UserProfileProvider,
      __assign({}, props),
      import_react.default.createElement("div", { className: "sendbird-channel-list ".concat(className) }, children)
    )
  );
};
function useChannelListContext() {
  var context = (0, import_react.useContext)(ChannelListContext);
  if (!context)
    throw new Error("ChannelListContext not found. Use within the ChannelList module.");
  return context;
}

// node_modules/@sendbird/uikit-react/chunks/bundle-DtQBJOWR.js
var pubSubFactory = function(opts) {
  var topics = {};
  return {
    __getTopics: function() {
      return topics;
    },
    subscribe: function(topic, listener) {
      var _a;
      (_a = topics[topic]) !== null && _a !== void 0 ? _a : topics[topic] = /* @__PURE__ */ new Set();
      topics[topic].add(listener);
      return {
        remove: function() {
          topics[topic].delete(listener);
        }
      };
    },
    publish: function(topic, info) {
      if (topics[topic]) {
        topics[topic].forEach(function(fn) {
          if (opts === null || opts === void 0 ? void 0 : opts.publishSynchronous) {
            fn(info !== void 0 ? info : {});
          } else {
            setTimeout(function() {
              return fn(info !== void 0 ? info : {});
            }, 0);
          }
        });
      }
    }
  };
};

// node_modules/@sendbird/uikit-react/chunks/bundle-Dx43PGfx.js
var import_react2 = __toESM(require_react(), 1);
function useDeepCompareMemoize(value) {
  var ref = (0, import_react2.useRef)(value);
  if (!isEqual$1(value, ref.current)) {
    ref.current = value;
  }
  return ref.current;
}
function useDeepCompareEffect(callback, dependencies) {
  (0, import_react2.useEffect)(callback, dependencies.map(useDeepCompareMemoize));
}

// node_modules/@sendbird/uikit-react/chunks/bundle-DPw-2E0C.js
var import_react3 = __toESM(require_react(), 1);
var pass = function(value) {
  return value;
};
function useMessageActions(params) {
  var _this = this;
  var _a = params.onBeforeSendUserMessage, onBeforeSendUserMessage = _a === void 0 ? pass : _a, _b = params.onBeforeSendFileMessage, onBeforeSendFileMessage = _b === void 0 ? pass : _b, _c = params.onBeforeUpdateUserMessage, onBeforeUpdateUserMessage = _c === void 0 ? pass : _c, _d = params.onBeforeSendVoiceMessage, onBeforeSendVoiceMessage = _d === void 0 ? pass : _d, _e = params.onBeforeSendMultipleFilesMessage, onBeforeSendMultipleFilesMessage = _e === void 0 ? pass : _e, sendFileMessage = params.sendFileMessage, sendMultipleFilesMessage = params.sendMultipleFilesMessage, sendUserMessage = params.sendUserMessage, updateUserMessage = params.updateUserMessage, updateFileMessage = params.updateFileMessage, resendMessage = params.resendMessage, deleteMessage = params.deleteMessage, resetNewMessages = params.resetNewMessages, scrollToBottom = params.scrollToBottom, quoteMessage = params.quoteMessage, replyType = params.replyType, currentChannel = params.currentChannel;
  var _f = useSendbird().state, eventHandlers = _f.eventHandlers, pubSub = _f.config.pubSub;
  var buildInternalMessageParams = (0, import_react3.useCallback)(function(basicParams) {
    var messageParams = __assign({}, basicParams);
    if (params.quoteMessage && replyType !== "NONE") {
      messageParams.isReplyToChannel = true;
      messageParams.parentMessageId = quoteMessage === null || quoteMessage === void 0 ? void 0 : quoteMessage.messageId;
    }
    return messageParams;
  }, [replyType, quoteMessage]);
  var asyncScrollToBottom = (0, import_react3.useCallback)(function() {
    setTimeout(scrollToBottom, 0);
  }, []);
  var processParams = (0, import_react3.useCallback)(function(handler, params2, type) {
    return __awaiter(_this, void 0, void 0, function() {
      var result, error_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, handler(params2)];
          case 1:
            result = _a2.sent();
            return [2, result === void 0 ? params2 : result];
          case 2:
            error_1 = _a2.sent();
            if (typeof (eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.message) === "object") {
              K(type).with("file", "voice", function() {
                var _a3, _b2, _c2, _d2;
                if (params2.file) {
                  (_b2 = (_a3 = eventHandlers.message).onFileUploadFailed) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, error_1);
                }
                (_d2 = (_c2 = eventHandlers.message).onSendMessageFailed) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, params2, error_1);
              }).with("multipleFiles", function() {
                var _a3, _b2, _c2, _d2;
                if (params2.fileInfoList) {
                  (_b2 = (_a3 = eventHandlers.message).onFileUploadFailed) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, error_1);
                }
                (_d2 = (_c2 = eventHandlers.message).onSendMessageFailed) === null || _d2 === void 0 ? void 0 : _d2.call(_c2, params2, error_1);
              }).with("user", function() {
                var _a3, _b2;
                (_b2 = (_a3 = eventHandlers.message).onSendMessageFailed) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, params2, error_1);
              }).with("update", function() {
                var _a3, _b2;
                (_b2 = (_a3 = eventHandlers.message).onUpdateMessageFailed) === null || _b2 === void 0 ? void 0 : _b2.call(_a3, params2, error_1);
              }).exhaustive();
            }
            throw error_1;
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [eventHandlers]);
  return {
    sendUserMessage: (0, import_react3.useCallback)(function(params2) {
      return __awaiter(_this, void 0, void 0, function() {
        var internalParams, processedParams;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              internalParams = buildInternalMessageParams(params2);
              return [4, processParams(onBeforeSendUserMessage, internalParams, "user")];
            case 1:
              processedParams = _a2.sent();
              return [2, sendUserMessage(processedParams, asyncScrollToBottom)];
          }
        });
      });
    }, [buildInternalMessageParams, sendUserMessage, scrollToBottom, processParams]),
    sendFileMessage: (0, import_react3.useCallback)(function(params2) {
      return __awaiter(_this, void 0, void 0, function() {
        var internalParams, processedParams;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              internalParams = buildInternalMessageParams(params2);
              return [4, processParams(onBeforeSendFileMessage, internalParams, "file")];
            case 1:
              processedParams = _a2.sent();
              return [2, sendFileMessage(processedParams, asyncScrollToBottom)];
          }
        });
      });
    }, [buildInternalMessageParams, sendFileMessage, scrollToBottom, processParams]),
    sendMultipleFilesMessage: (0, import_react3.useCallback)(function(params2) {
      return __awaiter(_this, void 0, void 0, function() {
        var internalParams, processedParams;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              internalParams = buildInternalMessageParams(params2);
              return [4, processParams(onBeforeSendMultipleFilesMessage, internalParams, "multipleFiles")];
            case 1:
              processedParams = _a2.sent();
              return [2, sendMultipleFilesMessage(processedParams, asyncScrollToBottom)];
          }
        });
      });
    }, [buildInternalMessageParams, sendMultipleFilesMessage, scrollToBottom, processParams]),
    sendVoiceMessage: (0, import_react3.useCallback)(function(params2, duration) {
      return __awaiter(_this, void 0, void 0, function() {
        var internalParams, processedParams;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              internalParams = buildInternalMessageParams(__assign(__assign({}, params2), { fileName: VOICE_MESSAGE_FILE_NAME, mimeType: VOICE_MESSAGE_MIME_TYPE, metaArrays: [
                new Ve({
                  key: META_ARRAY_VOICE_DURATION_KEY,
                  value: ["".concat(duration)]
                }),
                new Ve({
                  key: META_ARRAY_MESSAGE_TYPE_KEY,
                  value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]
                })
              ] }));
              return [4, processParams(onBeforeSendVoiceMessage, internalParams, "voice")];
            case 1:
              processedParams = _a2.sent();
              return [2, sendFileMessage(processedParams, asyncScrollToBottom)];
          }
        });
      });
    }, [buildInternalMessageParams, sendFileMessage, scrollToBottom, processParams]),
    updateUserMessage: (0, import_react3.useCallback)(function(messageId, params2) {
      return __awaiter(_this, void 0, void 0, function() {
        var internalParams, processedParams;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              internalParams = buildInternalMessageParams(params2);
              return [4, processParams(onBeforeUpdateUserMessage, internalParams, "update")];
            case 1:
              processedParams = _a2.sent();
              return [2, updateUserMessage(messageId, processedParams).then(function(message) {
                pubSub.publish(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, {
                  channel: currentChannel,
                  message,
                  publishingModules: [PublishingModuleType.CHANNEL]
                });
                return message;
              })];
          }
        });
      });
    }, [buildInternalMessageParams, updateUserMessage, processParams, currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]),
    updateFileMessage,
    resendMessage,
    deleteMessage,
    resetNewMessages
  };
}
var useGroupChannel = function() {
  var _a, _b, _c;
  var store = (0, import_react3.useContext)(GroupChannelContext);
  if (!store)
    throw new Error("useGroupChannel must be used within a GroupChannelProvider");
  var config = useSendbird().state.config;
  var markAsReadScheduler = config.markAsReadScheduler;
  var state = shimExports.useSyncExternalStore(store.subscribe, store.getState);
  var setAnimatedMessageId = (0, import_react3.useCallback)(function(messageId) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { animatedMessageId: messageId });
    });
  }, []);
  var setIsScrollBottomReached = (0, import_react3.useCallback)(function(isReached) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { isScrollBottomReached: isReached });
    });
  }, []);
  var scrollToBottom = (0, import_react3.useCallback)(function(animated) {
    return __awaiter(void 0, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!state.scrollRef.current)
              return [
                2
                /*return*/
              ];
            setAnimatedMessageId(null);
            setIsScrollBottomReached(true);
            return [4, delay()];
          case 1:
            _a2.sent();
            if (!(config.isOnline && state.hasNext()))
              return [3, 3];
            return [4, state.resetWithStartingPoint(Number.MAX_SAFE_INTEGER)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            state.scrollPubSub.publish("scrollToBottom", { animated });
            if (state.currentChannel && !state.hasNext()) {
              state.resetNewMessages();
              if (!state.disableMarkAsRead) {
                markAsReadScheduler.push(state.currentChannel);
              }
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [state.scrollRef.current, config.isOnline, markAsReadScheduler]);
  var scrollToMessage = (0, import_react3.useCallback)(function(createdAt, messageId, messageFocusAnimated, scrollAnimated) {
    return __awaiter(void 0, void 0, void 0, function() {
      var element, parentNode, clickHandler, message, topOffset;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            element = state.scrollRef.current;
            parentNode = element === null || element === void 0 ? void 0 : element.parentNode;
            clickHandler = {
              activate: function() {
                if (!element || !parentNode)
                  return;
                element.style.pointerEvents = "auto";
                parentNode.style.cursor = "auto";
              },
              deactivate: function() {
                if (!element || !parentNode)
                  return;
                element.style.pointerEvents = "none";
                parentNode.style.cursor = "wait";
              }
            };
            clickHandler.deactivate();
            setAnimatedMessageId(null);
            message = state.messages.find(function(it) {
              return it.messageId === messageId || it.createdAt === createdAt;
            });
            if (!message)
              return [3, 1];
            topOffset = getMessageTopOffset(message.createdAt);
            if (topOffset)
              state.scrollPubSub.publish("scroll", { top: topOffset, animated: scrollAnimated });
            if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true)
              setAnimatedMessageId(messageId);
            return [3, 3];
          case 1:
            return [4, state.resetWithStartingPoint(createdAt)];
          case 2:
            _a2.sent();
            setTimeout(function() {
              var topOffset2 = getMessageTopOffset(createdAt);
              if (topOffset2) {
                state.scrollPubSub.publish("scroll", {
                  top: topOffset2,
                  lazy: false,
                  animated: scrollAnimated
                });
              }
              if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true)
                setAnimatedMessageId(messageId);
            });
            _a2.label = 3;
          case 3:
            clickHandler.activate();
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [setAnimatedMessageId, state.scrollRef.current, (_a = state.messages) === null || _a === void 0 ? void 0 : _a.map(function(it) {
    return it === null || it === void 0 ? void 0 : it.messageId;
  })]);
  var toggleReaction = (0, import_react3.useCallback)(function(message, emojiKey, isReacted) {
    if (!state.currentChannel)
      return;
    if (isReacted) {
      state.currentChannel.deleteReaction(message, emojiKey).catch(function(error) {
        var _a2;
        (_a2 = config.logger) === null || _a2 === void 0 ? void 0 : _a2.warning("Failed to delete reaction:", error);
      });
    } else {
      state.currentChannel.addReaction(message, emojiKey).catch(function(error) {
        var _a2;
        (_a2 = config.logger) === null || _a2 === void 0 ? void 0 : _a2.warning("Failed to add reaction:", error);
      });
    }
  }, [(_b = state.currentChannel) === null || _b === void 0 ? void 0 : _b.deleteReaction, (_c = state.currentChannel) === null || _c === void 0 ? void 0 : _c.addReaction]);
  var messageActions = useMessageActions(__assign(__assign({}, state), { scrollToBottom }));
  var setCurrentChannel = (0, import_react3.useCallback)(function(channel) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { currentChannel: channel, fetchChannelError: null, quoteMessage: null, animatedMessageId: null, nicknamesMap: new Map(channel.members.map(function(_a2) {
        var userId = _a2.userId, nickname = _a2.nickname;
        return [userId, nickname];
      })) });
    }, true);
  }, []);
  var handleChannelError = (0, import_react3.useCallback)(function(error) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { currentChannel: null, fetchChannelError: error, quoteMessage: null, animatedMessageId: null });
    });
  }, []);
  var setQuoteMessage = (0, import_react3.useCallback)(function(message) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { quoteMessage: message });
    });
  }, []);
  var actions = (0, import_react3.useMemo)(function() {
    return __assign({ setCurrentChannel, handleChannelError, setQuoteMessage, scrollToBottom, scrollToMessage, toggleReaction, setAnimatedMessageId, setIsScrollBottomReached }, messageActions);
  }, [
    setCurrentChannel,
    handleChannelError,
    setQuoteMessage,
    scrollToBottom,
    scrollToMessage,
    toggleReaction,
    setAnimatedMessageId,
    setIsScrollBottomReached,
    messageActions
  ]);
  return { state, actions };
};
function useMessageListScroll(behavior, deps) {
  if (deps === void 0) {
    deps = [];
  }
  var scrollRef = (0, import_react3.useRef)(null);
  var scrollPositionRef = (0, import_react3.useRef)(0);
  var scrollDistanceFromBottomRef = (0, import_react3.useRef)(0);
  var scrollPubSub = (0, import_react3.useState)(function() {
    return pubSubFactory({ publishSynchronous: true });
  })[0];
  var setIsScrollBottomReached = useGroupChannel().actions.setIsScrollBottomReached;
  (0, import_react3.useLayoutEffect)(function() {
    scrollPositionRef.current = 0;
    scrollDistanceFromBottomRef.current = 0;
    setIsScrollBottomReached(true);
    if (scrollRef.current)
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
  }, deps);
  (0, import_react3.useLayoutEffect)(function() {
    var unsubscribes = [];
    unsubscribes.push(scrollPubSub.subscribe("scrollToBottom", function(_a) {
      var resolve = _a.resolve, animated = _a.animated;
      runCallback(function() {
        if (!scrollRef.current) {
          if (resolve)
            resolve();
          return;
        }
        if (scrollRef.current.scroll) {
          scrollRef.current.scroll({ top: scrollRef.current.scrollHeight, behavior: getScrollBehavior(behavior, animated) });
        } else {
          scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }
        scrollDistanceFromBottomRef.current = 0;
        setIsScrollBottomReached(true);
        if (resolve)
          resolve();
      });
    }));
    unsubscribes.push(scrollPubSub.subscribe("scroll", function(_a) {
      var top = _a.top, animated = _a.animated, lazy = _a.lazy, resolve = _a.resolve;
      runCallback(function() {
        if (!scrollRef.current)
          return;
        var _a2 = scrollRef.current, scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
        if (scrollRef.current.scroll) {
          scrollRef.current.scroll({ top, behavior: getScrollBehavior(behavior, animated) });
        } else if (typeof top === "number") {
          scrollRef.current.scrollTop = top;
        }
        scrollDistanceFromBottomRef.current = Math.max(0, scrollHeight - scrollTop - clientHeight);
        setIsScrollBottomReached(scrollDistanceFromBottomRef.current === 0);
        if (resolve)
          resolve();
      }, lazy);
    }));
    return function() {
      unsubscribes.forEach(function(_a) {
        var remove = _a.remove;
        return remove();
      });
    };
  }, [behavior]);
  return {
    scrollRef,
    scrollPubSub,
    scrollDistanceFromBottomRef,
    scrollPositionRef
  };
}
function runCallback(callback, lazy) {
  if (lazy === void 0) {
    lazy = true;
  }
  if (lazy) {
    setTimeout(function() {
      callback();
    });
  } else {
    callback();
  }
}
function getScrollBehavior(behavior, animated) {
  if (typeof animated === "boolean")
    return animated ? "smooth" : "auto";
  return behavior;
}
var initialState2 = {
  currentChannel: null,
  channelUrl: "",
  fetchChannelError: null,
  nicknamesMap: /* @__PURE__ */ new Map(),
  messages: [],
  quoteMessage: null,
  animatedMessageId: null,
  isScrollBottomReached: true,
  scrollRef: { current: null },
  scrollDistanceFromBottomRef: { current: 0 },
  scrollPositionRef: { current: 0 },
  messageInputRef: { current: null },
  isReactionEnabled: false,
  isMessageGroupingEnabled: true,
  isMultipleFilesMessageEnabled: false,
  showSearchIcon: true,
  replyType: "NONE",
  threadReplySelectType: ThreadReplySelectType.PARENT,
  disableMarkAsRead: false,
  scrollBehavior: "auto",
  scrollPubSub: null
};
var GroupChannelContext = (0, import_react3.createContext)(null);
var createGroupChannelStore = function(props) {
  return createStore(__assign(__assign({}, initialState2), props));
};
var InternalGroupChannelProvider = function(props) {
  var children = props.children;
  var defaultProps = deleteNullish({
    channelUrl: props === null || props === void 0 ? void 0 : props.channelUrl,
    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,
    disableUserProfile: props === null || props === void 0 ? void 0 : props.disableUserProfile,
    onUserProfileMessage: props === null || props === void 0 ? void 0 : props.onUserProfileMessage,
    onStartDirectMessage: props === null || props === void 0 ? void 0 : props.onStartDirectMessage,
    isReactionEnabled: props === null || props === void 0 ? void 0 : props.isReactionEnabled,
    isMessageGroupingEnabled: props === null || props === void 0 ? void 0 : props.isMessageGroupingEnabled,
    isMultipleFilesMessageEnabled: props === null || props === void 0 ? void 0 : props.isMultipleFilesMessageEnabled,
    showSearchIcon: props === null || props === void 0 ? void 0 : props.showSearchIcon,
    threadReplySelectType: props === null || props === void 0 ? void 0 : props.threadReplySelectType,
    disableMarkAsRead: props === null || props === void 0 ? void 0 : props.disableMarkAsRead,
    scrollBehavior: props === null || props === void 0 ? void 0 : props.scrollBehavior,
    forceLeftToRightMessageLayout: props === null || props === void 0 ? void 0 : props.forceLeftToRightMessageLayout,
    startingPoint: props === null || props === void 0 ? void 0 : props.startingPoint,
    animatedMessageId: props === null || props === void 0 ? void 0 : props.animatedMessageId,
    onMessageAnimated: props === null || props === void 0 ? void 0 : props.onMessageAnimated,
    messageListQueryParams: props === null || props === void 0 ? void 0 : props.messageListQueryParams,
    filterEmojiCategoryIds: props === null || props === void 0 ? void 0 : props.filterEmojiCategoryIds,
    onBeforeSendUserMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendUserMessage,
    onBeforeSendFileMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendFileMessage,
    onBeforeSendVoiceMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendVoiceMessage,
    onBeforeSendMultipleFilesMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendMultipleFilesMessage,
    onBeforeUpdateUserMessage: props === null || props === void 0 ? void 0 : props.onBeforeUpdateUserMessage,
    onBeforeDownloadFileMessage: props === null || props === void 0 ? void 0 : props.onBeforeDownloadFileMessage,
    onBackClick: props === null || props === void 0 ? void 0 : props.onBackClick,
    onChatHeaderActionClick: props === null || props === void 0 ? void 0 : props.onChatHeaderActionClick,
    onReplyInThreadClick: props === null || props === void 0 ? void 0 : props.onReplyInThreadClick,
    onSearchClick: props === null || props === void 0 ? void 0 : props.onSearchClick,
    onQuoteMessageClick: props === null || props === void 0 ? void 0 : props.onQuoteMessageClick,
    renderUserMentionItem: props === null || props === void 0 ? void 0 : props.renderUserMentionItem
  });
  var storeRef = (0, import_react3.useRef)(createGroupChannelStore(defaultProps));
  return import_react3.default.createElement(GroupChannelContext.Provider, { value: storeRef.current }, children);
};
var GroupChannelManager = function(props) {
  var _a, _b, _c;
  var channelUrl = props.channelUrl, children = props.children, moduleReactionEnabled = props.isReactionEnabled, moduleReplyType = props.replyType, moduleThreadReplySelectType = props.threadReplySelectType, _d = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _d === void 0 ? true : _d, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, showSearchIcon = props.showSearchIcon, _e = props.disableMarkAsRead, disableMarkAsRead = _e === void 0 ? false : _e, _f = props.scrollBehavior, scrollBehavior = _f === void 0 ? "auto" : _f, startingPoint = props.startingPoint, _animatedMessageId = props.animatedMessageId, messageListQueryParams = props.messageListQueryParams, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage, onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage, onMessageAnimated = props.onMessageAnimated, onBackClick = props.onBackClick, onChatHeaderActionClick = props.onChatHeaderActionClick, onReplyInThreadClick = props.onReplyInThreadClick, onSearchClick = props.onSearchClick, onQuoteMessageClick = props.onQuoteMessageClick, renderUserMentionItem = props.renderUserMentionItem, filterEmojiCategoryIds = props.filterEmojiCategoryIds;
  var _g = useGroupChannel(), state = _g.state, actions = _g.actions;
  var updateState = useGroupChannelStore().updateState;
  var _h = useSendbird().state, config = _h.config, stores = _h.stores;
  var sdkStore = stores.sdkStore;
  var markAsReadScheduler = config.markAsReadScheduler, logger = config.logger, pubSub = config.pubSub;
  var _j = useMessageListScroll(scrollBehavior, [(_a = state.currentChannel) === null || _a === void 0 ? void 0 : _a.url]), scrollRef = _j.scrollRef, scrollPubSub = _j.scrollPubSub, scrollDistanceFromBottomRef = _j.scrollDistanceFromBottomRef, scrollPositionRef = _j.scrollPositionRef;
  var isScrollBottomReached = state.isScrollBottomReached;
  var resolvedReplyType = getCaseResolvedReplyType(moduleReplyType !== null && moduleReplyType !== void 0 ? moduleReplyType : config.groupChannel.replyType).upperCase;
  var resolvedThreadReplySelectType = getCaseResolvedThreadReplySelectType(moduleThreadReplySelectType !== null && moduleThreadReplySelectType !== void 0 ? moduleThreadReplySelectType : config.groupChannel.threadReplySelectType).upperCase;
  var replyType = getCaseResolvedReplyType(moduleReplyType !== null && moduleReplyType !== void 0 ? moduleReplyType : config.groupChannel.replyType).upperCase;
  var resolvedIsReactionEnabled = getIsReactionEnabled({
    channel: state.currentChannel,
    config,
    moduleLevel: moduleReactionEnabled
  });
  var chatReplyType = useIIFE(function() {
    if (replyType === "NONE")
      return Q.NONE;
    return Q.ONLY_REPLY_TO_CHANNEL;
  });
  var messageDataSource = useGroupChannelMessages(sdkStore.sdk, state.currentChannel, {
    startingPoint,
    replyType: chatReplyType,
    collectionCreator: getCollectionCreator(state.currentChannel, messageListQueryParams),
    shouldCountNewMessages: function() {
      return !isScrollBottomReached;
    },
    markAsRead: function(channels) {
      if (isScrollBottomReached && !disableMarkAsRead) {
        channels.forEach(function(it) {
          return markAsReadScheduler.push(it);
        });
      }
    },
    onMessagesReceived: function(messages) {
      if (isScrollBottomReached && isContextMenuClosed() && messages.length !== state.messages.length) {
        setTimeout(function() {
          return actions.scrollToBottom(true);
        }, 10);
      }
    },
    onChannelDeleted: function() {
      actions.setCurrentChannel(null);
      onBackClick === null || onBackClick === void 0 ? void 0 : onBackClick();
    },
    onCurrentUserBanned: function() {
      actions.setCurrentChannel(null);
      onBackClick === null || onBackClick === void 0 ? void 0 : onBackClick();
    },
    onChannelUpdated: function(channel) {
      actions.setCurrentChannel(channel);
    },
    logger
  });
  useAsyncEffect(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var channel, error_1;
      var _a2;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            if (!(sdkStore.initialized && channelUrl))
              return [3, 4];
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, 3, , 4]);
            return [4, sdkStore.sdk.groupChannel.getChannel(channelUrl)];
          case 2:
            channel = _b2.sent();
            actions.setCurrentChannel(channel);
            return [3, 4];
          case 3:
            error_1 = _b2.sent();
            actions.handleChannelError(error_1);
            (_a2 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "GroupChannelProvider: error when fetching channel", error_1);
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [sdkStore.initialized, sdkStore.sdk, channelUrl]);
  useAsyncLayoutEffect(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var handleExternalMessage, subscriptions;
      return __generator(this, function(_a2) {
        if (messageDataSource.initialized) {
          actions.scrollToBottom();
        }
        handleExternalMessage = function(data) {
          var _a3;
          if (data.channel.url === ((_a3 = state.currentChannel) === null || _a3 === void 0 ? void 0 : _a3.url)) {
            actions.scrollToBottom(true);
          }
        };
        if ((pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) === void 0)
          return [
            2
            /*return*/
          ];
        subscriptions = [
          config.pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, handleExternalMessage),
          config.pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, handleExternalMessage)
        ];
        return [2, function() {
          subscriptions.forEach(function(subscription) {
            return subscription.remove();
          });
        }];
      });
    });
  }, [messageDataSource.initialized, (_b = state.currentChannel) === null || _b === void 0 ? void 0 : _b.url]);
  (0, import_react3.useEffect)(function() {
    if (typeof startingPoint === "number") {
      actions.scrollToMessage(startingPoint, 0, false, false);
    }
  }, [startingPoint]);
  (0, import_react3.useEffect)(function() {
    if (_animatedMessageId) {
      actions.setAnimatedMessageId(_animatedMessageId);
    }
  }, [_animatedMessageId]);
  var eventHandlers = (0, import_react3.useMemo)(function() {
    return {
      onBeforeSendUserMessage,
      onBeforeSendFileMessage,
      onBeforeSendVoiceMessage,
      onBeforeSendMultipleFilesMessage,
      onBeforeUpdateUserMessage,
      onBeforeDownloadFileMessage,
      onBackClick,
      onChatHeaderActionClick,
      onReplyInThreadClick,
      onSearchClick,
      onQuoteMessageClick,
      onMessageAnimated
    };
  }, [
    onBeforeSendUserMessage,
    onBeforeSendFileMessage,
    onBeforeSendVoiceMessage,
    onBeforeSendMultipleFilesMessage,
    onBeforeUpdateUserMessage,
    onBeforeDownloadFileMessage,
    onBackClick,
    onChatHeaderActionClick,
    onReplyInThreadClick,
    onSearchClick,
    onQuoteMessageClick,
    onMessageAnimated
  ]);
  var renderProps = (0, import_react3.useMemo)(function() {
    return {
      renderUserMentionItem,
      filterEmojiCategoryIds
    };
  }, [renderUserMentionItem, filterEmojiCategoryIds]);
  var configurations = (0, import_react3.useMemo)(function() {
    return {
      isReactionEnabled: resolvedIsReactionEnabled,
      isMessageGroupingEnabled,
      isMultipleFilesMessageEnabled,
      replyType: resolvedReplyType,
      threadReplySelectType: resolvedThreadReplySelectType,
      showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : config.groupChannelSettings.enableMessageSearch,
      disableMarkAsRead,
      scrollBehavior
    };
  }, [
    resolvedIsReactionEnabled,
    isMessageGroupingEnabled,
    isMultipleFilesMessageEnabled,
    resolvedReplyType,
    resolvedThreadReplySelectType,
    showSearchIcon,
    disableMarkAsRead,
    scrollBehavior,
    config.groupChannelSettings.enableMessageSearch
  ]);
  var scrollState = (0, import_react3.useMemo)(function() {
    return {
      scrollRef,
      scrollPubSub,
      scrollDistanceFromBottomRef,
      scrollPositionRef,
      isScrollBottomReached
    };
  }, [
    scrollRef,
    scrollPubSub,
    scrollDistanceFromBottomRef,
    scrollPositionRef,
    isScrollBottomReached
  ]);
  useDeepCompareEffect(function() {
    updateState(__assign(__assign(__assign(__assign(__assign({
      // Channel state
      channelUrl,
      currentChannel: state.currentChannel
    }, configurations), scrollState), eventHandlers), renderProps), messageDataSource));
  }, [
    channelUrl,
    (_c = state.currentChannel) === null || _c === void 0 ? void 0 : _c.serialize(),
    configurations,
    scrollState,
    eventHandlers,
    renderProps,
    messageDataSource.initialized,
    messageDataSource.loading,
    messageDataSource.messages.map(function(it) {
      return it.serialize();
    })
  ]);
  return children;
};
var GroupChannelProvider = function(props) {
  return import_react3.default.createElement(
    InternalGroupChannelProvider,
    __assign({}, props),
    import_react3.default.createElement(
      GroupChannelManager,
      __assign({}, props),
      import_react3.default.createElement(UserProfileProvider, __assign({}, props), props.children)
    )
  );
};
var useGroupChannelStore = function() {
  return useStore(GroupChannelContext, function(state) {
    return state;
  }, initialState2);
};
var useGroupChannelContext = function() {
  var _a = useGroupChannel(), state = _a.state, actions = _a.actions;
  return __assign(__assign({}, state), actions);
};
function getCollectionCreator(groupChannel, messageListQueryParams) {
  return function(defaultParams) {
    var params = __assign(__assign(__assign({}, defaultParams), { prevResultLimit: 30, nextResultLimit: 30 }), messageListQueryParams);
    return groupChannel.createMessageCollection(__assign(__assign({}, params), { filter: new qs(params) }));
  };
}

// node_modules/@sendbird/uikit-react/GroupChannel/components/GroupChannelHeader.js
var import_react4 = __toESM(require_react(), 1);
var GroupChannelHeader = function(props) {
  var context = useGroupChannelContext();
  return import_react4.default.createElement(GroupChannelHeaderView, __assign({}, props, context, { currentChannel: context.currentChannel }));
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/FileViewer.js
var import_react5 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var FileViewer2 = function(props) {
  var _a = useGroupChannel(), onBeforeDownloadFileMessage = _a.state.onBeforeDownloadFileMessage, deleteMessage = _a.actions.deleteMessage;
  var logger = useSendbird().state.config.logger;
  return import_react5.default.createElement(FileViewerView, __assign({}, props, { deleteMessage, onDownloadClick: function(e) {
    return __awaiter(void 0, void 0, void 0, function() {
      var allowDownload, err_1;
      var _a2, _b;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            if (!onBeforeDownloadFileMessage)
              return [
                2
                /*return*/
              ];
            _c.label = 1;
          case 1:
            _c.trys.push([1, 3, , 4]);
            return [4, onBeforeDownloadFileMessage({ message: props.message })];
          case 2:
            allowDownload = _c.sent();
            if (!allowDownload) {
              e.preventDefault();
              (_a2 = logger.info) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "FileViewer: Not allowed to download.");
            }
            return [3, 4];
          case 3:
            err_1 = _c.sent();
            (_b = logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, "FileViewer: Error occurred while determining download continuation:", err_1);
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  } }));
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/RemoveMessageModal.js
var import_react6 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
var RemoveMessageModal = function(props) {
  var deleteMessage = useGroupChannel().actions.deleteMessage;
  return import_react6.default.createElement(RemoveMessageModalView, __assign({}, props, { deleteMessage }));
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/Message.js
var import_react7 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
var Message = function(props) {
  var state = useSendbird().state;
  var config = state.config, emojiManager = state.emojiManager;
  var _a = useGroupChannel(), _b = _a.state, loading = _b.loading, currentChannel = _b.currentChannel, animatedMessageId = _b.animatedMessageId, replyType = _b.replyType, threadReplySelectType = _b.threadReplySelectType, isReactionEnabled = _b.isReactionEnabled, nicknamesMap = _b.nicknamesMap, renderUserMentionItem = _b.renderUserMentionItem, filterEmojiCategoryIds = _b.filterEmojiCategoryIds, onQuoteMessageClick = _b.onQuoteMessageClick, onReplyInThreadClick = _b.onReplyInThreadClick, onMessageAnimated = _b.onMessageAnimated, onBeforeDownloadFileMessage = _b.onBeforeDownloadFileMessage, messages = _b.messages, _c = _a.actions, toggleReaction = _c.toggleReaction, setQuoteMessage = _c.setQuoteMessage, setAnimatedMessageId = _c.setAnimatedMessageId, scrollToMessage = _c.scrollToMessage, updateUserMessage = _c.updateUserMessage, sendUserMessage = _c.sendUserMessage, resendMessage = _c.resendMessage, deleteMessage = _c.deleteMessage;
  var message = props.message;
  var initialized = !loading && Boolean(currentChannel);
  var shouldRenderSuggestedReplies = useIIFE(function() {
    var _a2 = config.groupChannel, enableSuggestedReplies = _a2.enableSuggestedReplies, showSuggestedRepliesFor = _a2.showSuggestedRepliesFor;
    var lastMessageInView = messages[messages.length - 1];
    var hasUnsentMessage = isSendableMessage(lastMessageInView) && lastMessageInView.sendingStatus !== "succeeded";
    var showSuggestedReplies = showSuggestedRepliesFor === "all_messages" ? true : message.messageId === lastMessageInView.messageId;
    return enableSuggestedReplies && getSuggestedReplies(message).length > 0 && !hasUnsentMessage && showSuggestedReplies;
  });
  return import_react7.default.createElement(MessageView, __assign({}, props, { channel: currentChannel, emojiContainer: emojiManager.emojiContainer, editInputDisabled: !initialized || isDisabledBecauseFrozen(currentChannel !== null && currentChannel !== void 0 ? currentChannel : void 0) || isDisabledBecauseMuted(currentChannel !== null && currentChannel !== void 0 ? currentChannel : void 0) || !config.isOnline, shouldRenderSuggestedReplies, isReactionEnabled: isReactionEnabled !== null && isReactionEnabled !== void 0 ? isReactionEnabled : false, replyType: replyType !== null && replyType !== void 0 ? replyType : "NONE", threadReplySelectType: threadReplySelectType !== null && threadReplySelectType !== void 0 ? threadReplySelectType : ThreadReplySelectType.PARENT, nicknamesMap, renderUserMentionItem, filterEmojiCategoryIds, scrollToMessage, toggleReaction, setQuoteMessage, onQuoteMessageClick, onReplyInThreadClick, sendUserMessage, updateUserMessage, resendMessage, deleteMessage, animatedMessageId, setAnimatedMessageId, onMessageAnimated, renderFileViewer: function(props2) {
    return import_react7.default.createElement(FileViewer2, __assign({}, props2));
  }, renderRemoveMessageModal: function(props2) {
    return import_react7.default.createElement(RemoveMessageModal, __assign({}, props2));
  }, usedInLegacy: false, onBeforeDownloadFileMessage }));
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/MessageList.js
var import_react8 = __toESM(require_react(), 1);
var import_react_dom4 = __toESM(require_react_dom(), 1);
var InfiniteList = (0, import_react8.forwardRef)(function(props, listRef) {
  var messages = props.messages, renderMessage = props.renderMessage, scrollPositionRef = props.scrollPositionRef, scrollDistanceFromBottomRef = props.scrollDistanceFromBottomRef, onLoadPrevious = props.onLoadPrevious, onLoadNext = props.onLoadNext, _a = props.loadThreshold, loadThreshold = _a === void 0 ? 0.05 : _a, typingIndicator = props.typingIndicator, _b = props.onScrollPosition, onScrollPosition = _b === void 0 ? noop : _b, initDeps = props.initDeps;
  var isFetching = import_react8.default.useRef(false);
  var direction = import_react8.default.useRef();
  var oldScrollTop = (0, import_react8.useRef)(0);
  (0, import_react8.useLayoutEffect)(function() {
    if (listRef.current) {
      listRef.current.scrollTop = listRef.current.scrollHeight;
    }
  }, initDeps);
  (0, import_react8.useLayoutEffect)(function() {
    if (listRef.current) {
      if (direction.current === "top") {
        listRef.current.scrollTop = listRef.current.scrollHeight - scrollPositionRef.current;
      }
      if (direction.current === "bottom") {
        listRef.current.scrollTop = oldScrollTop.current;
      }
      direction.current = void 0;
    }
  }, [listRef.current, messages.length]);
  var handleScroll = (0, import_react8.useCallback)(function() {
    return __awaiter(void 0, void 0, void 0, function() {
      var list, threshold;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!listRef.current)
              return [
                2
                /*return*/
              ];
            list = listRef.current;
            onScrollPosition(getReachedStatus(list));
            scrollPositionRef.current = list.scrollHeight - list.scrollTop;
            scrollDistanceFromBottomRef.current = scrollPositionRef.current - list.clientHeight;
            oldScrollTop.current = list.scrollTop;
            if (isFetching.current)
              return [
                2
                /*return*/
              ];
            threshold = list.clientHeight * Math.min(Math.max(0, loadThreshold), 1);
            if (!(list.scrollTop <= threshold))
              return [3, 2];
            isFetching.current = true;
            direction.current = "top";
            return [4, onLoadPrevious()];
          case 1:
            _a2.sent();
            isFetching.current = false;
            return [3, 5];
          case 2:
            if (!(list.scrollHeight - list.scrollTop - list.clientHeight <= threshold))
              return [3, 4];
            isFetching.current = true;
            direction.current = "bottom";
            return [4, onLoadNext()];
          case 3:
            _a2.sent();
            isFetching.current = false;
            return [3, 5];
          case 4:
            direction.current = void 0;
            _a2.label = 5;
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [messages.length]);
  return import_react8.default.createElement(
    "div",
    { className: "sendbird-conversation__scroll-container" },
    import_react8.default.createElement("div", { className: "sendbird-conversation__padding" }),
    import_react8.default.createElement(
      "div",
      { ref: listRef, className: "sendbird-conversation__messages-padding", "data-testid": "sendbird-message-list-container", onScroll: handleScroll },
      messages.map(function(message, index) {
        return renderMessage({ message, index });
      }),
      typingIndicator
    )
  );
});
function getReachedStatus(element) {
  if (isAboutSame(element.scrollTop, 0, SCROLL_BUFFER)) {
    return "top";
  }
  if (isAboutSame(element.scrollHeight, element.clientHeight + element.scrollTop, SCROLL_BUFFER)) {
    return "bottom";
  }
  return "middle";
}
var MessageList = function(props) {
  var _a, _b, _c, _d, _e;
  var _f = props.className, className = _f === void 0 ? "" : _f;
  var _g = deleteNullish(props), _h = _g.renderMessage, renderMessage = _h === void 0 ? function(props2) {
    return import_react8.default.createElement(Message, __assign({}, props2));
  } : _h, renderMessageContent = _g.renderMessageContent, renderSuggestedReplies = _g.renderSuggestedReplies, renderCustomSeparator = _g.renderCustomSeparator, _j = _g.renderPlaceholderLoader, renderPlaceholderLoader = _j === void 0 ? function() {
    return import_react8.default.createElement(PlaceHolder, { type: PlaceHolderTypes.LOADING });
  } : _j, _k = _g.renderPlaceholderEmpty, renderPlaceholderEmpty = _k === void 0 ? function() {
    return import_react8.default.createElement(PlaceHolder, { className: "sendbird-conversation__no-messages", type: PlaceHolderTypes.NO_MESSAGES });
  } : _k, _l = _g.renderFrozenNotification, renderFrozenNotification = _l === void 0 ? function() {
    return import_react8.default.createElement(FrozenNotification, { className: "sendbird-conversation__messages__notification" });
  } : _l;
  var _m = useGroupChannel(), _o = _m.state, channelUrl = _o.channelUrl, hasNext = _o.hasNext, loading = _o.loading, messages = _o.messages, newMessages = _o.newMessages, isScrollBottomReached = _o.isScrollBottomReached, isMessageGroupingEnabled = _o.isMessageGroupingEnabled, currentChannel = _o.currentChannel, replyType = _o.replyType, scrollPubSub = _o.scrollPubSub, loadNext = _o.loadNext, loadPrevious = _o.loadPrevious, resetNewMessages = _o.resetNewMessages, scrollRef = _o.scrollRef, scrollPositionRef = _o.scrollPositionRef, scrollDistanceFromBottomRef = _o.scrollDistanceFromBottomRef, _p = _m.actions, scrollToBottom = _p.scrollToBottom, setIsScrollBottomReached = _p.setIsScrollBottomReached;
  var state = useSendbird().state;
  var stringSet = useLocalization().stringSet;
  var _q = (0, import_react8.useState)(), unreadSinceDate = _q[0], setUnreadSinceDate = _q[1];
  (0, import_react8.useEffect)(function() {
    if (isScrollBottomReached) {
      setUnreadSinceDate(void 0);
    } else {
      setUnreadSinceDate(/* @__PURE__ */ new Date());
    }
  }, [isScrollBottomReached]);
  var onMessageContentSizeChanged = function(isBottomMessageAffected) {
    if (isBottomMessageAffected === void 0) {
      isBottomMessageAffected = false;
    }
    var elem = scrollRef.current;
    if (elem) {
      var latestDistance = scrollDistanceFromBottomRef.current;
      var currentDistance = elem.scrollHeight - elem.scrollTop - elem.offsetHeight;
      if (latestDistance < currentDistance && (!isBottomMessageAffected || latestDistance < SCROLL_BUFFER)) {
        var diff = currentDistance - latestDistance;
        scrollPubSub.publish("scroll", { top: elem.scrollTop + diff, lazy: false, animated: false });
      }
    }
  };
  var renderer = {
    frozenNotification: function() {
      if (!currentChannel || !currentChannel.isFrozen)
        return null;
      return renderFrozenNotification();
    },
    unreadMessagesNotification: function() {
      if (isScrollBottomReached || !unreadSinceDate)
        return null;
      return import_react8.default.createElement(UnreadCount, { className: "sendbird-conversation__messages__notification", count: newMessages.length, lastReadAt: unreadSinceDate, onClick: function() {
        return scrollToBottom();
      } });
    },
    scrollToBottomButton: function() {
      if (!hasNext() && isScrollBottomReached)
        return null;
      return import_react8.default.createElement(
        "div",
        { className: "sendbird-conversation__scroll-bottom-button", onClick: function() {
          return scrollToBottom();
        }, onKeyDown: function() {
          return scrollToBottom();
        }, tabIndex: 0, role: "button" },
        import_react8.default.createElement(Icon, { width: "24px", height: "24px", type: IconTypes.CHEVRON_DOWN, fillColor: IconColors.PRIMARY })
      );
    }
  };
  if (loading) {
    return renderPlaceholderLoader();
  }
  if (messages.length === 0) {
    return renderPlaceholderEmpty();
  }
  return import_react8.default.createElement(
    import_react8.default.Fragment,
    null,
    import_react8.default.createElement(
      "div",
      { className: "sendbird-conversation__messages ".concat(className), dir: getHTMLTextDirection(state.config.htmlTextDirection, state.config.forceLeftToRightMessageLayout) },
      import_react8.default.createElement(InfiniteList, { ref: scrollRef, initDeps: [channelUrl], scrollPositionRef, scrollDistanceFromBottomRef, onLoadNext: loadNext, onLoadPrevious: loadPrevious, onScrollPosition: function(it) {
        var isScrollBottomReached2 = it === "bottom";
        if (newMessages.length > 0 && isScrollBottomReached2) {
          resetNewMessages();
        }
        setIsScrollBottomReached(isScrollBottomReached2);
      }, messages, renderMessage: function(_a2) {
        var message = _a2.message, index = _a2.index;
        var _b2 = getMessagePartsInfo({
          allMessages: messages,
          stringSet,
          replyType: replyType !== null && replyType !== void 0 ? replyType : "NONE",
          isMessageGroupingEnabled: isMessageGroupingEnabled !== null && isMessageGroupingEnabled !== void 0 ? isMessageGroupingEnabled : false,
          currentIndex: index,
          currentMessage: message,
          currentChannel
        }), chainTop = _b2.chainTop, chainBottom = _b2.chainBottom, hasSeparator = _b2.hasSeparator;
        var isOutgoingMessage = isSendableMessage(message) && message.sender.userId === state.config.userId;
        return import_react8.default.createElement(MessageProvider, { message, key: getComponentKeyFromMessage(message), isByMe: isOutgoingMessage }, renderMessage({
          handleScroll: onMessageContentSizeChanged,
          message,
          hasSeparator,
          chainTop,
          chainBottom,
          renderMessageContent,
          renderSuggestedReplies,
          renderCustomSeparator
        }));
      }, typingIndicator: !hasNext() && ((_b = (_a = state === null || state === void 0 ? void 0 : state.config) === null || _a === void 0 ? void 0 : _a.groupChannel) === null || _b === void 0 ? void 0 : _b.enableTypingIndicator) && ((_e = (_d = (_c = state === null || state === void 0 ? void 0 : state.config) === null || _c === void 0 ? void 0 : _c.groupChannel) === null || _d === void 0 ? void 0 : _d.typingIndicatorTypes) === null || _e === void 0 ? void 0 : _e.has(TypingIndicatorType.Bubble)) && import_react8.default.createElement(TypingIndicatorBubbleWrapper, { channelUrl, handleScroll: onMessageContentSizeChanged }) }),
      import_react8.default.createElement(import_react8.default.Fragment, null, renderer.frozenNotification()),
      import_react8.default.createElement(import_react8.default.Fragment, null, renderer.unreadMessagesNotification()),
      import_react8.default.createElement(import_react8.default.Fragment, null, renderer.scrollToBottomButton())
    )
  );
};
var TypingIndicatorBubbleWrapper = function(props) {
  var stores = useSendbird().state.stores;
  var _a = useGroupChannel().state, isScrollBottomReached = _a.isScrollBottomReached, scrollPubSub = _a.scrollPubSub;
  var _b = (0, import_react8.useState)([]), typingMembers = _b[0], setTypingMembers = _b[1];
  useGroupChannelHandler(stores.sdkStore.sdk, {
    onTypingStatusUpdated: function(channel) {
      if (channel.url === props.channelUrl) {
        setTypingMembers(channel.getTypingUsers());
      }
      if (isScrollBottomReached && isContextMenuClosed()) {
        setTimeout(function() {
          scrollPubSub.publish("scrollToBottom", {});
        }, 10);
      }
    }
  });
  return import_react8.default.createElement(TypingIndicatorBubble, { typingMembers, handleScroll: props.handleScroll });
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/MessageInputWrapper.js
var import_react9 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);
var MessageInputWrapper = function(props) {
  var _a = useGroupChannel(), state = _a.state, actions = _a.actions;
  return import_react9.default.createElement(MessageInputWrapperView, __assign({}, props, state, actions));
};

// node_modules/@sendbird/uikit-react/GroupChannel/components/GroupChannelUI.js
var import_react10 = __toESM(require_react(), 1);
var import_react_dom6 = __toESM(require_react_dom(), 1);
var GroupChannelUI = function(props) {
  var context = useGroupChannelContext();
  var _a = useGroupChannel().state, channelUrl = _a.channelUrl, fetchChannelError = _a.fetchChannelError;
  var _b = deleteNullish(props), _c = _b.renderChannelHeader, renderChannelHeader = _c === void 0 ? function(props2) {
    return import_react10.default.createElement(GroupChannelHeader, __assign({}, props2));
  } : _c, _d = _b.renderMessageList, renderMessageList = _d === void 0 ? function(props2) {
    return import_react10.default.createElement(MessageList, __assign({}, props2, { className: "sendbird-conversation__message-list" }));
  } : _d, _e = _b.renderMessageInput, renderMessageInput = _e === void 0 ? function() {
    return import_react10.default.createElement(MessageInputWrapper, __assign({}, props));
  } : _e;
  return import_react10.default.createElement(GroupChannelUIView, __assign({}, props, context, { isInvalid: fetchChannelError !== null, channelUrl, renderChannelHeader, renderMessageList, renderMessageInput }));
};

// node_modules/@sendbird/uikit-react/GroupChannel.js
var import_react11 = __toESM(require_react(), 1);
var import_react_dom7 = __toESM(require_react_dom(), 1);
var GroupChannel = function(props) {
  return import_react11.default.createElement(
    GroupChannelProvider,
    __assign({}, props),
    import_react11.default.createElement(GroupChannelUI, __assign({}, props))
  );
};

// node_modules/@sendbird/uikit-react/chunks/bundle-BOgayIsk.js
var import_react12 = __toESM(require_react(), 1);
function useUnmount(callback, deps) {
  if (deps === void 0) {
    deps = [];
  }
  (0, import_react12.useLayoutEffect)(function() {
    return function() {
      callback();
    };
  }, deps);
}
function useOnlineStatus(sdk, logger) {
  var _a, _b;
  var _c = (0, import_react12.useState)(
    // window is undefined in SSR env
    typeof window !== "undefined" ? (_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true : true
  ), isOnline = _c[0], setIsOnline = _c[1];
  (0, import_react12.useEffect)(function() {
    var uniqueHandlerId = uuidv4();
    try {
      logger.warning("sdk changed", uniqueHandlerId);
      var handler = new wi({
        onDisconnected: function() {
          setIsOnline(false);
          logger.warning("onDisconnected", { isOnline });
        },
        onReconnectStarted: function() {
          setIsOnline(false);
          logger.warning("onReconnectStarted", { isOnline });
        },
        onReconnectSucceeded: function() {
          setIsOnline(true);
          logger.warning("onReconnectSucceeded", { isOnline });
        },
        onReconnectFailed: function() {
          sdk.reconnect();
          logger.warning("onReconnectFailed");
        }
      });
      if (sdk === null || sdk === void 0 ? void 0 : sdk.addConnectionHandler) {
        sdk.addConnectionHandler(uniqueHandlerId, handler);
        logger.info("Added ConnectionHandler", uniqueHandlerId);
      }
    } catch (_a2) {
    }
    return function() {
      try {
        sdk.removeConnectionHandler(uniqueHandlerId);
        logger.info("Removed ConnectionHandler", uniqueHandlerId);
      } catch (_a2) {
      }
    };
  }, [sdk]);
  (0, import_react12.useEffect)(function() {
    var tryReconnect = function() {
      try {
        logger.warning("Try reconnecting SDK");
        if (sdk.connectionState !== "OPEN") {
          sdk.reconnect();
        }
      } catch (_a2) {
      }
    };
    window.addEventListener("online", tryReconnect);
    return function() {
      window.removeEventListener("online", tryReconnect);
    };
  }, [sdk]);
  (0, import_react12.useEffect)(function() {
    var body = document.querySelector("body");
    if (!isOnline && !(sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled)) {
      try {
        body === null || body === void 0 ? void 0 : body.classList.add("sendbird__offline");
        logger.info("Added class sendbird__offline to body");
      } catch (e) {
      }
    } else {
      try {
        body === null || body === void 0 ? void 0 : body.classList.remove("sendbird__offline");
        logger.info("Removed class sendbird__offline from body");
      } catch (e) {
      }
    }
  }, [isOnline, sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled]);
  return isOnline;
}
var TIMEOUT = 2e3;
function schedulerFactory(_a) {
  var logger = _a.logger, timeout = _a.timeout, cb = _a.cb;
  var queue = [];
  var interval = null;
  var push = function(channel) {
    var channelPresent = queue.find(function(c) {
      return c.url === channel.url;
    });
    if (!channelPresent) {
      queue.push(channel);
    } else {
      logger.info("Channel: Mark as read already in queue", { channel });
    }
    if (interval) {
      return;
    }
    var item = queue.shift();
    if (item) {
      cb(item);
    }
    interval = setInterval(function() {
      if (queue.length === 0 && interval) {
        clearInterval(interval);
        interval = null;
        return;
      }
      var item2 = queue.shift();
      if (item2) {
        cb(item2);
      }
    }, timeout || TIMEOUT);
  };
  var clear = function() {
    queue = [];
    if (interval) {
      clearInterval(interval);
      interval = null;
    }
  };
  return {
    push,
    clear,
    getQueue: function() {
      return queue;
    }
  };
}
function useMarkAsDeliveredScheduler(_a, _b) {
  var _this = this;
  var isConnected = _a.isConnected;
  var logger = _b.logger;
  var markAsDeliveredScheduler = (0, import_react12.useMemo)(function() {
    return schedulerFactory({
      logger,
      cb: function(channel) {
        return __awaiter(_this, void 0, void 0, function() {
          var error_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                _a2.trys.push([0, 2, , 3]);
                return [4, channel.markAsDelivered()];
              case 1:
                _a2.sent();
                return [3, 3];
              case 2:
                error_1 = _a2.sent();
                logger === null || logger === void 0 ? void 0 : logger.warning("Channel: Mark as delivered failed", { channel, error: error_1 });
                return [3, 3];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
    });
  }, []);
  (0, import_react12.useEffect)(function() {
    if (!isConnected) {
      markAsDeliveredScheduler.clear();
    }
  }, [isConnected]);
  useUnmount(function() {
    markAsDeliveredScheduler.clear();
  });
  return markAsDeliveredScheduler;
}

// node_modules/@sendbird/uikit-react/chunks/bundle-P--QfsZn.js
var import_react13 = __toESM(require_react(), 1);
var useGroupChannelList2 = function() {
  var store = (0, import_react13.useContext)(GroupChannelListContext);
  if (!store)
    throw new Error("useGroupChannelList must be used within a GroupChannelListProvider");
  var setGroupChannels = (0, import_react13.useCallback)(function(channels) {
    store.setState(function(state2) {
      return __assign(__assign({}, state2), { groupChannels: channels });
    }, true);
  }, []);
  var state = shimExports.useSyncExternalStore(store.subscribe, store.getState);
  var actions = (0, import_react13.useMemo)(function() {
    return {
      setGroupChannels
    };
  }, [setGroupChannels]);
  return { state, actions };
};
var GroupChannelListContext = import_react13.default.createContext(null);
var initialState3 = {
  className: "",
  selectedChannelUrl: "",
  disableAutoSelect: false,
  allowProfileEdit: false,
  isTypingIndicatorEnabled: false,
  isMessageReceiptStatusEnabled: false,
  onChannelSelect: function() {
  },
  onChannelCreated: function() {
  },
  onThemeChange: noop,
  onCreateChannelClick: noop,
  onBeforeCreateChannel: null,
  onUserProfileUpdated: noop,
  typingChannelUrls: [],
  refreshing: false,
  initialized: false,
  groupChannels: [],
  refresh: null,
  loadMore: null,
  scrollRef: { current: null }
};
var useGroupChannelListStore = function() {
  return useStore(GroupChannelListContext, function(state) {
    return state;
  }, initialState3);
};
var GroupChannelListManager = function(_a) {
  var _b, _c, _d, _e, _f, _g;
  var _h = _a.className, className = _h === void 0 ? "" : _h, _j = _a.selectedChannelUrl, selectedChannelUrl = _j === void 0 ? "" : _j, _k = _a.disableAutoSelect, disableAutoSelect = _k === void 0 ? false : _k, channelListQueryParams = _a.channelListQueryParams, onThemeChange = _a.onThemeChange, onChannelSelect = _a.onChannelSelect, onChannelCreated = _a.onChannelCreated, onCreateChannelClick = _a.onCreateChannelClick, onBeforeCreateChannel = _a.onBeforeCreateChannel, onUserProfileUpdated = _a.onUserProfileUpdated, props = __rest(_a, ["className", "selectedChannelUrl", "disableAutoSelect", "channelListQueryParams", "onThemeChange", "onChannelSelect", "onChannelCreated", "onCreateChannelClick", "onBeforeCreateChannel", "onUserProfileUpdated"]);
  var sendbirdState = useSendbird().state;
  var config = sendbirdState.config, stores = sendbirdState.stores;
  var _l = useGroupChannelList2(), state = _l.state, actions = _l.actions;
  var updateState = useGroupChannelListStore().updateState;
  var sdkStore = stores.sdkStore;
  var sdk = sdkStore.sdk;
  var isConnected = useOnlineStatus(sdk, config.logger);
  var scheduler = useMarkAsDeliveredScheduler({ isConnected }, config);
  var scrollRef = (0, import_react13.useRef)(null);
  var channelListDataSource = useGroupChannelList(sdk, {
    collectionCreator: getCollectionCreator2(sdk, channelListQueryParams),
    markAsDelivered: function(channels) {
      return channels.forEach(scheduler.push);
    },
    onChannelsDeleted: function(channelUrls) {
      channelUrls.forEach(function(url) {
        if (url === selectedChannelUrl)
          onChannelSelect(null);
      });
    },
    onChannelsUpdated: function() {
      actions.setGroupChannels(groupChannels);
    }
  });
  var refreshing = channelListDataSource.refreshing, initialized = channelListDataSource.initialized, groupChannels = channelListDataSource.groupChannels, refresh = channelListDataSource.refresh, loadMore = channelListDataSource.loadMore;
  (0, import_react13.useEffect)(function() {
    var _a2;
    if (!disableAutoSelect && stores.sdkStore.initialized && initialized) {
      if (!selectedChannelUrl)
        onChannelSelect((_a2 = groupChannels[0]) !== null && _a2 !== void 0 ? _a2 : null);
    }
  }, [disableAutoSelect, stores.sdkStore.initialized, initialized, selectedChannelUrl]);
  (0, import_react13.useEffect)(function() {
    refresh === null || refresh === void 0 ? void 0 : refresh();
  }, [
    Object.keys(channelListQueryParams !== null && channelListQueryParams !== void 0 ? channelListQueryParams : {}).sort().map(function(key) {
      return "".concat(key, "=").concat(encodeURIComponent(JSON.stringify(channelListQueryParams[key])));
    }).join("&")
  ]);
  var typingChannelUrls = state.typingChannelUrls;
  useGroupChannelHandler(sdk, {
    onTypingStatusUpdated: function(channel) {
      var _a2;
      var channelList = typingChannelUrls.filter(function(channelUrl) {
        return channelUrl !== channel.url;
      });
      if (((_a2 = channel.getTypingUsers()) === null || _a2 === void 0 ? void 0 : _a2.length) > 0) {
        updateState({
          typingChannelUrls: channelList.concat(channel.url)
        });
      } else {
        updateState({
          typingChannelUrls: channelList
        });
      }
    }
  });
  var allowProfileEdit = (_c = (_b = props.allowProfileEdit) !== null && _b !== void 0 ? _b : config.allowProfileEdit) !== null && _c !== void 0 ? _c : true;
  var isTypingIndicatorEnabled = (_e = (_d = props.isTypingIndicatorEnabled) !== null && _d !== void 0 ? _d : config.groupChannelList.enableTypingIndicator) !== null && _e !== void 0 ? _e : false;
  var isMessageReceiptStatusEnabled = (_g = (_f = props.isMessageReceiptStatusEnabled) !== null && _f !== void 0 ? _f : config.groupChannelList.enableMessageReceiptStatus) !== null && _g !== void 0 ? _g : false;
  var eventHandlers = (0, import_react13.useMemo)(function() {
    return {
      onChannelSelect,
      onChannelCreated,
      onThemeChange,
      onCreateChannelClick,
      onBeforeCreateChannel,
      onUserProfileUpdated
    };
  }, [
    onChannelSelect,
    onChannelCreated,
    onThemeChange,
    onCreateChannelClick,
    onBeforeCreateChannel,
    onUserProfileUpdated
  ]);
  var configurations = (0, import_react13.useMemo)(function() {
    return {
      className,
      selectedChannelUrl,
      disableAutoSelect,
      allowProfileEdit,
      isTypingIndicatorEnabled,
      isMessageReceiptStatusEnabled,
      typingChannelUrls,
      refreshing,
      initialized,
      refresh,
      loadMore
    };
  }, [
    className,
    selectedChannelUrl,
    disableAutoSelect,
    allowProfileEdit,
    isTypingIndicatorEnabled,
    isMessageReceiptStatusEnabled,
    typingChannelUrls,
    refreshing,
    initialized,
    scrollRef
  ]);
  useDeepCompareEffect(function() {
    updateState(__assign(__assign(__assign({}, eventHandlers), configurations), { groupChannels }));
  }, [
    configurations,
    eventHandlers,
    groupChannels.map(function(groupChannel) {
      return groupChannel.serialize();
    })
  ]);
  return null;
};
var createGroupChannelListStore = function(props) {
  return createStore(__assign(__assign({}, initialState3), props));
};
var InternalGroupChannelListProvider = function(props) {
  var children = props.children;
  var defaultProps = deleteNullish({
    onChannelSelect: props === null || props === void 0 ? void 0 : props.onChannelSelect,
    onChannelCreated: props === null || props === void 0 ? void 0 : props.onChannelCreated,
    className: props === null || props === void 0 ? void 0 : props.className,
    selectedChannelUrl: props === null || props === void 0 ? void 0 : props.selectedChannelUrl,
    allowProfileEdit: props === null || props === void 0 ? void 0 : props.allowProfileEdit,
    disableAutoSelect: props === null || props === void 0 ? void 0 : props.disableAutoSelect,
    isTypingIndicatorEnabled: props === null || props === void 0 ? void 0 : props.isTypingIndicatorEnabled,
    isMessageReceiptStatusEnabled: props === null || props === void 0 ? void 0 : props.isMessageReceiptStatusEnabled,
    channelListQueryParams: props === null || props === void 0 ? void 0 : props.channelListQueryParams,
    onThemeChange: props === null || props === void 0 ? void 0 : props.onThemeChange,
    onCreateChannelClick: props === null || props === void 0 ? void 0 : props.onCreateChannelClick,
    onBeforeCreateChannel: props === null || props === void 0 ? void 0 : props.onBeforeCreateChannel,
    onUserProfileUpdated: props === null || props === void 0 ? void 0 : props.onUserProfileUpdated
  });
  var storeRef = (0, import_react13.useRef)(createGroupChannelListStore(defaultProps));
  return import_react13.default.createElement(GroupChannelListContext.Provider, { value: storeRef.current }, children);
};
var GroupChannelListProvider = function(props) {
  var children = props.children, className = props.className;
  return import_react13.default.createElement(
    InternalGroupChannelListProvider,
    __assign({}, props),
    import_react13.default.createElement(GroupChannelListManager, __assign({}, props)),
    import_react13.default.createElement(
      UserProfileProvider,
      __assign({}, props),
      import_react13.default.createElement("div", { className: "sendbird-channel-list ".concat(className) }, children)
    )
  );
};
function getCollectionCreator2(sdk, channelListQueryParams) {
  return function(defaultParams) {
    var params = __assign(__assign({}, defaultParams), channelListQueryParams);
    return sdk.groupChannel.createGroupChannelCollection(__assign(__assign({}, params), { filter: new hn(params) }));
  };
}

// node_modules/@sendbird/uikit-react/GroupChannelList/components/GroupChannelListHeader.js
var import_react14 = __toESM(require_react(), 1);
var GroupChannelListHeader = function(_a) {
  var renderTitle = _a.renderTitle, renderIconButton = _a.renderIconButton, onEdit = _a.onEdit, allowProfileEdit = _a.allowProfileEdit, renderLeft = _a.renderLeft, renderMiddle = _a.renderMiddle, renderRight = _a.renderRight;
  var user = useSendbird().state.stores.userStore.user;
  var stringSet = useLocalization().stringSet;
  var renderProfile = renderMiddle !== null && renderMiddle !== void 0 ? renderMiddle : renderTitle;
  return import_react14.default.createElement(Header$1, { className: classnames("sendbird-channel-header", allowProfileEdit && "sendbird-channel-header--allow-edit"), renderLeft, renderMiddle: function() {
    var _a2;
    return (_a2 = renderProfile === null || renderProfile === void 0 ? void 0 : renderProfile()) !== null && _a2 !== void 0 ? _a2 : import_react14.default.createElement(
      "div",
      { className: "sendbird-channel-header__title", role: "button", onClick: function() {
        onEdit === null || onEdit === void 0 ? void 0 : onEdit();
      }, onKeyDown: function() {
        onEdit === null || onEdit === void 0 ? void 0 : onEdit();
      }, tabIndex: 0 },
      import_react14.default.createElement(
        "div",
        { className: "sendbird-channel-header__title__left" },
        import_react14.default.createElement(Avatar$1, { width: "32px", height: "32px", src: user.profileUrl, alt: user.nickname })
      ),
      import_react14.default.createElement(
        "div",
        { className: "sendbird-channel-header__title__right" },
        import_react14.default.createElement(Label, { className: "sendbird-channel-header__title__right__name", type: LabelTypography.SUBTITLE_2, color: LabelColors.ONBACKGROUND_1 }, user.nickname || stringSet.NO_NAME),
        import_react14.default.createElement(Label, { className: "sendbird-channel-header__title__right__user-id", type: LabelTypography.BODY_2, color: LabelColors.ONBACKGROUND_2 }, user.userId)
      )
    );
  }, renderRight: renderRight !== null && renderRight !== void 0 ? renderRight : renderIconButton });
};

// node_modules/@sendbird/uikit-react/EditUserProfile/context.js
var import_react15 = __toESM(require_react(), 1);
var EditUserProfileProviderContext = import_react15.default.createContext(null);
var EditUserProfileProvider = function(_a) {
  var children = _a.children, props = __rest(_a, ["children"]);
  return import_react15.default.createElement(EditUserProfileProviderContext.Provider, { value: props }, children);
};
var useEditUserProfileContext = function() {
  var context = import_react15.default.useContext(EditUserProfileProviderContext);
  if (!context)
    throw new Error("EditUserProfileContext not found. Use within the EditUserProfile module.");
  return context;
};

// node_modules/@sendbird/uikit-react/EditUserProfile/components/EditUserProfileUI.js
var import_react16 = __toESM(require_react(), 1);
var import_react_dom8 = __toESM(require_react_dom(), 1);
var EditUserProfileUIView = function(_a) {
  var _b;
  var formRef = _a.formRef, inputRef = _a.inputRef, onThemeChange = _a.onThemeChange, setProfileImage = _a.setProfileImage;
  var state = useSendbird().state;
  var stores = state.stores, config = state.config;
  var theme = config.theme, setCurrentTheme = config.setCurrentTheme;
  var user = (_b = stores.userStore) === null || _b === void 0 ? void 0 : _b.user;
  var stringSet = useLocalization().stringSet;
  var _c = (0, import_react16.useState)(null), currentImg = _c[0], setCurrentImg = _c[1];
  var hiddenInputRef = (0, import_react16.useRef)(null);
  return import_react16.default.createElement(
    "form",
    { className: "sendbird-edit-user-profile", ref: formRef, onSubmit: function(e) {
      e.preventDefault();
    } },
    import_react16.default.createElement(
      "section",
      { className: "sendbird-edit-user-profile__img" },
      import_react16.default.createElement(InputLabel, null, stringSet.EDIT_PROFILE__IMAGE_LABEL),
      import_react16.default.createElement(
        "div",
        { className: "sendbird-edit-user-profile__img__avatar" },
        import_react16.default.createElement(Avatar$1, { width: "80px", height: "80px", src: currentImg || (user === null || user === void 0 ? void 0 : user.profileUrl) })
      ),
      import_react16.default.createElement("input", { ref: hiddenInputRef, type: "file", accept: "image/gif, image/jpeg, image/png", style: { display: "none" }, onChange: function(e) {
        if (e.target.files) {
          setCurrentImg(URL.createObjectURL(e.target.files[0]));
          setProfileImage(e.target.files[0]);
        }
        if (hiddenInputRef.current) {
          hiddenInputRef.current.value = "";
        }
      } }),
      import_react16.default.createElement(
        TextButton,
        { className: "sendbird-edit-user-profile__img__avatar-button", disableUnderline: true, onClick: function() {
          var _a2;
          return (_a2 = hiddenInputRef.current) === null || _a2 === void 0 ? void 0 : _a2.click();
        } },
        import_react16.default.createElement(Label, { type: LabelTypography.BUTTON_1, color: LabelColors.PRIMARY }, stringSet.EDIT_PROFILE__IMAGE_UPLOAD)
      )
    ),
    import_react16.default.createElement(
      "section",
      { className: "sendbird-edit-user-profile__name" },
      import_react16.default.createElement(InputLabel, null, stringSet.EDIT_PROFILE__NICKNAME_LABEL),
      import_react16.default.createElement(Input, { required: (user === null || user === void 0 ? void 0 : user.nickname) !== "", name: "sendbird-edit-user-profile__name__input", ref: inputRef, value: user === null || user === void 0 ? void 0 : user.nickname, placeHolder: stringSet.EDIT_PROFILE__NICKNAME_PLACEHOLDER })
    ),
    import_react16.default.createElement(
      "section",
      { className: "sendbird-edit-user-profile__userid" },
      import_react16.default.createElement(InputLabel, null, stringSet.EDIT_PROFILE__USERID_LABEL),
      import_react16.default.createElement(Input, { disabled: true, name: "sendbird-edit-user-profile__userid__input", value: user === null || user === void 0 ? void 0 : user.userId })
    ),
    import_react16.default.createElement(
      "section",
      { className: "sendbird-edit-user-profile__theme" },
      import_react16.default.createElement(InputLabel, null, stringSet.EDIT_PROFILE__THEME_LABEL),
      import_react16.default.createElement("div", { className: "sendbird-edit-user-profile__theme__theme-icon" }, theme === "dark" ? import_react16.default.createElement(Icon, { onClick: function() {
        setCurrentTheme("light");
        onThemeChange === null || onThemeChange === void 0 ? void 0 : onThemeChange("light");
      }, type: IconTypes.TOGGLE_ON, width: 44, height: 24 }) : import_react16.default.createElement(Icon, { onClick: function() {
        setCurrentTheme("dark");
        onThemeChange === null || onThemeChange === void 0 ? void 0 : onThemeChange("dark");
      }, type: IconTypes.TOGGLE_OFF, width: 44, height: 24 }))
    )
  );
};
var handleUpdateUserInfo = function(_a) {
  var _b, _c, _d;
  var globalContext = _a.globalContext, formRef = _a.formRef, inputRef = _a.inputRef, profileImage = _a.profileImage, onEditProfile = _a.onEditProfile, updateUserInfo = _a.updateUserInfo;
  var stores = globalContext.stores;
  var sdk = stores.sdkStore.sdk;
  var user = stores.userStore.user;
  if ((user === null || user === void 0 ? void 0 : user.nickname) !== "" && !inputRef.current.value) {
    (_c = (_b = formRef.current).reportValidity) === null || _c === void 0 ? void 0 : _c.call(_b);
    return;
  }
  sdk === null || sdk === void 0 ? void 0 : sdk.updateCurrentUserInfo({
    nickname: (_d = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _d === void 0 ? void 0 : _d.value,
    profileImage: profileImage !== null && profileImage !== void 0 ? profileImage : void 0
  }).then(function(updatedUser) {
    updateUserInfo(updatedUser);
    onEditProfile === null || onEditProfile === void 0 ? void 0 : onEditProfile(updatedUser);
  });
};
var useEditUserProfileUISates = function(_a) {
  var onEditProfile = _a.onEditProfile;
  var _b = useSendbird(), state = _b.state, actions = _b.actions;
  var inputRef = (0, import_react16.useRef)(null);
  var formRef = (0, import_react16.useRef)(null);
  var _c = (0, import_react16.useState)(null), profileImage = _c[0], setProfileImage = _c[1];
  var updateUserInfo = function() {
    handleUpdateUserInfo({
      globalContext: state,
      formRef,
      inputRef,
      profileImage,
      onEditProfile,
      updateUserInfo: actions.updateUserInfo
    });
  };
  return {
    formRef,
    inputRef,
    updateUserInfo,
    profileImage,
    setProfileImage
  };
};
var EditUserProfileUI = function() {
  var editProfileContext = useEditUserProfileContext();
  var onEditProfile = editProfileContext.onEditProfile, onCancel = editProfileContext.onCancel, onThemeChange = editProfileContext.onThemeChange;
  var stringSet = (0, import_react16.useContext)(LocalizationContext).stringSet;
  var _a = useEditUserProfileUISates({ onEditProfile }), formRef = _a.formRef, inputRef = _a.inputRef, updateUserInfo = _a.updateUserInfo, setProfileImage = _a.setProfileImage;
  return import_react16.default.createElement(
    Modal,
    { titleText: stringSet.EDIT_PROFILE__TITLE, submitText: stringSet.BUTTON__SAVE, type: ButtonTypes.PRIMARY, onCancel, isFullScreenOnMobile: true, onSubmit: updateUserInfo },
    import_react16.default.createElement(EditUserProfileUIView, { formRef, inputRef, setProfileImage, onThemeChange })
  );
};

// node_modules/@sendbird/uikit-react/EditUserProfile.js
var import_react17 = __toESM(require_react(), 1);
var import_react_dom9 = __toESM(require_react_dom(), 1);
var EditUserProfile = function(props) {
  var onEditProfile = props.onEditProfile, onCancel = props.onCancel, onThemeChange = props.onThemeChange;
  return import_react17.default.createElement(
    EditUserProfileProvider,
    { onEditProfile, onCancel, onThemeChange },
    import_react17.default.createElement(EditUserProfileUI, null)
  );
};

// node_modules/@sendbird/uikit-react/GroupChannelList/components/GroupChannelPreviewAction.js
var import_react18 = __toESM(require_react(), 1);
var import_react_dom10 = __toESM(require_react_dom(), 1);
var LeaveGroupChannel = function(_a) {
  var channel = _a.channel, onSubmit = _a.onSubmit, onCancel = _a.onCancel;
  var _b = useSendbird().state.config, logger = _b.logger, isOnline = _b.isOnline;
  var stringSet = useLocalization().stringSet;
  if (channel) {
    return import_react18.default.createElement(Modal, { disabled: !isOnline, onCancel, onSubmit: function() {
      logger.info("LeaveGroupChannel: Leaving channel", channel);
      channel.leave().then(function() {
        logger.info("LeaveGroupChannel: Leaving channel successful!", channel);
        onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit();
      });
    }, submitText: stringSet.MODAL__LEAVE_CHANNEL__FOOTER, titleText: stringSet.MODAL__LEAVE_CHANNEL__TITLE });
  }
};
function GroupChannelPreviewAction(_a) {
  var channel = _a.channel, _b = _a.disabled, disabled = _b === void 0 ? false : _b, onLeaveChannel = _a.onLeaveChannel;
  var parentRef = (0, import_react18.useRef)(null);
  var parentContainerRef = (0, import_react18.useRef)(null);
  var _c = (0, import_react18.useState)(false), showModal = _c[0], setShowModal = _c[1];
  var stringSet = (0, import_react18.useContext)(LocalizationContext).stringSet;
  return import_react18.default.createElement(
    "div",
    { ref: parentContainerRef, tabIndex: 0, role: "button", style: { display: "inline-block" }, onKeyDown: function(e) {
      return e.stopPropagation();
    }, onClick: function(e) {
      return e.stopPropagation();
    } },
    import_react18.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
      return import_react18.default.createElement(
        IconButton,
        { ref: parentRef, onClick: toggleDropdown, height: "32px", width: "32px" },
        import_react18.default.createElement(Icon, { type: IconTypes.MORE, fillColor: IconColors.PRIMARY, width: "24px", height: "24px" })
      );
    }, menuItems: function(closeDropdown) {
      return import_react18.default.createElement(
        MenuItems,
        { parentRef, parentContainRef: parentContainerRef, closeDropdown },
        import_react18.default.createElement(MenuItem, { onClick: function() {
          if (disabled)
            return;
          setShowModal(true);
          closeDropdown();
        }, testID: "channel_list_item_context_menu_leave_channel" }, stringSet.CHANNEL_SETTING__LEAVE_CHANNEL__TITLE)
      );
    } }),
    showModal && import_react18.default.createElement(LeaveGroupChannel, { channel, onSubmit: function() {
      setShowModal(false);
      onLeaveChannel === null || onLeaveChannel === void 0 ? void 0 : onLeaveChannel();
    }, onCancel: function() {
      return setShowModal(false);
    } })
  );
}

// node_modules/@sendbird/uikit-react/ui/MentionUserLabel.js
var import_react19 = __toESM(require_react(), 1);
function MentionUserLabel(_a) {
  var _b = _a.className, className = _b === void 0 ? "" : _b, children = _a.children, _c = _a.isReverse, isReverse = _c === void 0 ? false : _c, color = _a.color, userId = _a.userId;
  return import_react19.default.createElement("span", { className: classnames(MENTION_USER_LABEL_CLASSNAME, className, isReverse && "reverse", color), contentEditable: false, "data-userid": userId, "data-sb-mention": true }, children);
}

// node_modules/@sendbird/uikit-react/chunks/bundle-B7JoK-Jx.js
var import_react20 = __toESM(require_react(), 1);
var GroupChannelListItemView = function(_a) {
  var channel = _a.channel, tabIndex = _a.tabIndex, isTyping = _a.isTyping, isSelected = _a.isSelected, channelName = _a.channelName, _b = _a.isMessageStatusEnabled, isMessageStatusEnabled = _b === void 0 ? true : _b, _c = _a.onClick, onClick = _c === void 0 ? noop : _c, _d = _a.onLeaveChannel, onLeaveChannel = _d === void 0 ? function() {
    return Promise.resolve();
  } : _d, renderChannelAction = _a.renderChannelAction;
  var config = useSendbird().state.config;
  var theme = config.theme, userId = config.userId;
  var _e = useLocalization(), dateLocale = _e.dateLocale, stringSet = _e.stringSet;
  var isMobile = useMediaQueryContext().isMobile;
  var isMentionEnabled = config.groupChannel.enableMention;
  var lastMessage = getLastMessageText(channel, stringSet);
  var previewLastMessage = config.groupChannel.enableMarkdownForUserMessage ? getChannelPreviewMessage(lastMessage) : lastMessage;
  var _f = (0, import_react20.useState)(false), showMobileLeave = _f[0], setShowMobileLeave = _f[1];
  var onLongPress = useLongPress({
    onLongPress: function() {
      if (isMobile) {
        setShowMobileLeave(true);
      }
    },
    onClick
  }, {
    delay: 1e3
  });
  return import_react20.default.createElement(
    import_react20.default.Fragment,
    null,
    import_react20.default.createElement(
      "div",
      __assign({ className: [
        "sendbird-channel-preview",
        isSelected ? "sendbird-channel-preview--active" : ""
      ].join(" "), role: "link", tabIndex }, isMobile ? __assign({}, onLongPress) : { onClick }),
      import_react20.default.createElement(
        "div",
        { className: "sendbird-channel-preview__avatar" },
        import_react20.default.createElement(ChannelAvatar, { channel, userId, theme })
      ),
      import_react20.default.createElement(
        "div",
        { className: "sendbird-channel-preview__content" },
        import_react20.default.createElement(
          "div",
          { className: "sendbird-channel-preview__content__upper" },
          import_react20.default.createElement(
            "div",
            { className: "sendbird-channel-preview__content__upper__header" },
            (channel.isBroadcast || false) && import_react20.default.createElement(
              "div",
              { className: "sendbird-channel-preview__content__upper__header__broadcast-icon" },
              import_react20.default.createElement(Icon, { type: IconTypes.BROADCAST, fillColor: IconColors.SECONDARY, height: "16px", width: "16px" })
            ),
            import_react20.default.createElement(Label, { className: "sendbird-channel-preview__content__upper__header__channel-name", testID: "sendbird-channel-preview__content__upper__header__channel-name", type: LabelTypography.SUBTITLE_2, color: LabelColors.ONBACKGROUND_1 }, channelName),
            import_react20.default.createElement(Label, { className: "sendbird-channel-preview__content__upper__header__total-members", type: LabelTypography.CAPTION_2, color: LabelColors.ONBACKGROUND_2 }, getTotalMembers(channel)),
            channel.isFrozen && import_react20.default.createElement(
              "div",
              { title: "Frozen", className: "sendbird-channel-preview__content__upper__header__frozen-icon" },
              import_react20.default.createElement(Icon, { type: IconTypes.FREEZE, fillColor: IconColors.PRIMARY, height: 12, width: 12 })
            )
          ),
          !channel.isEphemeral && isMessageStatusEnabled && import_react20.default.createElement(MessageStatus, { className: "sendbird-channel-preview__content__upper__last-message-at", channel, message: channel.lastMessage, isDateSeparatorConsidered: false }),
          !channel.isEphemeral && !isMessageStatusEnabled && import_react20.default.createElement(Label, { className: "sendbird-channel-preview__content__upper__last-message-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, getLastMessageCreatedAt({
            channel,
            locale: dateLocale,
            stringSet
          }))
        ),
        import_react20.default.createElement(
          "div",
          { className: "sendbird-channel-preview__content__lower" },
          import_react20.default.createElement(
            Label,
            { className: "sendbird-channel-preview__content__lower__last-message", type: LabelTypography.BODY_2, color: LabelColors.ONBACKGROUND_3 },
            isTyping && import_react20.default.createElement(TypingIndicatorText, { members: channel.getTypingUsers() }),
            !isTyping && !isVoiceMessage(channel.lastMessage) && previewLastMessage,
            !isTyping && isVoiceMessage(channel.lastMessage) && stringSet.VOICE_MESSAGE
          ),
          /**
           * Do not show unread count for focused channel. This is because of the limitation where
           * isScrollBottom and hasNext states needs to be added globally but they are from channel context
           * so channel list cannot see them with the current architecture.
           */
          !isSelected && !channel.isEphemeral && import_react20.default.createElement(
            "div",
            { className: "sendbird-channel-preview__content__lower__unread-message-count" },
            isMentionEnabled && channel.unreadMentionCount > 0 ? import_react20.default.createElement(MentionUserLabel, { className: "sendbird-channel-preview__content__lower__unread-message-count__mention", color: "purple" }, "@") : null,
            getChannelUnreadMessageCount(channel) ? (
              // return number
              import_react20.default.createElement(Badge, { count: getChannelUnreadMessageCount(channel) })
            ) : null
          )
        )
      ),
      !isMobile && import_react20.default.createElement("div", { className: "sendbird-channel-preview__action" }, renderChannelAction({ channel }))
    ),
    showMobileLeave && isMobile && import_react20.default.createElement(
      Modal,
      { className: "sendbird-channel-preview__leave--mobile", titleText: channelName, hideFooter: true, isCloseOnClickOutside: true, onCancel: function() {
        return setShowMobileLeave(false);
      } },
      import_react20.default.createElement(
        TextButton,
        { onClick: function() {
          onLeaveChannel();
          setShowMobileLeave(false);
        }, className: "sendbird-channel-preview__leave-label--mobile" },
        import_react20.default.createElement(Label, { type: LabelTypography.SUBTITLE_1, color: LabelColors.ONBACKGROUND_1 }, stringSet.CHANNEL_PREVIEW_MOBILE_LEAVE)
      )
    )
  );
};

// node_modules/@sendbird/uikit-react/GroupChannelList/components/GroupChannelListItem.js
var import_react21 = __toESM(require_react(), 1);
var import_react_dom11 = __toESM(require_react_dom(), 1);
var GroupChannelListItem = function(_a) {
  var _b, _c, _d;
  var channel = _a.channel, isSelected = _a.isSelected, isTyping = _a.isTyping, renderChannelAction = _a.renderChannelAction, onLeaveChannel = _a.onLeaveChannel, onClick = _a.onClick, tabIndex = _a.tabIndex;
  var config = useSendbird().state.config;
  var stringSet = useLocalization().stringSet;
  var _e = useGroupChannelList2().state, isTypingIndicatorEnabled = _e.isTypingIndicatorEnabled, isMessageReceiptStatusEnabled = _e.isMessageReceiptStatusEnabled;
  var userId = config.userId;
  var isMessageStatusEnabled = isMessageReceiptStatusEnabled && !((_b = channel.lastMessage) === null || _b === void 0 ? void 0 : _b.isAdminMessage()) && ((_d = (_c = channel.lastMessage) === null || _c === void 0 ? void 0 : _c.sender) === null || _d === void 0 ? void 0 : _d.userId) === userId;
  return import_react21.default.createElement(GroupChannelListItemView, { channel, tabIndex, channelName: getChannelTitle2(channel, userId, stringSet), isTyping: isTypingIndicatorEnabled && isTyping, isSelected, isMessageStatusEnabled, onClick, onLeaveChannel, renderChannelAction });
};

// node_modules/@sendbird/uikit-react/chunks/bundle-BZ9AHb6D.js
var EmojiManager = (
  /** @class */
  function() {
    function EmojiManager2(props) {
      var _this = this;
      var _a;
      var sdk = props.sdk, logger = props.logger;
      (_a = sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji) === null || _a === void 0 ? void 0 : _a.call(sdk).then(function(emojiContainer) {
        _this._emojiContainer = emojiContainer;
        logger === null || logger === void 0 ? void 0 : logger.info("EmojiManager | Succeeded getting all emojis. ", emojiContainer);
      }).catch(function() {
        logger === null || logger === void 0 ? void 0 : logger.warning("EmojiManager | Failed getting all emojis.");
      });
    }
    Object.defineProperty(EmojiManager2.prototype, "AllEmojisAsArray", {
      get: function() {
        return this._emojiContainer.emojiCategories.flatMap(function(category) {
          return category.emojis;
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(EmojiManager2.prototype, "AllEmojisAsMap", {
      get: function() {
        return this._emojiContainer.emojiCategories.flatMap(function(category) {
          return category.emojis;
        }).reduce(function(map, emoji) {
          map.set(emoji.key, emoji.url);
          return map;
        }, /* @__PURE__ */ new Map());
      },
      enumerable: false,
      configurable: true
    });
    EmojiManager2.prototype.getAllEmojis = function(type) {
      var _this = this;
      return K(type).when(function(type2) {
        return ["array", "arr"].includes(type2);
      }, function() {
        return _this.AllEmojisAsArray;
      }).when(function(type2) {
        return ["map"].includes(type2);
      }, function() {
        return _this.AllEmojisAsMap;
      }).otherwise(function() {
        return _this.AllEmojisAsArray;
      });
    };
    EmojiManager2.prototype.getEmojiUrl = function(reactionKey) {
      var _a, _b;
      return (_b = (_a = this.AllEmojisAsArray.find(function(emoji) {
        return emoji.key === reactionKey;
      })) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : "";
    };
    Object.defineProperty(EmojiManager2.prototype, "emojiContainer", {
      get: function() {
        return this._emojiContainer;
      },
      enumerable: false,
      configurable: true
    });
    return EmojiManager2;
  }()
);
var colorMapping = {
  // Primary / Secondary / Error / Information
  100: "extra-light",
  200: "light",
  300: "main",
  400: "dark",
  500: "extra-dark",
  // Overlay
  "overlay-01": "overlay-dark",
  "overlay-02": "overlay-light",
  // OnLight
  "onlight-01": "onlight-text-high-emphasis",
  "onlight-02": "onlight-text-mid-emphasis",
  "onlight-03": "onlight-text-low-emphasis",
  "onlight-04": "onlight-text-disabled",
  // OnDark
  "ondark-01": "ondark-text-high-emphasis",
  "ondark-02": "ondark-text-mid-emphasis",
  "ondark-03": "ondark-text-low-emphasis",
  "ondark-04": "ondark-text-disabled"
};
var colorMappingOrder = Object.values(colorMapping).sort(function(a, b) {
  return b.length - a.length;
});
var colorMappingMap = new Map(Object.entries(colorMapping).map(function(_a) {
  var key = _a[0], value = _a[1];
  return [value, key];
}));
var mapColorKeys = function(colorSet) {
  var mappedColors = {};
  Object.entries(colorSet).forEach(function(_a) {
    var key = _a[0], value = _a[1];
    var descriptiveKey = key;
    for (var _i = 0, colorMappingOrder_1 = colorMappingOrder; _i < colorMappingOrder_1.length; _i++) {
      var mappingValue = colorMappingOrder_1[_i];
      var regex2 = new RegExp("-".concat(mappingValue, "$"));
      if (regex2.test(key)) {
        var numericKey = colorMappingMap.get(mappingValue);
        if (numericKey) {
          descriptiveKey = key.replace(regex2, "-".concat(numericKey));
          break;
        }
      }
    }
    mappedColors[descriptiveKey] = value;
  });
  return mappedColors;
};

// node_modules/css-vars-ponyfill/dist/css-vars-ponyfill.esm.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function getUrls(urls) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var settings = {
    mimeType: options.mimeType || null,
    onBeforeSend: options.onBeforeSend || Function.prototype,
    onSuccess: options.onSuccess || Function.prototype,
    onError: options.onError || Function.prototype,
    onComplete: options.onComplete || Function.prototype
  };
  var urlArray = Array.isArray(urls) ? urls : [urls];
  var urlQueue = Array.apply(null, Array(urlArray.length)).map(function(x) {
    return null;
  });
  function isValidCss(text) {
    var isString = typeof text === "string";
    var isHTML = isString && text.trim().charAt(0) === "<";
    return isString && !isHTML;
  }
  function onError2(xhr, urlIndex) {
    settings.onError(xhr, urlArray[urlIndex], urlIndex);
  }
  function onSuccess2(responseText, urlIndex) {
    var returnVal = settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);
    responseText = returnVal === false ? "" : returnVal || responseText;
    urlQueue[urlIndex] = responseText;
    if (urlQueue.indexOf(null) === -1) {
      settings.onComplete(urlQueue);
    }
  }
  var parser = document.createElement("a");
  urlArray.forEach(function(url, i) {
    parser.setAttribute("href", url);
    parser.href = String(parser.href);
    var isIElte9 = Boolean(document.all && !window.atob);
    var isIElte9CORS = isIElte9 && parser.host.split(":")[0] !== location.host.split(":")[0];
    if (isIElte9CORS) {
      var isSameProtocol = parser.protocol === location.protocol;
      if (isSameProtocol) {
        var xdr = new XDomainRequest();
        xdr.open("GET", url);
        xdr.timeout = 0;
        xdr.onprogress = Function.prototype;
        xdr.ontimeout = Function.prototype;
        xdr.onload = function() {
          var text = xdr.responseText;
          if (isValidCss(text)) {
            onSuccess2(text, i);
          } else {
            onError2(xdr, i);
          }
        };
        xdr.onerror = function(err) {
          onError2(xdr, i);
        };
        setTimeout(function() {
          xdr.send();
        }, 0);
      } else {
        console.warn("Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol (".concat(url, ")"));
        onError2(null, i);
      }
    } else {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url);
      if (settings.mimeType && xhr.overrideMimeType) {
        xhr.overrideMimeType(settings.mimeType);
      }
      settings.onBeforeSend(xhr, url, i);
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          var text = xhr.responseText;
          if (xhr.status < 400 && isValidCss(text)) {
            onSuccess2(text, i);
          } else if (xhr.status === 0 && isValidCss(text)) {
            onSuccess2(text, i);
          } else {
            onError2(xhr, i);
          }
        }
      };
      xhr.send();
    }
  });
}
function getCssData(options) {
  var regex2 = {
    cssComments: /\/\*[\s\S]+?\*\//g,
    cssImports: /(?:@import\s*)(?:url\(\s*)?(?:['"])([^'"]*)(?:['"])(?:\s*\))?(?:[^;]*;)/g
  };
  var settings = {
    rootElement: options.rootElement || document,
    include: options.include || 'style,link[rel="stylesheet"]',
    exclude: options.exclude || null,
    filter: options.filter || null,
    skipDisabled: options.skipDisabled !== false,
    useCSSOM: options.useCSSOM || false,
    onBeforeSend: options.onBeforeSend || Function.prototype,
    onSuccess: options.onSuccess || Function.prototype,
    onError: options.onError || Function.prototype,
    onComplete: options.onComplete || Function.prototype
  };
  var sourceNodes = Array.apply(null, settings.rootElement.querySelectorAll(settings.include)).filter(function(node) {
    return !matchesSelector(node, settings.exclude);
  });
  var cssArray = Array.apply(null, Array(sourceNodes.length)).map(function(x) {
    return null;
  });
  function handleComplete() {
    var isComplete = cssArray.indexOf(null) === -1;
    if (isComplete) {
      cssArray.reduce(function(skipIndices, value, i) {
        if (value === "") {
          skipIndices.push(i);
        }
        return skipIndices;
      }, []).reverse().forEach(function(skipIndex) {
        return [sourceNodes, cssArray].forEach(function(arr) {
          return arr.splice(skipIndex, 1);
        });
      });
      var cssText = cssArray.join("");
      settings.onComplete(cssText, cssArray, sourceNodes);
    }
  }
  function handleSuccess(cssText, cssIndex, node, sourceUrl) {
    var returnVal = settings.onSuccess(cssText, node, sourceUrl);
    cssText = returnVal !== void 0 && Boolean(returnVal) === false ? "" : returnVal || cssText;
    resolveImports(cssText, node, sourceUrl, function(resolvedCssText, errorData) {
      if (cssArray[cssIndex] === null) {
        errorData.forEach(function(data) {
          return settings.onError(data.xhr, node, data.url);
        });
        if (!settings.filter || settings.filter.test(resolvedCssText)) {
          cssArray[cssIndex] = resolvedCssText;
        } else {
          cssArray[cssIndex] = "";
        }
        handleComplete();
      }
    });
  }
  function parseImportData(cssText, baseUrl) {
    var ignoreRules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    var importData = {};
    importData.rules = (cssText.replace(regex2.cssComments, "").match(regex2.cssImports) || []).filter(function(rule) {
      return ignoreRules.indexOf(rule) === -1;
    });
    importData.urls = importData.rules.map(function(rule) {
      return rule.replace(regex2.cssImports, "$1");
    });
    importData.absoluteUrls = importData.urls.map(function(url) {
      return getFullUrl$1(url, baseUrl);
    });
    importData.absoluteRules = importData.rules.map(function(rule, i) {
      var oldUrl = importData.urls[i];
      var newUrl = getFullUrl$1(importData.absoluteUrls[i], baseUrl);
      return rule.replace(oldUrl, newUrl);
    });
    return importData;
  }
  function resolveImports(cssText, node, baseUrl, callbackFn) {
    var __errorData = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [];
    var __errorRules = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
    var importData = parseImportData(cssText, baseUrl, __errorRules);
    if (importData.rules.length) {
      getUrls(importData.absoluteUrls, {
        onBeforeSend: function onBeforeSend2(xhr, url, urlIndex) {
          settings.onBeforeSend(xhr, node, url);
        },
        onSuccess: function onSuccess2(cssText2, url, urlIndex) {
          var returnVal = settings.onSuccess(cssText2, node, url);
          cssText2 = returnVal === false ? "" : returnVal || cssText2;
          var responseImportData = parseImportData(cssText2, url, __errorRules);
          responseImportData.rules.forEach(function(rule, i) {
            cssText2 = cssText2.replace(rule, responseImportData.absoluteRules[i]);
          });
          return cssText2;
        },
        onError: function onError2(xhr, url, urlIndex) {
          __errorData.push({
            xhr,
            url
          });
          __errorRules.push(importData.rules[urlIndex]);
          resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
        },
        onComplete: function onComplete2(responseArray) {
          responseArray.forEach(function(importText, i) {
            cssText = cssText.replace(importData.rules[i], importText);
          });
          resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
        }
      });
    } else {
      callbackFn(cssText, __errorData);
    }
  }
  if (sourceNodes.length) {
    sourceNodes.forEach(function(node, i) {
      var linkHref = node.getAttribute("href");
      var linkRel = node.getAttribute("rel");
      var isLink = node.nodeName.toLowerCase() === "link" && linkHref && linkRel && linkRel.toLowerCase().indexOf("stylesheet") !== -1;
      var isSkip = settings.skipDisabled === false ? false : node.disabled;
      var isStyle = node.nodeName.toLowerCase() === "style";
      if (isLink && !isSkip) {
        var isURIScheme = linkHref.indexOf("data:text/css") !== -1;
        if (isURIScheme) {
          var cssText = decodeURIComponent(linkHref.substring(linkHref.indexOf(",") + 1));
          if (settings.useCSSOM) {
            cssText = Array.apply(null, node.sheet.cssRules).map(function(rule) {
              return rule.cssText;
            }).join("");
          }
          handleSuccess(cssText, i, node, location.href);
        } else {
          getUrls(linkHref, {
            mimeType: "text/css",
            onBeforeSend: function onBeforeSend2(xhr, url, urlIndex) {
              settings.onBeforeSend(xhr, node, url);
            },
            onSuccess: function onSuccess2(cssText2, url, urlIndex) {
              var sourceUrl = getFullUrl$1(linkHref);
              handleSuccess(cssText2, i, node, sourceUrl);
            },
            onError: function onError2(xhr, url, urlIndex) {
              cssArray[i] = "";
              settings.onError(xhr, node, url);
              handleComplete();
            }
          });
        }
      } else if (isStyle && !isSkip) {
        var _cssText = node.textContent;
        if (settings.useCSSOM) {
          _cssText = Array.apply(null, node.sheet.cssRules).map(function(rule) {
            return rule.cssText;
          }).join("");
        }
        handleSuccess(_cssText, i, node, location.href);
      } else {
        cssArray[i] = "";
        handleComplete();
      }
    });
  } else {
    settings.onComplete("", []);
  }
}
function getFullUrl$1(url, base) {
  var d = document.implementation.createHTMLDocument("");
  var b = d.createElement("base");
  var a = d.createElement("a");
  d.head.appendChild(b);
  d.body.appendChild(a);
  b.href = base || document.baseURI || (document.querySelector("base") || {}).href || location.href;
  a.href = url;
  return a.href;
}
function matchesSelector(elm, selector) {
  var matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;
  return matches.call(elm, selector);
}
var balancedMatch = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp)
    a = maybeMatch(a, str);
  if (b instanceof RegExp)
    b = maybeMatch(b, str);
  var r = range(a, b, str);
  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}
function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
function parseCss(css) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaults2 = {
    preserveStatic: true,
    removeComments: false
  };
  var settings = _extends({}, defaults2, options);
  var errors = [];
  function error(msg) {
    throw new Error("CSS parse error: ".concat(msg));
  }
  function match2(re) {
    var m = re.exec(css);
    if (m) {
      css = css.slice(m[0].length);
      return m;
    }
  }
  function open() {
    return match2(/^{\s*/);
  }
  function close() {
    return match2(/^}/);
  }
  function whitespace() {
    match2(/^\s*/);
  }
  function comment() {
    whitespace();
    if (css[0] !== "/" || css[1] !== "*") {
      return;
    }
    var i = 2;
    while (css[i] && (css[i] !== "*" || css[i + 1] !== "/")) {
      i++;
    }
    if (!css[i]) {
      return error("end of comment is missing");
    }
    var str = css.slice(2, i);
    css = css.slice(i + 2);
    return {
      type: "comment",
      comment: str
    };
  }
  function comments() {
    var cmnts = [];
    var c;
    while (c = comment()) {
      cmnts.push(c);
    }
    return settings.removeComments ? [] : cmnts;
  }
  function selector() {
    whitespace();
    while (css[0] === "}") {
      error("extra closing bracket");
    }
    var m = match2(/^(("(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^{])+)/);
    if (m) {
      var _selector = m[0].trim();
      var selectorItems;
      var hasComment = /\/\*/.test(_selector);
      if (hasComment) {
        _selector = _selector.replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "");
      }
      var hasCommaInQuotes = /["']\w*,\w*["']/.test(_selector);
      if (hasCommaInQuotes) {
        _selector = _selector.replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function(m2) {
          return m2.replace(/,/g, "");
        });
      }
      var hasMultipleSelectors = /,/.test(_selector);
      if (hasMultipleSelectors) {
        selectorItems = _selector.split(/\s*(?![^(]*\)),\s*/);
      } else {
        selectorItems = [_selector];
      }
      if (hasCommaInQuotes) {
        selectorItems = selectorItems.map(function(s) {
          return s.replace(/\u200C/g, ",");
        });
      }
      return selectorItems;
    }
  }
  function declaration() {
    if (css[0] === "@") {
      return at_rule();
    }
    match2(/^([;\s]*)+/);
    var comment_regexp = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var prop = match2(/^(\*?[-#/*\\\w.]+(\[[0-9a-z_-]+\])?)\s*/);
    if (!prop) {
      return;
    }
    prop = prop[0].trim();
    if (!match2(/^:\s*/)) {
      return error("property missing ':'");
    }
    var val = match2(/^((?:\/\*.*?\*\/|'(?:\\'|.)*?'|"(?:\\"|.)*?"|\((\s*'(?:\\'|.)*?'|"(?:\\"|.)*?"|[^)]*?)\s*\)|[^};])+)/);
    var ret = {
      type: "declaration",
      property: prop.replace(comment_regexp, ""),
      value: val ? val[0].replace(comment_regexp, "").trim() : ""
    };
    match2(/^[;\s]*/);
    return ret;
  }
  function declarations() {
    if (!open()) {
      return error("missing '{'");
    }
    var d;
    var decls = comments();
    while (d = declaration()) {
      decls.push(d);
      decls = decls.concat(comments());
    }
    if (!close()) {
      return error("missing '}'");
    }
    return decls;
  }
  function keyframe() {
    whitespace();
    var vals = [];
    var m;
    while (m = match2(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
      vals.push(m[1]);
      match2(/^,\s*/);
    }
    if (vals.length) {
      return {
        type: "keyframe",
        values: vals,
        declarations: declarations()
      };
    }
  }
  function at_keyframes() {
    var m = match2(/^@([-\w]+)?keyframes\s*/);
    if (!m) {
      return;
    }
    var vendor = m[1];
    m = match2(/^([-\w]+)\s*/);
    if (!m) {
      return error("@keyframes missing name");
    }
    var name = m[1];
    if (!open()) {
      return error("@keyframes missing '{'");
    }
    var frame;
    var frames = comments();
    while (frame = keyframe()) {
      frames.push(frame);
      frames = frames.concat(comments());
    }
    if (!close()) {
      return error("@keyframes missing '}'");
    }
    return {
      type: "keyframes",
      name,
      vendor,
      keyframes: frames
    };
  }
  function at_page() {
    var m = match2(/^@page */);
    if (m) {
      var sel = selector() || [];
      return {
        type: "page",
        selectors: sel,
        declarations: declarations()
      };
    }
  }
  function at_page_margin_box() {
    var m = match2(/@(top|bottom|left|right)-(left|center|right|top|middle|bottom)-?(corner)?\s*/);
    if (m) {
      var name = "".concat(m[1], "-").concat(m[2]) + (m[3] ? "-".concat(m[3]) : "");
      return {
        type: "page-margin-box",
        name,
        declarations: declarations()
      };
    }
  }
  function at_fontface() {
    var m = match2(/^@font-face\s*/);
    if (m) {
      return {
        type: "font-face",
        declarations: declarations()
      };
    }
  }
  function at_supports() {
    var m = match2(/^@supports *([^{]+)/);
    if (m) {
      return {
        type: "supports",
        supports: m[1].trim(),
        rules: rules()
      };
    }
  }
  function at_host() {
    var m = match2(/^@host\s*/);
    if (m) {
      return {
        type: "host",
        rules: rules()
      };
    }
  }
  function at_media() {
    var m = match2(/^@media([^{]+)*/);
    if (m) {
      return {
        type: "media",
        media: (m[1] || "").trim(),
        rules: rules()
      };
    }
  }
  function at_custom_m() {
    var m = match2(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
    if (m) {
      return {
        type: "custom-media",
        name: m[1].trim(),
        media: m[2].trim()
      };
    }
  }
  function at_document() {
    var m = match2(/^@([-\w]+)?document *([^{]+)/);
    if (m) {
      return {
        type: "document",
        document: m[2].trim(),
        vendor: m[1] ? m[1].trim() : null,
        rules: rules()
      };
    }
  }
  function at_x() {
    var m = match2(/^@(import|charset|namespace)\s*([^;]+);/);
    if (m) {
      return {
        type: m[1],
        name: m[2].trim()
      };
    }
  }
  function at_rule() {
    whitespace();
    if (css[0] === "@") {
      var ret = at_x() || at_fontface() || at_media() || at_keyframes() || at_supports() || at_document() || at_custom_m() || at_host() || at_page() || at_page_margin_box();
      if (ret && !settings.preserveStatic) {
        var hasVarFunc = false;
        if (ret.declarations) {
          hasVarFunc = ret.declarations.some(function(decl) {
            return /var\(/.test(decl.value);
          });
        } else {
          var arr = ret.keyframes || ret.rules || [];
          hasVarFunc = arr.some(function(obj) {
            return (obj.declarations || []).some(function(decl) {
              return /var\(/.test(decl.value);
            });
          });
        }
        return hasVarFunc ? ret : {};
      }
      return ret;
    }
  }
  function rule() {
    if (!settings.preserveStatic) {
      var balancedMatch$1 = balancedMatch("{", "}", css);
      if (balancedMatch$1) {
        var hasVarDecl = /:(?:root|host)(?![.:#(])/.test(balancedMatch$1.pre) && /--\S*\s*:/.test(balancedMatch$1.body);
        var hasVarFunc = /var\(/.test(balancedMatch$1.body);
        if (!hasVarDecl && !hasVarFunc) {
          css = css.slice(balancedMatch$1.end + 1);
          return {};
        }
      }
    }
    var sel = selector() || [];
    var decls = settings.preserveStatic ? declarations() : declarations().filter(function(decl) {
      var hasVarDecl2 = sel.some(function(s) {
        return /:(?:root|host)(?![.:#(])/.test(s);
      }) && /^--\S/.test(decl.property);
      var hasVarFunc2 = /var\(/.test(decl.value);
      return hasVarDecl2 || hasVarFunc2;
    });
    if (!sel.length) {
      error("selector missing");
    }
    return {
      type: "rule",
      selectors: sel,
      declarations: decls
    };
  }
  function rules(core) {
    if (!core && !open()) {
      return error("missing '{'");
    }
    var node;
    var rules2 = comments();
    while (css.length && (core || css[0] !== "}") && (node = at_rule() || rule())) {
      if (node.type) {
        rules2.push(node);
      }
      rules2 = rules2.concat(comments());
    }
    if (!core && !close()) {
      return error("missing '}'");
    }
    return rules2;
  }
  return {
    type: "stylesheet",
    stylesheet: {
      rules: rules(true),
      errors
    }
  };
}
function parseVars(cssData) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaults2 = {
    parseHost: false,
    store: {},
    onWarning: function onWarning2() {
    }
  };
  var settings = _extends({}, defaults2, options);
  var reVarDeclSelectors = new RegExp(":".concat(settings.parseHost ? "host" : "root", "$"));
  if (typeof cssData === "string") {
    cssData = parseCss(cssData, settings);
  }
  cssData.stylesheet.rules.forEach(function(rule) {
    if (rule.type !== "rule" || !rule.selectors.some(function(s) {
      return reVarDeclSelectors.test(s);
    })) {
      return;
    }
    rule.declarations.forEach(function(decl, i) {
      var prop = decl.property;
      var value = decl.value;
      if (prop && prop.indexOf("--") === 0) {
        settings.store[prop] = value;
      }
    });
  });
  return settings.store;
}
function stringifyCss(tree) {
  var delim = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var cb = arguments.length > 2 ? arguments[2] : void 0;
  var renderMethods = {
    charset: function charset(node) {
      return "@charset " + node.name + ";";
    },
    comment: function comment(node) {
      return node.comment.indexOf("__CSSVARSPONYFILL") === 0 ? "/*" + node.comment + "*/" : "";
    },
    "custom-media": function customMedia(node) {
      return "@custom-media " + node.name + " " + node.media + ";";
    },
    declaration: function declaration(node) {
      return node.property + ":" + node.value + ";";
    },
    document: function document2(node) {
      return "@" + (node.vendor || "") + "document " + node.document + "{" + visit(node.rules) + "}";
    },
    "font-face": function fontFace(node) {
      return "@font-face{" + visit(node.declarations) + "}";
    },
    host: function host(node) {
      return "@host{" + visit(node.rules) + "}";
    },
    import: function _import(node) {
      return "@import " + node.name + ";";
    },
    keyframe: function keyframe(node) {
      return node.values.join(",") + "{" + visit(node.declarations) + "}";
    },
    keyframes: function keyframes(node) {
      return "@" + (node.vendor || "") + "keyframes " + node.name + "{" + visit(node.keyframes) + "}";
    },
    media: function media(node) {
      return "@media " + node.media + "{" + visit(node.rules) + "}";
    },
    namespace: function namespace(node) {
      return "@namespace " + node.name + ";";
    },
    page: function page(node) {
      return "@page " + (node.selectors.length ? node.selectors.join(", ") : "") + "{" + visit(node.declarations) + "}";
    },
    "page-margin-box": function pageMarginBox(node) {
      return "@" + node.name + "{" + visit(node.declarations) + "}";
    },
    rule: function rule(node) {
      var decls = node.declarations;
      if (decls.length) {
        return node.selectors.join(",") + "{" + visit(decls) + "}";
      }
    },
    supports: function supports(node) {
      return "@supports " + node.supports + "{" + visit(node.rules) + "}";
    }
  };
  function visit(nodes) {
    var buf = "";
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      if (cb) {
        cb(n);
      }
      var txt = renderMethods[n.type](n);
      if (txt) {
        buf += txt;
        if (txt.length && n.selectors) {
          buf += delim;
        }
      }
    }
    return buf;
  }
  return visit(tree.stylesheet.rules);
}
function walkCss(node, fn) {
  node.rules.forEach(function(rule) {
    if (rule.rules) {
      walkCss(rule, fn);
      return;
    }
    if (rule.keyframes) {
      rule.keyframes.forEach(function(keyframe) {
        if (keyframe.type === "keyframe") {
          fn(keyframe.declarations, rule);
        }
      });
      return;
    }
    if (!rule.declarations) {
      return;
    }
    fn(rule.declarations, node);
  });
}
var VAR_PROP_IDENTIFIER = "--";
var VAR_FUNC_IDENTIFIER = "var";
function transformCss(cssData) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var defaults2 = {
    preserveStatic: true,
    preserveVars: false,
    variables: {},
    onWarning: function onWarning2() {
    }
  };
  var settings = _extends({}, defaults2, options);
  if (typeof cssData === "string") {
    cssData = parseCss(cssData, settings);
  }
  walkCss(cssData.stylesheet, function(declarations, node) {
    for (var i = 0; i < declarations.length; i++) {
      var decl = declarations[i];
      var type = decl.type;
      var prop = decl.property;
      var value = decl.value;
      if (type !== "declaration") {
        continue;
      }
      if (!settings.preserveVars && prop && prop.indexOf(VAR_PROP_IDENTIFIER) === 0) {
        declarations.splice(i, 1);
        i--;
        continue;
      }
      if (value.indexOf(VAR_FUNC_IDENTIFIER + "(") !== -1) {
        var resolvedValue = resolveValue(value, settings);
        if (resolvedValue !== decl.value) {
          resolvedValue = fixNestedCalc(resolvedValue);
          if (!settings.preserveVars) {
            decl.value = resolvedValue;
          } else {
            declarations.splice(i, 0, {
              type,
              property: prop,
              value: resolvedValue
            });
            i++;
          }
        }
      }
    }
  });
  return stringifyCss(cssData);
}
function fixNestedCalc(value) {
  var reCalcVal = /calc\(([^)]+)\)/g;
  (value.match(reCalcVal) || []).forEach(function(match2) {
    var newVal = "calc".concat(match2.split("calc").join(""));
    value = value.replace(match2, newVal);
  });
  return value;
}
function resolveValue(value) {
  var settings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var __recursiveFallback = arguments.length > 2 ? arguments[2] : void 0;
  if (value.indexOf("var(") === -1) {
    return value;
  }
  var valueData = balancedMatch("(", ")", value);
  function resolveFunc(value2) {
    var name = value2.split(",")[0].replace(/[\s\n\t]/g, "");
    var fallback = (value2.match(/(?:\s*,\s*){1}(.*)?/) || [])[1];
    var match2 = Object.prototype.hasOwnProperty.call(settings.variables, name) ? String(settings.variables[name]) : void 0;
    var replacement = match2 || (fallback ? String(fallback) : void 0);
    var unresolvedFallback = __recursiveFallback || value2;
    if (!match2) {
      settings.onWarning('variable "'.concat(name, '" is undefined'));
    }
    if (replacement && replacement !== "undefined" && replacement.length > 0) {
      return resolveValue(replacement, settings, unresolvedFallback);
    } else {
      return "var(".concat(unresolvedFallback, ")");
    }
  }
  if (!valueData) {
    if (value.indexOf("var(") !== -1) {
      settings.onWarning('missing closing ")" in the value "'.concat(value, '"'));
    }
    return value;
  } else if (valueData.pre.slice(-3) === "var") {
    var isEmptyVarFunc = valueData.body.trim().length === 0;
    if (isEmptyVarFunc) {
      settings.onWarning("var() must contain a non-whitespace string");
      return value;
    } else {
      return valueData.pre.slice(0, -3) + resolveFunc(valueData.body) + resolveValue(valueData.post, settings);
    }
  } else {
    return valueData.pre + "(".concat(resolveValue(valueData.body, settings), ")") + resolveValue(valueData.post, settings);
  }
}
var isBrowser = typeof window !== "undefined";
var isNativeSupport = isBrowser && window.CSS && window.CSS.supports && window.CSS.supports("(--a: 0)");
var counters = {
  group: 0,
  job: 0
};
var defaults = {
  rootElement: isBrowser ? document : null,
  shadowDOM: false,
  include: "style,link[rel=stylesheet]",
  exclude: "",
  variables: {},
  onlyLegacy: true,
  preserveStatic: true,
  preserveVars: false,
  silent: false,
  updateDOM: true,
  updateURLs: true,
  watch: null,
  onBeforeSend: function onBeforeSend() {
  },
  onError: function onError() {
  },
  onWarning: function onWarning() {
  },
  onSuccess: function onSuccess() {
  },
  onComplete: function onComplete() {
  },
  onFinally: function onFinally() {
  }
};
var regex = {
  cssComments: /\/\*[\s\S]+?\*\//g,
  cssKeyframes: /@(?:-\w*-)?keyframes/,
  cssMediaQueries: /@media[^{]+\{([\s\S]+?})\s*}/g,
  cssUrls: /url\((?!['"]?(?:data|http|\/\/):)['"]?([^'")]*)['"]?\)/g,
  cssVarDeclRules: /(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^}]*})/g,
  cssVarDecls: /(?:[\s;]*)(-{2}\w[\w-]*)(?:\s*:\s*)([^;]*);/g,
  cssVarFunc: /var\(\s*--[\w-]/,
  cssVars: /(?:(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^;]*;*\s*)|(?:var\(\s*))(--[^:)]+)(?:\s*[:)])/
};
var variableStore = {
  dom: {},
  job: {},
  user: {}
};
var cssVarsIsRunning = false;
var cssVarsObserver = null;
var cssVarsSrcNodeCount = 0;
var debounceTimer = null;
var isShadowDOMReady = false;
function cssVars() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var msgPrefix = "cssVars(): ";
  var settings = _extends({}, defaults, options);
  function handleError(message, sourceNode, xhr, url) {
    if (!settings.silent && window.console) {
      console.error("".concat(msgPrefix).concat(message, "\n"), sourceNode);
    }
    settings.onError(message, sourceNode, xhr, url);
  }
  function handleWarning(message) {
    if (!settings.silent && window.console) {
      console.warn("".concat(msgPrefix).concat(message));
    }
    settings.onWarning(message);
  }
  function handleFinally(hasChanged) {
    settings.onFinally(Boolean(hasChanged), isNativeSupport, getTimeStamp() - settings.__benchmark);
  }
  if (!isBrowser) {
    return;
  }
  if (settings.watch) {
    settings.watch = defaults.watch;
    addMutationObserver(settings);
    cssVars(settings);
    return;
  } else if (settings.watch === false && cssVarsObserver) {
    cssVarsObserver.disconnect();
    cssVarsObserver = null;
  }
  if (!settings.__benchmark) {
    if (cssVarsIsRunning === settings.rootElement) {
      cssVarsDebounced(options);
      return;
    }
    var srcNodes = [].slice.call(settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])'));
    settings.__benchmark = getTimeStamp();
    settings.exclude = [cssVarsObserver ? '[data-cssvars]:not([data-cssvars=""])' : '[data-cssvars="out"]', "link[disabled]:not([data-cssvars])", settings.exclude].filter(function(selector) {
      return selector;
    }).join(",");
    settings.variables = fixVarNames(settings.variables);
    srcNodes.forEach(function(srcNode) {
      var hasStyleCache = srcNode.nodeName.toLowerCase() === "style" && srcNode.__cssVars.text;
      var hasStyleChanged = hasStyleCache && srcNode.textContent !== srcNode.__cssVars.text;
      if (hasStyleCache && hasStyleChanged) {
        srcNode.sheet && (srcNode.sheet.disabled = false);
        srcNode.setAttribute("data-cssvars", "");
      }
    });
    if (!cssVarsObserver) {
      var outNodes = [].slice.call(settings.rootElement.querySelectorAll('[data-cssvars="out"]'));
      outNodes.forEach(function(outNode) {
        var dataGroup = outNode.getAttribute("data-cssvars-group");
        var srcNode = dataGroup ? settings.rootElement.querySelector('[data-cssvars="src"][data-cssvars-group="'.concat(dataGroup, '"]')) : null;
        if (!srcNode) {
          outNode.parentNode.removeChild(outNode);
        }
      });
      if (cssVarsSrcNodeCount && srcNodes.length < cssVarsSrcNodeCount) {
        cssVarsSrcNodeCount = srcNodes.length;
        variableStore.dom = {};
      }
    }
  }
  if (document.readyState !== "loading") {
    if (isNativeSupport && settings.onlyLegacy) {
      var hasVarChange = false;
      if (settings.updateDOM) {
        var targetElm = settings.rootElement.host || (settings.rootElement === document ? document.documentElement : settings.rootElement);
        Object.keys(settings.variables).forEach(function(key) {
          var varValue = settings.variables[key];
          hasVarChange = hasVarChange || varValue !== getComputedStyle(targetElm).getPropertyValue(key);
          targetElm.style.setProperty(key, varValue);
        });
      }
      handleFinally(hasVarChange);
    } else if (!isShadowDOMReady && (settings.shadowDOM || settings.rootElement.shadowRoot || settings.rootElement.host)) {
      getCssData({
        rootElement: defaults.rootElement,
        include: defaults.include,
        exclude: settings.exclude,
        skipDisabled: false,
        onSuccess: function onSuccess2(cssText, node, url) {
          var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
          if (isUserDisabled) {
            return false;
          }
          cssText = cssText.replace(regex.cssComments, "").replace(regex.cssMediaQueries, "");
          cssText = (cssText.match(regex.cssVarDeclRules) || []).join("");
          return cssText || false;
        },
        onComplete: function onComplete2(cssText, cssArray, nodeArray) {
          parseVars(cssText, {
            store: variableStore.dom,
            onWarning: handleWarning
          });
          isShadowDOMReady = true;
          cssVars(settings);
        }
      });
    } else {
      cssVarsIsRunning = settings.rootElement;
      getCssData({
        rootElement: settings.rootElement,
        include: settings.include,
        exclude: settings.exclude,
        skipDisabled: false,
        onBeforeSend: settings.onBeforeSend,
        onError: function onError2(xhr, node, url) {
          var responseUrl = xhr.responseURL || getFullUrl(url, location.href);
          var statusText = xhr.statusText ? "(".concat(xhr.statusText, ")") : "Unspecified Error" + (xhr.status === 0 ? " (possibly CORS related)" : "");
          var errorMsg = "CSS XHR Error: ".concat(responseUrl, " ").concat(xhr.status, " ").concat(statusText);
          handleError(errorMsg, node, xhr, responseUrl);
        },
        onSuccess: function onSuccess2(cssText, node, url) {
          var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
          if (isUserDisabled) {
            return false;
          }
          var isLink = node.nodeName.toLowerCase() === "link";
          var isStyleImport = node.nodeName.toLowerCase() === "style" && cssText !== node.textContent;
          var returnVal = settings.onSuccess(cssText, node, url);
          cssText = returnVal !== void 0 && Boolean(returnVal) === false ? "" : returnVal || cssText;
          if (settings.updateURLs && (isLink || isStyleImport)) {
            cssText = fixRelativeCssUrls(cssText, url);
          }
          return cssText;
        },
        onComplete: function onComplete2(cssText, cssArray) {
          var nodeArray = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
          var currentVars = _extends({}, variableStore.dom, variableStore.user);
          var hasVarChange2 = false;
          variableStore.job = {};
          nodeArray.forEach(function(node, i2) {
            var nodeCSS = cssArray[i2];
            node.__cssVars = node.__cssVars || {};
            node.__cssVars.text = nodeCSS;
            if (regex.cssVars.test(nodeCSS)) {
              try {
                var cssTree = parseCss(nodeCSS, {
                  preserveStatic: settings.preserveStatic,
                  removeComments: true
                });
                parseVars(cssTree, {
                  parseHost: Boolean(settings.rootElement.host),
                  store: variableStore.dom,
                  onWarning: handleWarning
                });
                node.__cssVars.tree = cssTree;
              } catch (err) {
                handleError(err.message, node);
              }
            }
          });
          _extends(variableStore.job, variableStore.dom);
          if (settings.updateDOM) {
            _extends(variableStore.user, settings.variables);
            _extends(variableStore.job, variableStore.user);
          } else {
            _extends(variableStore.job, variableStore.user, settings.variables);
            _extends(currentVars, settings.variables);
          }
          hasVarChange2 = counters.job > 0 && Boolean(Object.keys(variableStore.job).length > Object.keys(currentVars).length || Boolean(Object.keys(currentVars).length && Object.keys(variableStore.job).some(function(key) {
            return variableStore.job[key] !== currentVars[key];
          })));
          if (hasVarChange2) {
            resetCssNodes(settings.rootElement);
            cssVars(settings);
          } else {
            var outCssArray = [];
            var outNodeArray = [];
            var hasKeyframesWithVars = false;
            if (settings.updateDOM) {
              counters.job++;
            }
            nodeArray.forEach(function(node, i2) {
              var isSkip = !node.__cssVars.tree;
              if (node.__cssVars.tree) {
                try {
                  transformCss(node.__cssVars.tree, _extends({}, settings, {
                    variables: variableStore.job,
                    onWarning: handleWarning
                  }));
                  var outCss = stringifyCss(node.__cssVars.tree);
                  if (settings.updateDOM) {
                    var nodeCSS = cssArray[i2];
                    var hasCSSVarFunc = regex.cssVarFunc.test(nodeCSS);
                    if (!node.getAttribute("data-cssvars")) {
                      node.setAttribute("data-cssvars", "src");
                    }
                    if (outCss.length && hasCSSVarFunc) {
                      var dataGroup = node.getAttribute("data-cssvars-group") || ++counters.group;
                      var outCssNoSpaces = outCss.replace(/\s/g, "");
                      var outNode = settings.rootElement.querySelector('[data-cssvars="out"][data-cssvars-group="'.concat(dataGroup, '"]')) || document.createElement("style");
                      hasKeyframesWithVars = hasKeyframesWithVars || regex.cssKeyframes.test(outCss);
                      if (settings.preserveStatic) {
                        node.sheet && (node.sheet.disabled = true);
                      }
                      if (!outNode.hasAttribute("data-cssvars")) {
                        outNode.setAttribute("data-cssvars", "out");
                      }
                      if (outCssNoSpaces === node.textContent.replace(/\s/g, "")) {
                        isSkip = true;
                        if (outNode && outNode.parentNode) {
                          node.removeAttribute("data-cssvars-group");
                          outNode.parentNode.removeChild(outNode);
                        }
                      } else if (outCssNoSpaces !== outNode.textContent.replace(/\s/g, "")) {
                        [node, outNode].forEach(function(n) {
                          n.setAttribute("data-cssvars-job", counters.job);
                          n.setAttribute("data-cssvars-group", dataGroup);
                        });
                        outNode.textContent = outCss;
                        outCssArray.push(outCss);
                        outNodeArray.push(outNode);
                        if (!outNode.parentNode) {
                          node.parentNode.insertBefore(outNode, node.nextSibling);
                        }
                      }
                    }
                  } else {
                    if (node.textContent.replace(/\s/g, "") !== outCss) {
                      outCssArray.push(outCss);
                    }
                  }
                } catch (err) {
                  handleError(err.message, node);
                }
              }
              if (isSkip) {
                node.setAttribute("data-cssvars", "skip");
              }
              if (!node.hasAttribute("data-cssvars-job")) {
                node.setAttribute("data-cssvars-job", counters.job);
              }
            });
            cssVarsSrcNodeCount = settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])').length;
            if (settings.shadowDOM) {
              var elms = [].concat(settings.rootElement).concat([].slice.call(settings.rootElement.querySelectorAll("*")));
              for (var i = 0, elm; elm = elms[i]; ++i) {
                if (elm.shadowRoot && elm.shadowRoot.querySelector("style")) {
                  var shadowSettings = _extends({}, settings, {
                    rootElement: elm.shadowRoot
                  });
                  cssVars(shadowSettings);
                }
              }
            }
            if (settings.updateDOM && hasKeyframesWithVars) {
              fixKeyframes(settings.rootElement);
            }
            cssVarsIsRunning = false;
            settings.onComplete(outCssArray.join(""), outNodeArray, JSON.parse(JSON.stringify(variableStore.job)), getTimeStamp() - settings.__benchmark);
            handleFinally(outNodeArray.length);
          }
        }
      });
    }
  } else {
    document.addEventListener("DOMContentLoaded", function init(evt) {
      cssVars(options);
      document.removeEventListener("DOMContentLoaded", init);
    });
  }
}
cssVars.reset = function() {
  counters.job = 0;
  counters.group = 0;
  cssVarsIsRunning = false;
  if (cssVarsObserver) {
    cssVarsObserver.disconnect();
    cssVarsObserver = null;
  }
  cssVarsSrcNodeCount = 0;
  debounceTimer = null;
  isShadowDOMReady = false;
  for (var prop in variableStore) {
    variableStore[prop] = {};
  }
};
function addMutationObserver(settings) {
  function isDisabled(node) {
    var isDisabledAttr = isLink(node) && node.hasAttribute("disabled");
    var isDisabledSheet = (node.sheet || {}).disabled;
    return isDisabledAttr || isDisabledSheet;
  }
  function isLink(node) {
    var isStylesheet = node.nodeName.toLowerCase() === "link" && (node.getAttribute("rel") || "").indexOf("stylesheet") !== -1;
    return isStylesheet;
  }
  function isStyle(node) {
    return node.nodeName.toLowerCase() === "style";
  }
  function isValidAttributeMutation(mutation) {
    var isValid2 = false;
    if (mutation.type === "attributes" && isLink(mutation.target) && !isDisabled(mutation.target)) {
      var isEnabledMutation = mutation.attributeName === "disabled";
      var isHrefMutation = mutation.attributeName === "href";
      var isSkipNode = mutation.target.getAttribute("data-cssvars") === "skip";
      var isSrcNode = mutation.target.getAttribute("data-cssvars") === "src";
      if (isEnabledMutation) {
        isValid2 = !isSkipNode && !isSrcNode;
      } else if (isHrefMutation) {
        if (isSkipNode) {
          mutation.target.setAttribute("data-cssvars", "");
        } else if (isSrcNode) {
          resetCssNodes(settings.rootElement, true);
        }
        isValid2 = true;
      }
    }
    return isValid2;
  }
  function isValidStyleTextMutation(mutation) {
    var isValid2 = false;
    if (mutation.type === "childList") {
      var isStyleElm = isStyle(mutation.target);
      var isOutNode = mutation.target.getAttribute("data-cssvars") === "out";
      isValid2 = isStyleElm && !isOutNode;
    }
    return isValid2;
  }
  function isValidAddMutation(mutation) {
    var isValid2 = false;
    if (mutation.type === "childList") {
      isValid2 = [].slice.call(mutation.addedNodes).some(function(node) {
        var isElm = node.nodeType === 1;
        var hasAttr = isElm && node.hasAttribute("data-cssvars");
        var isStyleWithVars = isStyle(node) && regex.cssVars.test(node.textContent);
        var isValid3 = !hasAttr && (isLink(node) || isStyleWithVars);
        return isValid3 && !isDisabled(node);
      });
    }
    return isValid2;
  }
  function isValidRemoveMutation(mutation) {
    var isValid2 = false;
    if (mutation.type === "childList") {
      isValid2 = [].slice.call(mutation.removedNodes).some(function(node) {
        var isElm = node.nodeType === 1;
        var isOutNode = isElm && node.getAttribute("data-cssvars") === "out";
        var isSrcNode = isElm && node.getAttribute("data-cssvars") === "src";
        var isValid3 = isSrcNode;
        if (isSrcNode || isOutNode) {
          var dataGroup = node.getAttribute("data-cssvars-group");
          var orphanNode = settings.rootElement.querySelector('[data-cssvars-group="'.concat(dataGroup, '"]'));
          if (isSrcNode) {
            resetCssNodes(settings.rootElement, true);
          }
          if (orphanNode) {
            orphanNode.parentNode.removeChild(orphanNode);
          }
        }
        return isValid3;
      });
    }
    return isValid2;
  }
  if (!window.MutationObserver) {
    return;
  }
  if (cssVarsObserver) {
    cssVarsObserver.disconnect();
    cssVarsObserver = null;
  }
  cssVarsObserver = new MutationObserver(function(mutations) {
    var hasValidMutation = mutations.some(function(mutation) {
      return isValidAttributeMutation(mutation) || isValidStyleTextMutation(mutation) || isValidAddMutation(mutation) || isValidRemoveMutation(mutation);
    });
    if (hasValidMutation) {
      cssVars(settings);
    }
  });
  cssVarsObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter: ["disabled", "href"],
    childList: true,
    subtree: true
  });
}
function cssVarsDebounced(settings) {
  var delay2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
  clearTimeout(debounceTimer);
  debounceTimer = setTimeout(function() {
    settings.__benchmark = null;
    cssVars(settings);
  }, delay2);
}
function fixKeyframes(rootElement) {
  var animationNameProp = ["animation-name", "-moz-animation-name", "-webkit-animation-name"].filter(function(prop) {
    return getComputedStyle(document.body)[prop];
  })[0];
  if (animationNameProp) {
    var allNodes = [].slice.call(rootElement.querySelectorAll("*"));
    var keyframeNodes = [];
    var nameMarker = "__CSSVARSPONYFILL-KEYFRAMES__";
    for (var i = 0, len = allNodes.length; i < len; i++) {
      var node = allNodes[i];
      var animationName = getComputedStyle(node)[animationNameProp];
      if (animationName !== "none") {
        node.style[animationNameProp] += nameMarker;
        keyframeNodes.push(node);
      }
    }
    void document.body.offsetHeight;
    for (var _i = 0, _len = keyframeNodes.length; _i < _len; _i++) {
      var nodeStyle = keyframeNodes[_i].style;
      nodeStyle[animationNameProp] = nodeStyle[animationNameProp].replace(nameMarker, "");
    }
  }
}
function fixRelativeCssUrls(cssText, baseUrl) {
  var cssUrls = cssText.replace(regex.cssComments, "").match(regex.cssUrls) || [];
  cssUrls.forEach(function(cssUrl) {
    var oldUrl = cssUrl.replace(regex.cssUrls, "$1");
    var newUrl = getFullUrl(oldUrl, baseUrl);
    cssText = cssText.replace(cssUrl, cssUrl.replace(oldUrl, newUrl));
  });
  return cssText;
}
function fixVarNames() {
  var varObj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var reLeadingHyphens = /^-{2}/;
  return Object.keys(varObj).reduce(function(obj, value) {
    var key = reLeadingHyphens.test(value) ? value : "--".concat(value.replace(/^-+/, ""));
    obj[key] = varObj[value];
    return obj;
  }, {});
}
function getFullUrl(url) {
  var base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : location.href;
  var d = document.implementation.createHTMLDocument("");
  var b = d.createElement("base");
  var a = d.createElement("a");
  d.head.appendChild(b);
  d.body.appendChild(a);
  b.href = base;
  a.href = url;
  return a.href;
}
function getTimeStamp() {
  return isBrowser && (window.performance || {}).now ? window.performance.now() : (/* @__PURE__ */ new Date()).getTime();
}
function resetCssNodes(rootElement) {
  var resetDOMVariableStore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var resetNodes = [].slice.call(rootElement.querySelectorAll('[data-cssvars="skip"],[data-cssvars="src"]'));
  resetNodes.forEach(function(node) {
    return node.setAttribute("data-cssvars", "");
  });
  if (resetDOMVariableStore) {
    variableStore.dom = {};
  }
}

// node_modules/@sendbird/uikit-react/chunks/bundle-Bb5bU2pm.js
var import_react22 = __toESM(require_react(), 1);
function useSetChannel(_a, _b) {
  var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit;
  var sdk = _b.sdk, logger = _b.logger;
  var _c = useMessageSearch().actions, setCurrentChannel = _c.setCurrentChannel, setChannelInvalid = _c.setChannelInvalid;
  (0, import_react22.useEffect)(function() {
    if (channelUrl && sdkInit && (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel)) {
      sdk.groupChannel.getChannel(channelUrl).then(function(groupChannel) {
        logger.info("MessageSearch | useSetChannel group channel", groupChannel);
        setCurrentChannel(groupChannel);
      }).catch(function() {
        setChannelInvalid();
      });
    }
  }, [channelUrl, sdkInit]);
}
var MessageSearchOrder;
(function(MessageSearchOrder2) {
  MessageSearchOrder2["SCORE"] = "score";
  MessageSearchOrder2["TIMESTAMP"] = "ts";
})(MessageSearchOrder || (MessageSearchOrder = {}));
function useGetSearchedMessages(_a, _b) {
  var currentChannel = _a.currentChannel, channelUrl = _a.channelUrl, requestString = _a.requestString, messageSearchQuery = _a.messageSearchQuery, onResultLoaded = _a.onResultLoaded;
  var sdk = _b.sdk, logger = _b.logger;
  var _c = useMessageSearch(), retryCount = _c.state.retryCount, _d = _c.actions, startMessageSearch = _d.startMessageSearch, getSearchedMessages = _d.getSearchedMessages, setQueryInvalid = _d.setQueryInvalid, startGettingSearchedMessages = _d.startGettingSearchedMessages;
  var handleSearchError = (0, import_react22.useCallback)(function(error) {
    logger.warning("MessageSearch | useGetSearchedMessages: failed getting search messages.", error);
    setQueryInvalid();
    if (onResultLoaded && typeof onResultLoaded === "function") {
      onResultLoaded(void 0, error);
    }
  }, [logger, setQueryInvalid, onResultLoaded]);
  (0, import_react22.useEffect)(function() {
    startMessageSearch();
    if (sdk && channelUrl && sdk.createMessageSearchQuery && currentChannel && requestString) {
      currentChannel.refresh().then(function(channel) {
        var inputSearchMessageQueryObject = __assign({ order: MessageSearchOrder.TIMESTAMP, channelUrl, messageTimestampFrom: channel.invitedAt, keyword: requestString }, messageSearchQuery);
        var createdQuery = sdk.createMessageSearchQuery(inputSearchMessageQueryObject);
        startGettingSearchedMessages(createdQuery);
        createdQuery.next().then(function(messages) {
          logger.info("MessageSearch | useGetSearchedMessages: succeeded getting messages", messages);
          getSearchedMessages(messages, createdQuery);
          if (onResultLoaded && typeof onResultLoaded === "function") {
            onResultLoaded(messages, void 0);
          }
        }).catch(handleSearchError);
      }).catch(function(error) {
        logger.warning("MessageSearch | useGetSearchedMessages: failed getting channel.", error);
        handleSearchError(error);
      });
    } else if (!requestString) {
      logger.info("MessageSearch | useGetSearchedMessages: search string is empty");
    }
  }, [channelUrl, messageSearchQuery, requestString, currentChannel, retryCount]);
}
function useScrollCallback(_a, _b) {
  var onResultLoaded = _a.onResultLoaded;
  var logger = _b.logger;
  var _c = useMessageSearch(), _d = _c.state, currentMessageSearchQuery = _d.currentMessageSearchQuery, hasMoreResult = _d.hasMoreResult, getNextSearchedMessages = _c.actions.getNextSearchedMessages;
  return (0, import_react22.useCallback)(function(cb) {
    if (!hasMoreResult) {
      logger.warning("MessageSearch | useScrollCallback: no more searched results", hasMoreResult);
    }
    if (currentMessageSearchQuery && currentMessageSearchQuery.hasNext) {
      currentMessageSearchQuery.next().then(function(messages) {
        logger.info("MessageSearch | useScrollCallback: succeeded getting searched messages", messages);
        getNextSearchedMessages(messages);
        cb(messages, null);
        if (onResultLoaded && typeof onResultLoaded === "function") {
          onResultLoaded(messages, null);
        }
      }).catch(function(error) {
        logger.warning("MessageSearch | useScrollCallback: failed getting searched messages", error);
        cb(null, error);
        if (onResultLoaded && typeof onResultLoaded === "function") {
          onResultLoaded(null, error);
        }
      });
    } else {
      logger.warning("MessageSearch | useScrollCallback: no currentMessageSearchQuery");
    }
  }, [currentMessageSearchQuery, hasMoreResult]);
}
var DEBOUNCING_TIME = 500;
function useSearchStringEffect(_a) {
  var searchString = _a.searchString;
  var _b = (0, import_react22.useState)(""), requestString = _b[0], setRequestString = _b[1];
  var _c = (0, import_react22.useState)(null), debouncingTimer = _c[0], setDebouncingTimer = _c[1];
  var resetSearchString = useMessageSearch().actions.resetSearchString;
  var handleSearchStringChange = (0, import_react22.useCallback)(function() {
    if (searchString) {
      setRequestString(searchString);
    } else {
      setRequestString("");
      resetSearchString();
    }
  }, [searchString, resetSearchString]);
  (0, import_react22.useEffect)(function() {
    if (debouncingTimer) {
      clearTimeout(debouncingTimer);
    }
    var timer = setTimeout(handleSearchStringChange, DEBOUNCING_TIME);
    setDebouncingTimer(timer);
    return function() {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [searchString, handleSearchStringChange]);
  return requestString;
}
var initialState4 = {
  channelUrl: "",
  allMessages: [],
  loading: false,
  isInvalid: false,
  initialized: false,
  currentChannel: null,
  currentMessageSearchQuery: null,
  messageSearchQuery: null,
  hasMoreResult: false,
  retryCount: 0,
  selectedMessageId: null,
  searchString: "",
  requestString: ""
  /**
   * messageSearchDispatcher is no longer used.
   * Please use useMessageSearch() to get the store and update the state.
   */
  // messageSearchDispatcher: null,
};
var MessageSearchContext = (0, import_react22.createContext)(null);
var MessageSearchManager = function(_a) {
  var _b, _c;
  var channelUrl = _a.channelUrl, searchString = _a.searchString, messageSearchQuery = _a.messageSearchQuery, onResultLoaded = _a.onResultLoaded, onResultClick = _a.onResultClick;
  var _d = useMessageSearchStore(), state = _d.state, updateState = _d.updateState;
  var _e = useSendbird().state, config = _e.config, stores = _e.stores;
  var sdk = (_b = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;
  var sdkInit = (_c = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _c === void 0 ? void 0 : _c.initialized;
  var logger = config.logger;
  var scrollRef = (0, import_react22.useRef)(null);
  useSetChannel({ channelUrl, sdkInit }, { sdk, logger });
  var _searchString = (0, import_react22.useMemo)(function() {
    var _a2;
    return (_a2 = searchString !== null && searchString !== void 0 ? searchString : messageSearchQuery === null || messageSearchQuery === void 0 ? void 0 : messageSearchQuery.keyword) !== null && _a2 !== void 0 ? _a2 : "";
  }, [searchString, messageSearchQuery === null || messageSearchQuery === void 0 ? void 0 : messageSearchQuery.keyword]);
  var requestString = useSearchStringEffect({ searchString: _searchString });
  useGetSearchedMessages({
    currentChannel: state.currentChannel,
    channelUrl,
    requestString,
    messageSearchQuery,
    onResultLoaded
  }, { sdk, logger });
  var onScroll = useScrollCallback({ onResultLoaded }, { logger });
  var handleOnScroll = (0, import_react22.useCallback)(function(e) {
    var scrollElement = e.target;
    var scrollTop = scrollElement.scrollTop, scrollHeight = scrollElement.scrollHeight, clientHeight = scrollElement.clientHeight;
    if (!state.hasMoreResult) {
      return;
    }
    if (scrollTop + clientHeight >= scrollHeight) {
      onScroll(function() {
      });
    }
  }, [state.hasMoreResult, onScroll]);
  (0, import_react22.useEffect)(function() {
    updateState({
      channelUrl,
      searchString: _searchString,
      messageSearchQuery,
      onResultClick,
      onScroll,
      handleOnScroll,
      scrollRef,
      requestString
    });
  }, [channelUrl, searchString, messageSearchQuery, onResultClick, updateState, requestString]);
  return null;
};
var createMessageSearchStore = function(props) {
  return createStore(__assign(__assign({}, initialState4), props));
};
var InternalMessageSearchProvider = function(props) {
  var children = props.children;
  var defaultProps = deleteNullish({
    channelUrl: props === null || props === void 0 ? void 0 : props.channelUrl,
    messageSearchQuery: props === null || props === void 0 ? void 0 : props.messageSearchQuery,
    searchString: props === null || props === void 0 ? void 0 : props.searchString,
    onResultLoaded: props === null || props === void 0 ? void 0 : props.onResultLoaded,
    onResultClick: props === null || props === void 0 ? void 0 : props.onResultClick
  });
  var storeRef = (0, import_react22.useRef)(createMessageSearchStore(defaultProps));
  return import_react22.default.createElement(MessageSearchContext.Provider, { value: storeRef.current }, children);
};
var MessageSearchProvider = function(props) {
  var children = props.children, channelUrl = props.channelUrl, searchString = props.searchString, messageSearchQuery = props.messageSearchQuery, onResultLoaded = props.onResultLoaded, onResultClick = props.onResultClick;
  return import_react22.default.createElement(
    InternalMessageSearchProvider,
    __assign({}, props),
    import_react22.default.createElement(MessageSearchManager, { channelUrl, searchString, messageSearchQuery, onResultLoaded, onResultClick }),
    children
  );
};
var useMessageSearchStore = function() {
  return useStore(MessageSearchContext, function(state) {
    return state;
  }, initialState4);
};
var useMessageSearch = function() {
  var store = (0, import_react22.useContext)(MessageSearchContext);
  if (!store)
    throw new Error("useMessageSearch must be used within a MessageSearchProvider");
  var state = shimExports.useSyncExternalStore(store.subscribe, store.getState);
  var actions = (0, import_react22.useMemo)(function() {
    return {
      setCurrentChannel: function(channel) {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { currentChannel: channel, initialized: true });
        });
      },
      setChannelInvalid: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { currentChannel: null, initialized: false });
        });
      },
      getSearchedMessages: function(messages, createdQuery) {
        store.setState(function(state2) {
          var _a;
          if (createdQuery && createdQuery.channelUrl === ((_a = state2.currentMessageSearchQuery) === null || _a === void 0 ? void 0 : _a.channelUrl) && createdQuery.key === state2.currentMessageSearchQuery.key) {
            return __assign(__assign({}, state2), { loading: false, isInvalid: false, allMessages: messages, hasMoreResult: state2.currentMessageSearchQuery.hasNext });
          }
          return state2;
        });
      },
      setQueryInvalid: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { isInvalid: true });
        });
      },
      startMessageSearch: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { isInvalid: false, loading: false });
        });
      },
      startGettingSearchedMessages: function(query) {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { loading: true, currentMessageSearchQuery: query });
        });
      },
      getNextSearchedMessages: function(messages) {
        return store.setState(function(state2) {
          var _a;
          return __assign(__assign({}, state2), { allMessages: __spreadArray(__spreadArray([], state2.allMessages, true), messages, true), hasMoreResult: ((_a = state2.currentMessageSearchQuery) === null || _a === void 0 ? void 0 : _a.hasNext) || false });
        });
      },
      resetSearchString: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { allMessages: [] });
        });
      },
      setSelectedMessageId: function(messageId) {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { selectedMessageId: messageId });
        });
      },
      handleRetryToConnect: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { retryCount: state2.retryCount + 1 });
        });
      },
      // Looks exactly same as handleRetryToConnect but keep just for backward compatibility
      setRetryCount: function() {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { retryCount: state2.retryCount + 1 });
        });
      }
    };
  }, [store]);
  return { state, actions };
};

// node_modules/@sendbird/uikit-react/Thread/context/types.js
var ChannelStateTypes;
(function(ChannelStateTypes2) {
  ChannelStateTypes2["NIL"] = "NIL";
  ChannelStateTypes2["LOADING"] = "LOADING";
  ChannelStateTypes2["INVALID"] = "INVALID";
  ChannelStateTypes2["INITIALIZED"] = "INITIALIZED";
})(ChannelStateTypes || (ChannelStateTypes = {}));
var ParentMessageStateTypes;
(function(ParentMessageStateTypes2) {
  ParentMessageStateTypes2["NIL"] = "NIL";
  ParentMessageStateTypes2["LOADING"] = "LOADING";
  ParentMessageStateTypes2["INVALID"] = "INVALID";
  ParentMessageStateTypes2["INITIALIZED"] = "INITIALIZED";
})(ParentMessageStateTypes || (ParentMessageStateTypes = {}));
var ThreadListStateTypes;
(function(ThreadListStateTypes2) {
  ThreadListStateTypes2["NIL"] = "NIL";
  ThreadListStateTypes2["LOADING"] = "LOADING";
  ThreadListStateTypes2["INVALID"] = "INVALID";
  ThreadListStateTypes2["INITIALIZED"] = "INITIALIZED";
})(ThreadListStateTypes || (ThreadListStateTypes = {}));

// node_modules/@sendbird/uikit-react/chunks/bundle-DlwwNCtN.js
var import_react23 = __toESM(require_react(), 1);
var PREV_THREADS_FETCH_SIZE = 30;
var NEXT_THREADS_FETCH_SIZE = 30;
function useToggleReactionCallback(_a, _b) {
  var currentChannel = _a.currentChannel;
  var logger = _b.logger;
  return (0, import_react23.useCallback)(function(message, key, isReacted) {
    var _a2, _b2;
    if (isReacted) {
      (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.deleteReaction) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel, message, key).then(function(res) {
        logger.info("Thread | useToggleReactionsCallback: Delete reaction succeeded.", res);
      }).catch(function(err) {
        logger.warning("Thread | useToggleReactionsCallback: Delete reaction failed.", err);
      });
      return;
    }
    (_b2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.addReaction) === null || _b2 === void 0 ? void 0 : _b2.call(currentChannel, message, key).then(function(res) {
      logger.info("Thread | useToggleReactionsCallback: Add reaction succeeded.", res);
    }).catch(function(err) {
      logger.warning("Thread | useToggleReactionsCallback: Add reaction failed.", err);
    });
  }, [currentChannel]);
}
function useSendUserMessageCallback(_a, _b) {
  var isMentionEnabled = _a.isMentionEnabled, currentChannel = _a.currentChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage, sendMessageStart = _a.sendMessageStart, sendMessageFailure = _a.sendMessageFailure;
  var logger = _b.logger, pubSub = _b.pubSub;
  var sendMessage = (0, import_react23.useCallback)(function(props) {
    var _a2;
    var message = props.message, quoteMessage = props.quoteMessage, mentionTemplate = props.mentionTemplate, mentionedUsers = props.mentionedUsers;
    var createDefaultParams = function() {
      var params2 = {};
      params2.message = message;
      var mentionedUsersLength = (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) || 0;
      if (isMentionEnabled && mentionedUsersLength) {
        params2.mentionedUsers = mentionedUsers;
      }
      if (isMentionEnabled && mentionTemplate && mentionedUsersLength) {
        params2.mentionedMessageTemplate = mentionTemplate;
      }
      if (quoteMessage) {
        params2.isReplyToChannel = true;
        params2.parentMessageId = quoteMessage.messageId;
      }
      return params2;
    };
    var params = (_a2 = onBeforeSendUserMessage === null || onBeforeSendUserMessage === void 0 ? void 0 : onBeforeSendUserMessage(message, quoteMessage)) !== null && _a2 !== void 0 ? _a2 : createDefaultParams();
    logger.info("Thread | useSendUserMessageCallback: Sending user message start.", params);
    if (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage) {
      currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage(params).onPending(function(pendingMessage) {
        sendMessageStart(pendingMessage);
      }).onFailed(function(error, message2) {
        logger.info("Thread | useSendUserMessageCallback: Sending user message failed.", { message: message2, error });
        sendMessageFailure(message2);
      }).onSucceeded(function(message2) {
        logger.info("Thread | useSendUserMessageCallback: Sending user message succeeded.", message2);
        pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {
          channel: currentChannel,
          message: message2,
          publishingModules: [PublishingModuleType.THREAD]
        });
      });
    }
  }, [isMentionEnabled, currentChannel]);
  return sendMessage;
}
function useSendFileMessageCallback(_a, _b) {
  var currentChannel = _a.currentChannel, onBeforeSendFileMessage = _a.onBeforeSendFileMessage, sendMessageStart = _a.sendMessageStart, sendMessageFailure = _a.sendMessageFailure;
  var logger = _b.logger, pubSub = _b.pubSub;
  return (0, import_react23.useCallback)(function(file, quoteMessage) {
    return new Promise(function(resolve, reject) {
      var _a2;
      var createParamsDefault = function() {
        var params2 = {};
        params2.file = file;
        if (quoteMessage) {
          params2.isReplyToChannel = true;
          params2.parentMessageId = quoteMessage.messageId;
        }
        return params2;
      };
      var params = (_a2 = onBeforeSendFileMessage === null || onBeforeSendFileMessage === void 0 ? void 0 : onBeforeSendFileMessage(file, quoteMessage)) !== null && _a2 !== void 0 ? _a2 : createParamsDefault();
      logger.info("Thread | useSendFileMessageCallback: Sending file message start.", params);
      if (currentChannel == null) {
        logger.warning("Thread | useSendFileMessageCallback: currentChannel is null. Skipping file message send.");
        resolve(null);
      } else {
        currentChannel.sendFileMessage(params).onPending(function(pendingMessage) {
          sendMessageStart(__assign(__assign({}, pendingMessage), {
            url: URL.createObjectURL(file),
            // pending thumbnail message seems to be failed
            sendingStatus: Z.PENDING,
            isUserMessage: pendingMessage.isUserMessage,
            isFileMessage: pendingMessage.isFileMessage,
            isAdminMessage: pendingMessage.isAdminMessage,
            isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage
          }));
          setTimeout(function() {
            return scrollIntoLast();
          }, SCROLL_BOTTOM_DELAY_FOR_SEND);
        }).onFailed(function(error, message) {
          message.localUrl = URL.createObjectURL(file);
          message.file = file;
          logger.info("Thread | useSendFileMessageCallback: Sending file message failed.", { message, error });
          sendMessageFailure(message);
          reject(error);
        }).onSucceeded(function(message) {
          logger.info("Thread | useSendFileMessageCallback: Sending file message succeeded.", message);
          pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {
            channel: currentChannel,
            message,
            publishingModules: [PublishingModuleType.THREAD]
          });
          resolve(message);
        });
      }
    });
  }, [currentChannel]);
}
var useSendVoiceMessageCallback = function(_a, _b) {
  var currentChannel = _a.currentChannel, onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage, sendMessageStart = _a.sendMessageStart, sendMessageFailure = _a.sendMessageFailure;
  var logger = _b.logger, pubSub = _b.pubSub;
  var sendMessage = (0, import_react23.useCallback)(function(file, duration, quoteMessage) {
    var messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === "function" ? onBeforeSendVoiceMessage(file, quoteMessage) : {
      file,
      fileName: VOICE_MESSAGE_FILE_NAME,
      mimeType: VOICE_MESSAGE_MIME_TYPE,
      metaArrays: [
        new Ve({
          key: META_ARRAY_VOICE_DURATION_KEY,
          value: ["".concat(duration)]
        }),
        new Ve({
          key: META_ARRAY_MESSAGE_TYPE_KEY,
          value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]
        })
      ]
    };
    if (quoteMessage) {
      messageParams.isReplyToChannel = true;
      messageParams.parentMessageId = quoteMessage.messageId;
    }
    logger.info("Thread | useSendVoiceMessageCallback:  Start sending voice message", messageParams);
    currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(messageParams).onPending(function(pendingMessage) {
      sendMessageStart(__assign(__assign({}, pendingMessage), {
        url: URL.createObjectURL(file),
        // pending thumbnail message seems to be failed
        sendingStatus: Z.PENDING,
        isUserMessage: pendingMessage.isUserMessage,
        isFileMessage: pendingMessage.isFileMessage,
        isAdminMessage: pendingMessage.isAdminMessage,
        isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage
      }));
      setTimeout(function() {
        return scrollIntoLast();
      }, SCROLL_BOTTOM_DELAY_FOR_SEND);
    }).onFailed(function(error, message) {
      message.localUrl = URL.createObjectURL(file);
      message.file = file;
      logger.info("Thread | useSendVoiceMessageCallback: Sending voice message failed.", { message, error });
      sendMessageFailure(message);
    }).onSucceeded(function(message) {
      logger.info("Thread | useSendVoiceMessageCallback: Sending voice message succeeded.", message);
      pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {
        channel: currentChannel,
        message,
        publishingModules: [PublishingModuleType.THREAD]
      });
    });
  }, [
    currentChannel,
    onBeforeSendVoiceMessage
  ]);
  return sendMessage;
};
function useResendMessageCallback(_a, _b) {
  var currentChannel = _a.currentChannel, resendMessageStart = _a.resendMessageStart, sendMessageSuccess = _a.sendMessageSuccess, sendMessageFailure = _a.sendMessageFailure;
  var logger = _b.logger, pubSub = _b.pubSub;
  return (0, import_react23.useCallback)(function(failedMessage) {
    var _a2, _b2, _c, _d, _e;
    if (!(failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable)) {
      logger.warning("Thread | useResendMessageCallback: Message is not resendable.", failedMessage);
      return;
    }
    logger.info("Thread | useResendMessageCallback: Resending failedMessage start.", failedMessage);
    if (((_a2 = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isUserMessage) === null || _a2 === void 0 ? void 0 : _a2.call(failedMessage)) || (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.messageType) === G.USER) {
      try {
        currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage(failedMessage).onPending(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending user message started.", message);
          resendMessageStart(message);
        }).onSucceeded(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending user message succeeded.", message);
          sendMessageSuccess(message);
          pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {
            channel: currentChannel,
            message,
            publishingModules: [PublishingModuleType.THREAD]
          });
        }).onFailed(function(error) {
          logger.warning("Thread | useResendMessageCallback: Resending user message failed.", error);
          failedMessage.sendingStatus = Z.FAILED;
          sendMessageFailure(failedMessage);
        });
      } catch (err) {
        logger.warning("Thread | useResendMessageCallback: Resending user message failed.", err);
        failedMessage.sendingStatus = Z.FAILED;
        sendMessageFailure(failedMessage);
      }
    } else if ((_b2 = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isFileMessage) === null || _b2 === void 0 ? void 0 : _b2.call(failedMessage)) {
      try {
        (_c = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _c === void 0 ? void 0 : _c.call(currentChannel, failedMessage).onPending(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending file message started.", message);
          resendMessageStart(message);
        }).onSucceeded(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending file message succeeded.", message);
          sendMessageSuccess(message);
          pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {
            channel: currentChannel,
            message: failedMessage,
            publishingModules: [PublishingModuleType.THREAD]
          });
        }).onFailed(function(error) {
          logger.warning("Thread | useResendMessageCallback: Resending file message failed.", error);
          failedMessage.sendingStatus = Z.FAILED;
          sendMessageFailure(failedMessage);
        });
      } catch (err) {
        logger.warning("Thread | useResendMessageCallback: Resending file message failed.", err);
        failedMessage.sendingStatus = Z.FAILED;
        sendMessageFailure(failedMessage);
      }
    } else if ((_d = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isMultipleFilesMessage) === null || _d === void 0 ? void 0 : _d.call(failedMessage)) {
      try {
        (_e = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _e === void 0 ? void 0 : _e.call(currentChannel, failedMessage).onPending(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending multiple files message started.", message);
          resendMessageStart(message);
        }).onFileUploaded(function(requestId, index, uploadableFileInfo, error) {
          logger.info("Thread | useResendMessageCallback: onFileUploaded during resending multiple files message.", {
            requestId,
            index,
            error,
            uploadableFileInfo
          });
          pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {
            response: {
              channelUrl: currentChannel.url,
              requestId,
              index,
              uploadableFileInfo,
              error
            },
            publishingModules: [PublishingModuleType.THREAD]
          });
        }).onSucceeded(function(message) {
          logger.info("Thread | useResendMessageCallback: Resending MFM succeeded.", message);
          sendMessageSuccess(message);
          pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {
            channel: currentChannel,
            message,
            publishingModules: [PublishingModuleType.THREAD]
          });
        }).onFailed(function(error, message) {
          logger.warning("Thread | useResendMessageCallback: Resending MFM failed.", error);
          sendMessageFailure(message);
        });
      } catch (err) {
        logger.warning("Thread | useResendMessageCallback: Resending MFM failed.", err);
        sendMessageFailure(failedMessage);
      }
    } else {
      logger.warning("Thread | useResendMessageCallback: Message is not resendable.", failedMessage);
      failedMessage.sendingStatus = Z.FAILED;
      sendMessageFailure(failedMessage);
    }
  }, [currentChannel]);
}
function useUpdateMessageCallback(_a, _b) {
  var currentChannel = _a.currentChannel, isMentionEnabled = _a.isMentionEnabled, onMessageUpdated = _a.onMessageUpdated;
  var logger = _b.logger, pubSub = _b.pubSub;
  return (0, import_react23.useCallback)(function(props) {
    var _a2;
    var messageId = props.messageId, message = props.message, mentionedUsers = props.mentionedUsers, mentionTemplate = props.mentionTemplate;
    var createParamsDefault = function() {
      var params2 = {};
      params2.message = message;
      if (isMentionEnabled && mentionedUsers && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {
        params2.mentionedUsers = mentionedUsers;
      }
      if (isMentionEnabled && mentionTemplate) {
        params2.mentionedMessageTemplate = mentionTemplate;
      } else {
        params2.mentionedMessageTemplate = message;
      }
      return params2;
    };
    var params = createParamsDefault();
    logger.info("Thread | useUpdateMessageCallback: Message update start.", params);
    if (currentChannel == null) {
      logger.warning("Thread | useUpdateMessageCallback: currentChannel is null.");
      return;
    }
    (_a2 = currentChannel.updateUserMessage) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel, messageId, params).then(function(message2) {
      logger.info("Thread | useUpdateMessageCallback: Message update succeeded.", message2);
      onMessageUpdated(currentChannel, message2);
      pubSub.publish(pubSubTopics.UPDATE_USER_MESSAGE, {
        fromSelector: true,
        channel: currentChannel,
        message: message2,
        publishingModules: [PublishingModuleType.THREAD]
      });
    });
  }, [currentChannel, isMentionEnabled]);
}
function useDeleteMessageCallback(_a, _b) {
  var currentChannel = _a.currentChannel, onMessageDeletedByReqId = _a.onMessageDeletedByReqId, onMessageDeleted = _a.onMessageDeleted;
  var logger = _b.logger;
  return (0, import_react23.useCallback)(function(message) {
    logger.info("Thread | useDeleteMessageCallback: Deleting message.", message);
    var sendingStatus = message.sendingStatus;
    return new Promise(function(resolve, reject) {
      var _a2;
      logger.info("Thread | useDeleteMessageCallback: Deleting message requestState:", sendingStatus);
      if (sendingStatus === "failed" || sendingStatus === "pending") {
        logger.info("Thread | useDeleteMessageCallback: Deleted message from local:", message);
        onMessageDeletedByReqId(message.reqId);
        resolve();
      }
      if (currentChannel == null) {
        logger.info("Thread | useDeleteMessageCallback: No current channel");
        resolve();
      }
      logger.info("Thread | useDeleteMessageCallback: Deleting message from remote:", sendingStatus);
      (_a2 = currentChannel.deleteMessage) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel, message).then(function() {
        logger.info("Thread | useDeleteMessageCallback: Deleting message success!", message);
        onMessageDeleted(currentChannel, message.messageId);
        resolve();
      }).catch(function(err) {
        logger.warning("Thread | useDeleteMessageCallback: Deleting message failed!", err);
        reject(err);
      });
    });
  }, [currentChannel]);
}
function getThreadMessageListParams(params) {
  return __assign({ prevResultSize: PREV_THREADS_FETCH_SIZE, nextResultSize: NEXT_THREADS_FETCH_SIZE, includeMetaArray: true }, params);
}
var useThreadFetchers = function(_a) {
  var isReactionEnabled = _a.isReactionEnabled, anchorMessage = _a.anchorMessage, staleParentMessage = _a.parentMessage, logger = _a.logger, oldestMessageTimeStamp = _a.oldestMessageTimeStamp, latestMessageTimeStamp = _a.latestMessageTimeStamp, threadListState = _a.threadListState, initializeThreadListStart = _a.initializeThreadListStart, initializeThreadListSuccess = _a.initializeThreadListSuccess, initializeThreadListFailure = _a.initializeThreadListFailure, getPrevMessagesStart = _a.getPrevMessagesStart, getPrevMessagesSuccess = _a.getPrevMessagesSuccess, getPrevMessagesFailure = _a.getPrevMessagesFailure, getNextMessagesStart = _a.getNextMessagesStart, getNextMessagesSuccess = _a.getNextMessagesSuccess, getNextMessagesFailure = _a.getNextMessagesFailure;
  var stores = useSendbird().state.stores;
  var timestamp = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt) || 0;
  var initialize = (0, import_react23.useCallback)(function(callback) {
    return __awaiter(void 0, void 0, void 0, function() {
      var params, _a2, threadedMessages_1, parentMessage, error_1;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!stores.sdkStore.initialized || !staleParentMessage)
              return [
                2
                /*return*/
              ];
            initializeThreadListStart();
            _b.label = 1;
          case 1:
            _b.trys.push([1, 3, , 4]);
            params = getThreadMessageListParams({ includeReactions: isReactionEnabled });
            logger.info("Thread | useGetThreadList: Initialize thread list start.", { timestamp, params });
            return [4, staleParentMessage.getThreadedMessagesByTimestamp(timestamp, params)];
          case 2:
            _a2 = _b.sent(), threadedMessages_1 = _a2.threadedMessages, parentMessage = _a2.parentMessage;
            logger.info("Thread | useGetThreadList: Initialize thread list succeeded.", { staleParentMessage, threadedMessages: threadedMessages_1 });
            initializeThreadListSuccess(parentMessage, anchorMessage, threadedMessages_1);
            setTimeout(function() {
              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_1);
            });
            return [3, 4];
          case 3:
            error_1 = _b.sent();
            logger.info("Thread | useGetThreadList: Initialize thread list failed.", error_1);
            initializeThreadListFailure();
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [stores.sdkStore.initialized, staleParentMessage, anchorMessage, isReactionEnabled]);
  var loadPrevious = (0, import_react23.useCallback)(function(callback) {
    return __awaiter(void 0, void 0, void 0, function() {
      var params, _a2, threadedMessages_2, parentMessage, error_2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (threadListState !== ThreadListStateTypes.INITIALIZED || oldestMessageTimeStamp === 0 || !staleParentMessage)
              return [
                2
                /*return*/
              ];
            getPrevMessagesStart();
            _b.label = 1;
          case 1:
            _b.trys.push([1, 3, , 4]);
            params = getThreadMessageListParams({ nextResultSize: 0, includeReactions: isReactionEnabled });
            return [4, staleParentMessage.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params)];
          case 2:
            _a2 = _b.sent(), threadedMessages_2 = _a2.threadedMessages, parentMessage = _a2.parentMessage;
            logger.info("Thread | useGetPrevThreadsCallback: Fetch prev threads succeeded.", { parentMessage, threadedMessages: threadedMessages_2 });
            getPrevMessagesSuccess(threadedMessages_2);
            setTimeout(function() {
              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_2);
            });
            return [3, 4];
          case 3:
            error_2 = _b.sent();
            logger.info("Thread | useGetPrevThreadsCallback: Fetch prev threads failed.", error_2);
            getPrevMessagesFailure();
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [threadListState, oldestMessageTimeStamp, isReactionEnabled, staleParentMessage]);
  var loadNext = (0, import_react23.useCallback)(function(callback) {
    return __awaiter(void 0, void 0, void 0, function() {
      var params, _a2, threadedMessages_3, parentMessage, error_3;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (threadListState !== ThreadListStateTypes.INITIALIZED || latestMessageTimeStamp === 0 || !staleParentMessage)
              return [
                2
                /*return*/
              ];
            getNextMessagesStart();
            _b.label = 1;
          case 1:
            _b.trys.push([1, 3, , 4]);
            params = getThreadMessageListParams({ prevResultSize: 0, includeReactions: isReactionEnabled });
            return [4, staleParentMessage.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params)];
          case 2:
            _a2 = _b.sent(), threadedMessages_3 = _a2.threadedMessages, parentMessage = _a2.parentMessage;
            logger.info("Thread | useGetNextThreadsCallback: Fetch next threads succeeded.", { parentMessage, threadedMessages: threadedMessages_3 });
            getNextMessagesSuccess(threadedMessages_3);
            setTimeout(function() {
              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_3);
            });
            return [3, 4];
          case 3:
            error_3 = _b.sent();
            logger.info("Thread | useGetNextThreadsCallback: Fetch next threads failed.", error_3);
            getNextMessagesFailure();
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [threadListState, latestMessageTimeStamp, isReactionEnabled, staleParentMessage]);
  return {
    initializeThreadFetcher: initialize,
    fetchPrevThreads: loadPrevious,
    fetchNextThreads: loadNext
  };
};
function hasReqId(message) {
  return "reqId" in message;
}
var useThread = function() {
  var _a, _b;
  var store = (0, import_react23.useContext)(ThreadContext);
  if (!store)
    throw new Error("useThread must be used within a ThreadProvider");
  var _c = useSendbird().state, stores = _c.stores, config = _c.config;
  var logger = config.logger, pubSub = config.pubSub;
  var isMentionEnabled = config.groupChannel.enableMention;
  var isReactionEnabled = config.groupChannel.enableReactions;
  var state = shimExports.useSyncExternalStore(store.subscribe, store.getState);
  var message = state.message, parentMessage = state.parentMessage, currentChannel = state.currentChannel, threadListState = state.threadListState, allThreadMessages = state.allThreadMessages, onBeforeSendUserMessage = state.onBeforeSendUserMessage, onBeforeSendFileMessage = state.onBeforeSendFileMessage, onBeforeSendVoiceMessage = state.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = state.onBeforeSendMultipleFilesMessage;
  var sendMessageStatusActions = {
    sendMessageStart: function(message2) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { localThreadMessages: __spreadArray(__spreadArray([], state2.localThreadMessages, true), [
          message2
        ], false) });
      });
    },
    sendMessageSuccess: function(message2) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { allThreadMessages: __spreadArray(__spreadArray([], state2.allThreadMessages.filter(function(m) {
          return !compareIds2(m === null || m === void 0 ? void 0 : m.reqId, message2 === null || message2 === void 0 ? void 0 : message2.reqId);
        }), true), [
          message2
        ], false), localThreadMessages: state2.localThreadMessages.filter(function(m) {
          return !compareIds2(m === null || m === void 0 ? void 0 : m.reqId, message2 === null || message2 === void 0 ? void 0 : message2.reqId);
        }) });
      });
    },
    sendMessageFailure: function(message2) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { localThreadMessages: state2.localThreadMessages.map(function(m) {
          return compareIds2(m === null || m === void 0 ? void 0 : m.reqId, message2 === null || message2 === void 0 ? void 0 : message2.reqId) ? message2 : m;
        }) });
      });
    },
    resendMessageStart: function(message2) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { localThreadMessages: state2.localThreadMessages.map(function(m) {
          return compareIds2(m === null || m === void 0 ? void 0 : m.reqId, message2 === null || message2 === void 0 ? void 0 : message2.reqId) ? message2 : m;
        }) });
      });
    }
  };
  var toggleReaction = useToggleReactionCallback({ currentChannel }, { logger });
  var sendMessageActions = {
    sendMessage: useSendUserMessageCallback({
      isMentionEnabled,
      currentChannel,
      onBeforeSendUserMessage,
      sendMessageStart: sendMessageStatusActions.sendMessageStart,
      sendMessageFailure: sendMessageStatusActions.sendMessageFailure
    }, {
      logger,
      pubSub
    }),
    sendFileMessage: useSendFileMessageCallback({
      currentChannel,
      onBeforeSendFileMessage,
      sendMessageStart: sendMessageStatusActions.sendMessageStart,
      sendMessageFailure: sendMessageStatusActions.sendMessageFailure
    }, {
      logger,
      pubSub
    }),
    sendVoiceMessage: useSendVoiceMessageCallback({
      currentChannel,
      onBeforeSendVoiceMessage,
      sendMessageStart: sendMessageStatusActions.sendMessageStart,
      sendMessageFailure: sendMessageStatusActions.sendMessageFailure
    }, {
      logger,
      pubSub
    }),
    sendMultipleFilesMessage: useSendMultipleFilesMessage({
      currentChannel,
      onBeforeSendMultipleFilesMessage,
      publishingModules: [PublishingModuleType.THREAD]
    }, {
      logger,
      pubSub
    })[0],
    resendMessage: useResendMessageCallback({
      resendMessageStart: sendMessageStatusActions.resendMessageStart,
      sendMessageSuccess: sendMessageStatusActions.sendMessageSuccess,
      sendMessageFailure: sendMessageStatusActions.sendMessageFailure,
      currentChannel
    }, { logger, pubSub })
  };
  var messageModifiedActions = {
    onMessageUpdated: function(channel, message2) {
      return store.setState(function(state2) {
        var _a2, _b2, _c2;
        if (((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {
          return state2;
        }
        return __assign(__assign({}, state2), { parentMessage: ((_b2 = state2.parentMessage) === null || _b2 === void 0 ? void 0 : _b2.messageId) === (message2 === null || message2 === void 0 ? void 0 : message2.messageId) ? message2 : state2.parentMessage, allThreadMessages: (_c2 = state2.allThreadMessages) === null || _c2 === void 0 ? void 0 : _c2.map(function(msg) {
          return (msg === null || msg === void 0 ? void 0 : msg.messageId) === (message2 === null || message2 === void 0 ? void 0 : message2.messageId) ? message2 : msg;
        }) });
      });
    },
    onMessageDeleted: function(channel, messageId) {
      return store.setState(function(state2) {
        var _a2, _b2, _c2, _d2;
        if (((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {
          return state2;
        }
        if (((_b2 = state2 === null || state2 === void 0 ? void 0 : state2.parentMessage) === null || _b2 === void 0 ? void 0 : _b2.messageId) === messageId) {
          return __assign(__assign({}, state2), { parentMessage: null, parentMessageState: ParentMessageStateTypes.NIL, allThreadMessages: [] });
        }
        return __assign(__assign({}, state2), { allThreadMessages: (_c2 = state2.allThreadMessages) === null || _c2 === void 0 ? void 0 : _c2.filter(function(msg) {
          return (msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId;
        }), localThreadMessages: (_d2 = state2.localThreadMessages) === null || _d2 === void 0 ? void 0 : _d2.filter(function(msg) {
          return (msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId;
        }) });
      });
    },
    onMessageDeletedByReqId: function(reqId) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { localThreadMessages: state2.localThreadMessages.filter(function(m) {
          return !compareIds2(m.reqId, reqId);
        }) });
      });
    }
  };
  var modifyMessageActions = {
    updateMessage: useUpdateMessageCallback({
      currentChannel,
      isMentionEnabled,
      onMessageUpdated: messageModifiedActions.onMessageUpdated
    }, { logger, pubSub }),
    deleteMessage: useDeleteMessageCallback({
      currentChannel,
      onMessageDeleted: messageModifiedActions.onMessageDeleted,
      onMessageDeletedByReqId: messageModifiedActions.onMessageDeletedByReqId
    }, { logger })
  };
  var threadFetcherStatusActions = {
    initializeThreadListStart: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { threadListState: ThreadListStateTypes.LOADING, allThreadMessages: [] });
      });
    },
    initializeThreadListSuccess: function(parentMessage2, anchorMessage, threadedMessages) {
      return store.setState(function(state2) {
        var anchorMessageCreatedAt = !(anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId) ? parentMessage2 === null || parentMessage2 === void 0 ? void 0 : parentMessage2.createdAt : anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt;
        var anchorIndex = threadedMessages.findIndex(function(message2) {
          return (message2 === null || message2 === void 0 ? void 0 : message2.createdAt) > anchorMessageCreatedAt;
        });
        var prevThreadMessages = anchorIndex > -1 ? threadedMessages.slice(0, anchorIndex) : threadedMessages;
        var anchorThreadMessage = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId) ? [anchorMessage] : [];
        var nextThreadMessages = anchorIndex > -1 ? threadedMessages.slice(anchorIndex) : [];
        return __assign(__assign({}, state2), { threadListState: ThreadListStateTypes.INITIALIZED, hasMorePrev: anchorIndex === -1 || anchorIndex === PREV_THREADS_FETCH_SIZE, hasMoreNext: threadedMessages.length - anchorIndex === NEXT_THREADS_FETCH_SIZE, allThreadMessages: [prevThreadMessages, anchorThreadMessage, nextThreadMessages].flat() });
      });
    },
    initializeThreadListFailure: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { threadListState: ThreadListStateTypes.LOADING, allThreadMessages: [] });
      });
    },
    getPrevMessagesStart: function() {
      return store.setState(function(state2) {
        return __assign({}, state2);
      });
    },
    getPrevMessagesSuccess: function(threadedMessages) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { hasMorePrev: threadedMessages.length === PREV_THREADS_FETCH_SIZE, allThreadMessages: __spreadArray(__spreadArray([], threadedMessages, true), state2.allThreadMessages, true) });
      });
    },
    getPrevMessagesFailure: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { hasMorePrev: false });
      });
    },
    getNextMessagesStart: function() {
      return store.setState(function(state2) {
        return __assign({}, state2);
      });
    },
    getNextMessagesSuccess: function(threadedMessages) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { hasMoreNext: threadedMessages.length === NEXT_THREADS_FETCH_SIZE, allThreadMessages: __spreadArray(__spreadArray([], state2.allThreadMessages, true), threadedMessages, true) });
      });
    },
    getNextMessagesFailure: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { hasMoreNext: false });
      });
    }
  };
  var _d = useThreadFetchers({
    parentMessage,
    // anchorMessage should be null when parentMessage doesn't exist
    anchorMessage: (message === null || message === void 0 ? void 0 : message.messageId) !== (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) ? message || void 0 : void 0,
    logger,
    isReactionEnabled,
    threadListState,
    oldestMessageTimeStamp: ((_a = allThreadMessages[0]) === null || _a === void 0 ? void 0 : _a.createdAt) || 0,
    latestMessageTimeStamp: ((_b = allThreadMessages[allThreadMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.createdAt) || 0,
    initializeThreadListStart: threadFetcherStatusActions.initializeThreadListStart,
    initializeThreadListSuccess: threadFetcherStatusActions.initializeThreadListSuccess,
    initializeThreadListFailure: threadFetcherStatusActions.initializeThreadListFailure,
    getPrevMessagesStart: threadFetcherStatusActions.getPrevMessagesStart,
    getPrevMessagesSuccess: threadFetcherStatusActions.getPrevMessagesSuccess,
    getPrevMessagesFailure: threadFetcherStatusActions.getPrevMessagesFailure,
    getNextMessagesStart: threadFetcherStatusActions.getNextMessagesStart,
    getNextMessagesSuccess: threadFetcherStatusActions.getNextMessagesSuccess,
    getNextMessagesFailure: threadFetcherStatusActions.getNextMessagesFailure
  }), initializeThreadFetcher = _d.initializeThreadFetcher, fetchPrevThreads = _d.fetchPrevThreads, fetchNextThreads = _d.fetchNextThreads;
  var actions = (0, import_react23.useMemo)(function() {
    return __assign(__assign(__assign(__assign(__assign(__assign({ setCurrentUserId: function(currentUserId) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { currentUserId });
      });
    }, getChannelStart: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { channelState: ChannelStateTypes.LOADING, currentChannel: null });
      });
    }, getChannelSuccess: function(groupChannel) {
      return store.setState(function(state2) {
        var _a2, _b2;
        return __assign(__assign({}, state2), {
          channelState: ChannelStateTypes.INITIALIZED,
          currentChannel: groupChannel,
          // only support in normal group channel
          isMuted: ((_b2 = (_a2 = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.members) === null || _a2 === void 0 ? void 0 : _a2.find(function(member) {
            return (member === null || member === void 0 ? void 0 : member.userId) === state2.currentUserId;
          })) === null || _b2 === void 0 ? void 0 : _b2.isMuted) || false,
          isChannelFrozen: (groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen) || false
        });
      });
    }, getChannelFailure: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { channelState: ChannelStateTypes.INVALID, currentChannel: null });
      });
    }, getParentMessageStart: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { parentMessageState: ParentMessageStateTypes.LOADING, parentMessage: null });
      });
    }, getParentMessageSuccess: function(parentMessage2) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { parentMessageState: ParentMessageStateTypes.INITIALIZED, parentMessage: parentMessage2 });
      });
    }, getParentMessageFailure: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { parentMessageState: ParentMessageStateTypes.INVALID, parentMessage: null });
      });
    }, setEmojiContainer: function(emojiContainer) {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { emojiContainer });
      });
    }, onMessageReceived: function(channel, message2) {
      return store.setState(function(state2) {
        var _a2, _b2, _c2, _d2;
        if (((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state2.hasMoreNext || ((_b2 = message2 === null || message2 === void 0 ? void 0 : message2.parentMessage) === null || _b2 === void 0 ? void 0 : _b2.messageId) !== ((_c2 = state2 === null || state2 === void 0 ? void 0 : state2.parentMessage) === null || _c2 === void 0 ? void 0 : _c2.messageId)) {
          return state2;
        }
        var isAlreadyReceived = state2.allThreadMessages.findIndex(function(m) {
          return m.messageId === message2.messageId;
        }) > -1;
        return __assign(__assign({}, state2), { parentMessage: ((_d2 = state2.parentMessage) === null || _d2 === void 0 ? void 0 : _d2.messageId) === (message2 === null || message2 === void 0 ? void 0 : message2.messageId) ? message2 : state2.parentMessage, allThreadMessages: isAlreadyReceived ? state2.allThreadMessages.map(function(m) {
          return m.messageId === message2.messageId ? message2 : m;
        }) : __spreadArray(__spreadArray([], state2.allThreadMessages.filter(function(m) {
          return (m === null || m === void 0 ? void 0 : m.reqId) !== (message2 === null || message2 === void 0 ? void 0 : message2.reqId);
        }), true), [
          message2
        ], false) });
      });
    }, onReactionUpdated: function(reactionEvent) {
      return store.setState(function(state2) {
        var _a2, _b2, _c2;
        if (((_a2 = state2 === null || state2 === void 0 ? void 0 : state2.parentMessage) === null || _a2 === void 0 ? void 0 : _a2.messageId) === (reactionEvent === null || reactionEvent === void 0 ? void 0 : reactionEvent.messageId)) {
          (_c2 = (_b2 = state2.parentMessage) === null || _b2 === void 0 ? void 0 : _b2.applyReactionEvent) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, reactionEvent);
        }
        return __assign(__assign({}, state2), { allThreadMessages: state2.allThreadMessages.map(function(m) {
          var _a3;
          if ((reactionEvent === null || reactionEvent === void 0 ? void 0 : reactionEvent.messageId) === (m === null || m === void 0 ? void 0 : m.messageId)) {
            (_a3 = m === null || m === void 0 ? void 0 : m.applyReactionEvent) === null || _a3 === void 0 ? void 0 : _a3.call(m, reactionEvent);
            return m;
          }
          return m;
        }) });
      });
    }, onUserMuted: function(channel, user) {
      return store.setState(function(state2) {
        var _a2;
        if (((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state2.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {
          return state2;
        }
        return __assign(__assign({}, state2), { isMuted: true });
      });
    }, onUserUnmuted: function(channel, user) {
      return store.setState(function(state2) {
        var _a2;
        if (((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state2.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {
          return state2;
        }
        return __assign(__assign({}, state2), { isMuted: false });
      });
    }, onUserBanned: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { channelState: ChannelStateTypes.NIL, threadListState: ThreadListStateTypes.NIL, parentMessageState: ParentMessageStateTypes.NIL, currentChannel: null, parentMessage: null, allThreadMessages: [], hasMorePrev: false, hasMoreNext: false });
      });
    }, onUserUnbanned: function() {
      return store.setState(function(state2) {
        return __assign({}, state2);
      });
    }, onUserLeft: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { channelState: ChannelStateTypes.NIL, threadListState: ThreadListStateTypes.NIL, parentMessageState: ParentMessageStateTypes.NIL, currentChannel: null, parentMessage: null, allThreadMessages: [], hasMorePrev: false, hasMoreNext: false });
      });
    }, onChannelFrozen: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { isChannelFrozen: true });
      });
    }, onChannelUnfrozen: function() {
      return store.setState(function(state2) {
        return __assign(__assign({}, state2), { isChannelFrozen: false });
      });
    }, onOperatorUpdated: function(channel) {
      return store.setState(function(state2) {
        var _a2;
        if ((channel === null || channel === void 0 ? void 0 : channel.url) === ((_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url)) {
          return __assign(__assign({}, state2), { currentChannel: channel });
        }
        return state2;
      });
    }, onTypingStatusUpdated: function(channel, typingMembers) {
      return store.setState(function(state2) {
        var _a2;
        if (!compareIds2(channel.url, (_a2 = state2.currentChannel) === null || _a2 === void 0 ? void 0 : _a2.url)) {
          return state2;
        }
        return __assign(__assign({}, state2), { typingMembers });
      });
    }, onFileInfoUpdated: function(_a2) {
      var channelUrl = _a2.channelUrl, requestId = _a2.requestId, index = _a2.index, uploadableFileInfo = _a2.uploadableFileInfo, error = _a2.error;
      return store.setState(function(state2) {
        var _a3, _b2;
        if (!compareIds2(channelUrl, (_a3 = state2.currentChannel) === null || _a3 === void 0 ? void 0 : _a3.url)) {
          return state2;
        }
        if (error)
          return state2;
        var localThreadMessages = state2.localThreadMessages;
        var messageToUpdate = localThreadMessages.find(function(message2) {
          return compareIds2(hasReqId(message2) && message2.reqId, requestId);
        });
        var fileInfoList = (_b2 = messageToUpdate.messageParams) === null || _b2 === void 0 ? void 0 : _b2.fileInfoList;
        if (Array.isArray(fileInfoList)) {
          fileInfoList[index] = uploadableFileInfo;
        }
        return __assign(__assign({}, state2), { localThreadMessages });
      });
    }, toggleReaction }, sendMessageStatusActions), sendMessageActions), messageModifiedActions), modifyMessageActions), threadFetcherStatusActions), { initializeThreadFetcher, fetchPrevThreads, fetchNextThreads });
  }, [
    store,
    currentChannel,
    stores.sdkStore.initialized,
    parentMessage
  ]);
  return { state, actions };
};
function useGetChannel(_a, _b) {
  var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, message = _a.message;
  var sdk = _b.sdk, logger = _b.logger;
  var _c = useThread().actions, getChannelStart = _c.getChannelStart, getChannelSuccess = _c.getChannelSuccess, getChannelFailure = _c.getChannelFailure;
  (0, import_react23.useEffect)(function() {
    var _a2, _b2;
    if (sdkInit && channelUrl && (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel)) {
      logger.info("Thread | useInitialize: Get channel started");
      getChannelStart();
      (_b2 = (_a2 = sdk.groupChannel).getChannel) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, channelUrl).then(function(groupChannel) {
        logger.info("Thread | useInitialize: Get channel succeeded", groupChannel);
        getChannelSuccess(groupChannel);
      }).catch(function(error) {
        logger.info("Thread | useInitialize: Get channel failed", error);
        getChannelFailure();
      });
    }
  }, [message, sdkInit]);
}
function useGetAllEmoji(_a, _b) {
  var sdk = _a.sdk;
  var logger = _b.logger;
  var setEmojiContainer = useThread().actions.setEmojiContainer;
  (0, import_react23.useEffect)(function() {
    if (sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji) {
      sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji().then(function(emojiContainer) {
        logger.info("Thread | useGetAllEmoji: Getting emojis succeeded.", emojiContainer);
        setEmojiContainer(emojiContainer);
      }).catch(function(error) {
        logger.info("Thread | useGetAllEmoji: Getting emojis failed.", error);
      });
    }
  }, [sdk]);
}
function useGetParentMessage(_a, _b) {
  var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, parentMessage = _a.parentMessage;
  var sdk = _b.sdk, logger = _b.logger;
  var _c = useThread().actions, getParentMessageStart = _c.getParentMessageStart, getParentMessageSuccess = _c.getParentMessageSuccess, getParentMessageFailure = _c.getParentMessageFailure;
  (0, import_react23.useEffect)(function() {
    var _a2, _b2, _c2;
    if (sdkInit && ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.message) === null || _a2 === void 0 ? void 0 : _a2.getMessage) && parentMessage) {
      getParentMessageStart();
      var params = {
        channelUrl,
        channelType: H.GROUP,
        messageId: parentMessage.messageId,
        includeMetaArray: true,
        includeReactions: true,
        includeThreadInfo: true,
        includeParentMessageInfo: true
      };
      logger.info("Thread | useGetParentMessage: Get parent message start.", params);
      (_c2 = (_b2 = sdk.message).getMessage) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, params).then(function(parentMsg) {
        logger.info("Thread | useGetParentMessage: Get parent message succeeded.", parentMessage);
        parentMsg.ogMetaData = (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.ogMetaData) || null;
        getParentMessageSuccess(parentMsg);
      }).catch(function(error) {
        logger.info("Thread | useGetParentMessage: Get parent message failed.", error);
        getParentMessageFailure();
      });
    }
  }, [sdkInit, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);
}
function useHandleThreadPubsubEvents(_a, _b) {
  var sdkInit = _a.sdkInit, currentChannel = _a.currentChannel, parentMessage = _a.parentMessage;
  var pubSub = _b.pubSub;
  var _c = useThread().actions, sendMessageStart = _c.sendMessageStart, sendMessageSuccess = _c.sendMessageSuccess, sendMessageFailure = _c.sendMessageFailure, onFileInfoUpdated = _c.onFileInfoUpdated, onMessageUpdated = _c.onMessageUpdated, onMessageDeleted = _c.onMessageDeleted;
  (0, import_react23.useEffect)(function() {
    var subscriber = /* @__PURE__ */ new Map();
    if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {
      subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function(props) {
        var _a2, _b2;
        var channel = props.channel, message = props.message, publishingModules = props.publishingModules;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {
          var pendingMessage = __assign({}, message);
          if (message.isMultipleFilesMessage()) {
            pendingMessage.fileInfoList = (_b2 = (_a2 = message === null || message === void 0 ? void 0 : message.messageParams) === null || _a2 === void 0 ? void 0 : _a2.fileInfoList.map(function(fileInfo) {
              return __assign(__assign({}, fileInfo), { url: URL.createObjectURL(fileInfo.file) });
            })) !== null && _b2 !== void 0 ? _b2 : [];
          }
          sendMessageStart(message);
        }
        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();
      }));
      subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function(props) {
        var response = props.response, publishingModules = props.publishingModules;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === response.channelUrl && shouldPubSubPublishToThread(publishingModules)) {
          onFileInfoUpdated(response);
        }
      }));
      subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function(props) {
        var _a2 = props, channel = _a2.channel, message = _a2.message;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId)) {
          sendMessageSuccess(message);
        }
        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();
      }));
      subscriber.set(pubSubTopics.SEND_MESSAGE_FAILED, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_FAILED, function(props) {
        var channel = props.channel, message = props.message, publishingModules = props.publishingModules;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {
          sendMessageFailure(message);
        }
      }));
      subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function(props) {
        var channel = props.channel, message = props.message, publishingModules = props.publishingModules;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToThread(publishingModules)) {
          sendMessageSuccess(message);
        }
        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();
      }));
      subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function(props) {
        var _a2 = props, channel = _a2.channel, message = _a2.message;
        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {
          onMessageUpdated(channel, message);
        }
      }));
      subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function(props) {
        var _a2 = props, channel = _a2.channel, messageId = _a2.messageId;
        onMessageDeleted(channel, messageId);
      }));
    }
    return function() {
      subscriber === null || subscriber === void 0 ? void 0 : subscriber.forEach(function(s) {
        try {
          s === null || s === void 0 ? void 0 : s.remove();
        } catch (_a2) {
        }
      });
    };
  }, [sdkInit, currentChannel, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);
}
function useHandleChannelEvents(_a, _b) {
  var sdk = _a.sdk, currentChannel = _a.currentChannel;
  var logger = _b.logger;
  var _c = useThread().actions, onMessageReceived = _c.onMessageReceived, onMessageUpdated = _c.onMessageUpdated, onMessageDeleted = _c.onMessageDeleted, onReactionUpdated = _c.onReactionUpdated, onUserMuted = _c.onUserMuted, onUserUnmuted = _c.onUserUnmuted, onUserBanned = _c.onUserBanned, onUserUnbanned = _c.onUserUnbanned, onUserLeft = _c.onUserLeft, onChannelFrozen = _c.onChannelFrozen, onChannelUnfrozen = _c.onChannelUnfrozen, onOperatorUpdated = _c.onOperatorUpdated, onTypingStatusUpdated = _c.onTypingStatusUpdated;
  (0, import_react23.useEffect)(function() {
    var _a2, _b2, _c2;
    var handlerId = uuidv4();
    if (((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.addGroupChannelHandler) && currentChannel) {
      var channelHandlerParams = {
        // message status change
        onMessageReceived: function(channel, message) {
          logger.info("Thread | useHandleChannelEvents: onMessageReceived", { channel, message });
          onMessageReceived(channel, message);
        },
        onMessageUpdated: function(channel, message) {
          logger.info("Thread | useHandleChannelEvents: onMessageUpdated", { channel, message });
          onMessageUpdated(channel, message);
        },
        onMessageDeleted: function(channel, messageId) {
          logger.info("Thread | useHandleChannelEvents: onMessageDeleted", { channel, messageId });
          onMessageDeleted(channel, messageId);
        },
        onReactionUpdated: function(channel, reactionEvent) {
          logger.info("Thread | useHandleChannelEvents: onReactionUpdated", { channel, reactionEvent });
          onReactionUpdated(reactionEvent);
        },
        // user status change
        onUserMuted: function(channel, user) {
          logger.info("Thread | useHandleChannelEvents: onUserMuted", { channel, user });
          onUserMuted(channel, user);
        },
        onUserUnmuted: function(channel, user) {
          logger.info("Thread | useHandleChannelEvents: onUserUnmuted", { channel, user });
          onUserUnmuted(channel, user);
        },
        onUserBanned: function(channel, user) {
          logger.info("Thread | useHandleChannelEvents: onUserBanned", { channel, user });
          onUserBanned();
        },
        onUserUnbanned: function(channel, user) {
          logger.info("Thread | useHandleChannelEvents: onUserUnbanned", { channel, user });
          onUserUnbanned();
        },
        onUserLeft: function(channel, user) {
          logger.info("Thread | useHandleChannelEvents: onUserLeft", { channel, user });
          onUserLeft();
        },
        // channel status change
        onChannelFrozen: function(channel) {
          logger.info("Thread | useHandleChannelEvents: onChannelFrozen", { channel });
          onChannelFrozen();
        },
        onChannelUnfrozen: function(channel) {
          logger.info("Thread | useHandleChannelEvents: onChannelUnfrozen", { channel });
          onChannelUnfrozen();
        },
        onOperatorUpdated: function(channel, users) {
          logger.info("Thread | useHandleChannelEvents: onOperatorUpdated", { channel, users });
          onOperatorUpdated(channel);
        },
        onTypingStatusUpdated: function(channel) {
          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentChannel.url)) {
            logger.info("Channel | onTypingStatusUpdated", { channel });
            var typingMembers = channel.getTypingUsers();
            onTypingStatusUpdated(channel, typingMembers);
          }
        }
      };
      var channelHandler = new Ye(channelHandlerParams);
      (_c2 = (_b2 = sdk.groupChannel).addGroupChannelHandler) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, handlerId, channelHandler);
      logger.info("Thread | useHandleChannelEvents: Added channelHandler in Thread", { handlerId, channelHandler });
    }
    return function() {
      var _a3, _b3, _c3;
      if (handlerId && ((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler)) {
        (_c3 = (_b3 = sdk.groupChannel).removeGroupChannelHandler) === null || _c3 === void 0 ? void 0 : _c3.call(_b3, handlerId);
        logger.info("Thread | useHandleChannelEvents: Removed channelHandler in Thread.", handlerId);
      }
    };
  }, [
    sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel,
    currentChannel
  ]);
}
function useSetCurrentUserId(_a) {
  var user = _a.user;
  var setCurrentUserId = useThread().actions.setCurrentUserId;
  (0, import_react23.useEffect)(function() {
    setCurrentUserId(user === null || user === void 0 ? void 0 : user.userId);
  }, [user === null || user === void 0 ? void 0 : user.userId]);
}
var initialState5 = {
  channelUrl: "",
  message: null,
  onHeaderActionClick: void 0,
  onMoveToParentMessage: void 0,
  onBeforeSendUserMessage: void 0,
  onBeforeSendFileMessage: void 0,
  onBeforeSendVoiceMessage: void 0,
  onBeforeSendMultipleFilesMessage: void 0,
  onBeforeDownloadFileMessage: void 0,
  isMultipleFilesMessageEnabled: void 0,
  filterEmojiCategoryIds: void 0,
  currentChannel: null,
  allThreadMessages: [],
  localThreadMessages: [],
  parentMessage: null,
  channelState: ChannelStateTypes.NIL,
  parentMessageState: ParentMessageStateTypes.NIL,
  threadListState: ThreadListStateTypes.NIL,
  hasMorePrev: false,
  hasMoreNext: false,
  emojiContainer: {},
  isMuted: false,
  isChannelFrozen: false,
  currentUserId: "",
  typingMembers: [],
  nicknamesMap: null
};
var ThreadContext = import_react23.default.createContext(null);
var createThreadStore = function(props) {
  return createStore(__assign(__assign({}, initialState5), props));
};
var InternalThreadProvider = function(props) {
  var children = props.children;
  var defaultProps = {
    channelUrl: props === null || props === void 0 ? void 0 : props.channelUrl,
    message: props === null || props === void 0 ? void 0 : props.message,
    onHeaderActionClick: props === null || props === void 0 ? void 0 : props.onHeaderActionClick,
    onMoveToParentMessage: props === null || props === void 0 ? void 0 : props.onMoveToParentMessage,
    onBeforeSendUserMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendUserMessage,
    onBeforeSendFileMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendFileMessage,
    onBeforeSendVoiceMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendVoiceMessage,
    onBeforeSendMultipleFilesMessage: props === null || props === void 0 ? void 0 : props.onBeforeSendMultipleFilesMessage,
    onBeforeDownloadFileMessage: props === null || props === void 0 ? void 0 : props.onBeforeDownloadFileMessage,
    isMultipleFilesMessageEnabled: props === null || props === void 0 ? void 0 : props.isMultipleFilesMessageEnabled,
    filterEmojiCategoryIds: props === null || props === void 0 ? void 0 : props.filterEmojiCategoryIds
  };
  var storeRef = (0, import_react23.useRef)(createThreadStore(defaultProps));
  return import_react23.default.createElement(ThreadContext.Provider, { value: storeRef.current }, children);
};
var ThreadManager = function(props) {
  var message = props.message, channelUrl = props.channelUrl, onHeaderActionClick = props.onHeaderActionClick, onMoveToParentMessage = props.onMoveToParentMessage, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, filterEmojiCategoryIds = props.filterEmojiCategoryIds;
  var _a = useThread(), _b = _a.state, currentChannel = _b.currentChannel, parentMessage = _b.parentMessage, initializeThreadFetcher = _a.actions.initializeThreadFetcher;
  var updateState = useThreadStore().updateState;
  var propsParentMessage = getParentMessageFrom(message);
  var _c = useSendbird().state, stores = _c.stores, config = _c.config;
  var sdkStore = stores.sdkStore, userStore = stores.userStore;
  var sdk = sdkStore.sdk;
  var user = userStore.user;
  var sdkInit = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;
  var logger = config.logger, pubSub = config.pubSub;
  useSetCurrentUserId({ user });
  useGetChannel({
    channelUrl,
    sdkInit,
    message
  }, { sdk, logger });
  useGetParentMessage({
    channelUrl,
    sdkInit,
    parentMessage: propsParentMessage
  }, { sdk, logger });
  useGetAllEmoji({ sdk }, { logger });
  useHandleChannelEvents({
    sdk,
    currentChannel
  }, { logger });
  useHandleThreadPubsubEvents({
    sdkInit,
    currentChannel,
    parentMessage
  }, { logger, pubSub });
  (0, import_react23.useEffect)(function() {
    if (stores.sdkStore.initialized && config.isOnline) {
      initializeThreadFetcher();
    }
  }, [stores.sdkStore.initialized, config.isOnline, initializeThreadFetcher]);
  var nicknamesMap = (0, import_react23.useMemo)(function() {
    return config.groupChannel.replyType !== "none" && currentChannel ? getNicknamesMapFromMembers(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) : /* @__PURE__ */ new Map();
  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);
  useDeepCompareEffect(function() {
    updateState({
      channelUrl,
      message,
      onHeaderActionClick,
      onMoveToParentMessage,
      onBeforeSendUserMessage,
      onBeforeSendFileMessage,
      onBeforeSendVoiceMessage,
      onBeforeSendMultipleFilesMessage,
      onBeforeDownloadFileMessage,
      isMultipleFilesMessageEnabled,
      filterEmojiCategoryIds,
      nicknamesMap
    });
  }, [
    channelUrl,
    message,
    onHeaderActionClick,
    onMoveToParentMessage,
    onBeforeSendUserMessage,
    onBeforeSendFileMessage,
    onBeforeSendVoiceMessage,
    onBeforeSendMultipleFilesMessage,
    onBeforeDownloadFileMessage,
    isMultipleFilesMessageEnabled,
    filterEmojiCategoryIds,
    nicknamesMap
  ]);
  return null;
};
var ThreadProvider = function(props) {
  var children = props.children;
  return import_react23.default.createElement(
    InternalThreadProvider,
    __assign({}, props),
    import_react23.default.createElement(ThreadManager, __assign({}, props)),
    import_react23.default.createElement(UserProfileProvider, __assign({}, props), children)
  );
};
var useThreadStore = function() {
  return useStore(ThreadContext, function(state) {
    return state;
  }, initialState5);
};

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/toDate/index.js
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/esm/_lib/defaultOptions/index.js
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/esm/startOfDay/index.js
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/constants/index.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/esm/isSameDay/index.js
function isSameDay2(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeek/index.js
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeekYear/index.js
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCISOWeekYear/index.js
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCISOWeek/index.js
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

// node_modules/date-fns/esm/_lib/startOfUTCWeek/index.js
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeekYear/index.js
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/esm/_lib/startOfUTCWeekYear/index.js
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

// node_modules/date-fns/esm/_lib/getUTCWeek/index.js
var MILLISECONDS_IN_WEEK2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK2) + 1;
}

// node_modules/date-fns/esm/locale/_lib/buildFormatLongFn/index.js
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format3 = args.formats[width] || args.formats[args.defaultWidth];
    return format3;
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/formatLong/index.js
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/esm/locale/_lib/buildLocalizeFn/index.js
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/localize/index.js
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/esm/locale/_lib/buildMatchFn/index.js
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/esm/locale/_lib/buildMatchPatternFn/index.js
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}

// node_modules/date-fns/esm/locale/en-US/_lib/match/index.js
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/esm/formatDistanceStrict/index.js
var MILLISECONDS_IN_MINUTE = 1e3 * 60;
var MINUTES_IN_DAY = 60 * 24;
var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

// node_modules/date-fns/esm/getOverlappingDaysInIntervals/index.js
var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1e3;

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == _typeof(e) || "function" == typeof e))
    return e;
  if (void 0 !== e)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/createSuper.js
function _createSuper(t) {
  var r = _isNativeReflectConstruct();
  return function() {
    var e, o = _getPrototypeOf(t);
    if (r) {
      var s = _getPrototypeOf(this).constructor;
      e = Reflect.construct(o, arguments, s);
    } else
      e = o.apply(this, arguments);
    return _possibleConstructorReturn(this, e);
  };
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n) {
  if (!(a instanceof n))
    throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

// node_modules/date-fns/esm/parse/_lib/Setter.js
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = function(_Setter2) {
  _inherits(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);

// node_modules/date-fns/esm/parse/_lib/Parser.js
var Parser = function() {
  function Parser2() {
    _classCallCheck(this, Parser2);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser2, [{
    key: "run",
    value: function run(dateString, token, match2, options) {
      var result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();

// node_modules/date-fns/esm/parse/_lib/parsers/EraParser.js
var EraParser = function(_Parser) {
  _inherits(EraParser2, _Parser);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/constants.js
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/esm/parse/_lib/utils.js
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/esm/parse/_lib/parsers/YearParser.js
var YearParser = function(_Parser) {
  _inherits(YearParser2, _Parser);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekYearParser.js
var LocalWeekYearParser = function(_Parser) {
  _inherits(LocalWeekYearParser2, _Parser);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekYearParser.js
var ISOWeekYearParser = function(_Parser) {
  _inherits(ISOWeekYearParser2, _Parser);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ExtendedYearParser.js
var ExtendedYearParser = function(_Parser) {
  _inherits(ExtendedYearParser2, _Parser);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/QuarterParser.js
var QuarterParser = function(_Parser) {
  _inherits(QuarterParser2, _Parser);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneQuarterParser.js
var StandAloneQuarterParser = function(_Parser) {
  _inherits(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/MonthParser.js
var MonthParser = function(_Parser) {
  _inherits(MonthParser2, _Parser);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneMonthParser.js
var StandAloneMonthParser = function(_Parser) {
  _inherits(StandAloneMonthParser2, _Parser);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCWeek/index.js
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/LocalWeekParser.js
var LocalWeekParser = function(_Parser) {
  _inherits(LocalWeekParser2, _Parser);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCISOWeek/index.js
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISOWeekParser.js
var ISOWeekParser = function(_Parser) {
  _inherits(ISOWeekParser2, _Parser);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DateParser.js
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = function(_Parser) {
  _inherits(DateParser2, _Parser);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear2) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DayOfYearParser.js
var DayOfYearParser = function(_Parser) {
  _inherits(DayOfYearParser2, _Parser);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear2 = isLeapYearIndex(year);
      if (isLeapYear2) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCDay/index.js
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/DayParser.js
var DayParser = function(_Parser) {
  _inherits(DayParser2, _Parser);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/LocalDayParser.js
var LocalDayParser = function(_Parser) {
  _inherits(LocalDayParser2, _Parser);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/StandAloneLocalDayParser.js
var StandAloneLocalDayParser = function(_Parser) {
  _inherits(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);

// node_modules/date-fns/esm/_lib/setUTCISODay/index.js
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// node_modules/date-fns/esm/parse/_lib/parsers/ISODayParser.js
var ISODayParser = function(_Parser) {
  _inherits(ISODayParser2, _Parser);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMParser.js
var AMPMParser = function(_Parser) {
  _inherits(AMPMParser2, _Parser);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/AMPMMidnightParser.js
var AMPMMidnightParser = function(_Parser) {
  _inherits(AMPMMidnightParser2, _Parser);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/DayPeriodParser.js
var DayPeriodParser = function(_Parser) {
  _inherits(DayPeriodParser2, _Parser);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1to12Parser.js
var Hour1to12Parser = function(_Parser) {
  _inherits(Hour1to12Parser2, _Parser);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0to23Parser.js
var Hour0to23Parser = function(_Parser) {
  _inherits(Hour0to23Parser2, _Parser);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour0To11Parser.js
var Hour0To11Parser = function(_Parser) {
  _inherits(Hour0To11Parser2, _Parser);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/Hour1To24Parser.js
var Hour1To24Parser = function(_Parser) {
  _inherits(Hour1To24Parser2, _Parser);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/MinuteParser.js
var MinuteParser = function(_Parser) {
  _inherits(MinuteParser2, _Parser);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/SecondParser.js
var SecondParser = function(_Parser) {
  _inherits(SecondParser2, _Parser);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/FractionOfSecondParser.js
var FractionOfSecondParser = function(_Parser) {
  _inherits(FractionOfSecondParser2, _Parser);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneWithZParser.js
var ISOTimezoneWithZParser = function(_Parser) {
  _inherits(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/ISOTimezoneParser.js
var ISOTimezoneParser = function(_Parser) {
  _inherits(ISOTimezoneParser2, _Parser);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampSecondsParser.js
var TimestampSecondsParser = function(_Parser) {
  _inherits(TimestampSecondsParser2, _Parser);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/TimestampMillisecondsParser.js
var TimestampMillisecondsParser = function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);

// node_modules/date-fns/esm/parse/_lib/parsers/index.js
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/@sendbird/uikit-react/chunks/bundle-C8jOzYoR.js
var import_react24 = __toESM(require_react(), 1);
var SuggestedMentionList = function(props) {
  var currentChannel = useThread().state.currentChannel;
  return import_react24.default.createElement(SuggestedMentionListView, __assign({}, props, { currentChannel }));
};

// node_modules/@sendbird/uikit-react/chunks/bundle-CWmJRvV1.js
var Role = {
  OPERATOR: "operator",
  NONE: "none"
};

// node_modules/@sendbird/uikit-react/Channel/hooks/useHandleUploadFiles.js
var import_react25 = __toESM(require_react(), 1);
var import_react_dom12 = __toESM(require_react_dom(), 1);
var useHandleUploadFiles = function(_a, _b) {
  var sendFileMessage = _a.sendFileMessage, sendMultipleFilesMessage = _a.sendMultipleFilesMessage, quoteMessage = _a.quoteMessage;
  var logger = _b.logger;
  var stringSet = useLocalization().stringSet;
  var config = useSendbird().state.config;
  var imageCompression = config.imageCompression;
  var uikitUploadSizeLimit = config === null || config === void 0 ? void 0 : config.uikitUploadSizeLimit;
  var uikitMultipleFilesMessageLimit = config === null || config === void 0 ? void 0 : config.uikitMultipleFilesMessageLimit;
  var openModal = useGlobalModalContext().openModal;
  var handleUploadFiles = (0, import_react25.useCallback)(function(files) {
    return __awaiter(void 0, void 0, void 0, function() {
      var compressedFiles, sendingFiles, file, imageFiles_1, otherFiles_1;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!sendFileMessage || !sendMultipleFilesMessage) {
              logger.warning("Channel|useHandleUploadFiles: required functions are undefined", { sendFileMessage, sendMultipleFilesMessage });
              return [
                2
                /*return*/
              ];
            }
            if (files.length === 0) {
              logger.warning("Channel|useHandleUploadFiles: given file list is empty.", { files });
              return [
                2
                /*return*/
              ];
            }
            if (files.length > uikitMultipleFilesMessageLimit) {
              logger.info("Channel|useHandleUploadFiles: Cannot upload files more than ".concat(uikitMultipleFilesMessageLimit));
              openModal({
                modalProps: {
                  titleText: stringSet.FILE_UPLOAD_NOTIFICATION__COUNT_LIMIT.replace("%d", "".concat(uikitMultipleFilesMessageLimit)),
                  hideFooter: true
                },
                childElement: function(_a3) {
                  var closeModal = _a3.closeModal;
                  return import_react25.default.createElement(ModalFooter, { type: ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal });
                }
              });
              return [
                2
                /*return*/
              ];
            }
            if (files.some(function(file2) {
              return file2.size > uikitUploadSizeLimit;
            })) {
              logger.info("Channel|useHandleUploadFiles: Cannot upload file size exceeding ".concat(uikitUploadSizeLimit));
              openModal({
                modalProps: {
                  titleText: stringSet.FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT.replace("%d", "".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB))),
                  hideFooter: true
                },
                childElement: function(_a3) {
                  var closeModal = _a3.closeModal;
                  return import_react25.default.createElement(ModalFooter, { type: ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal });
                }
              });
              return [
                2
                /*return*/
              ];
            }
            return [4, compressImages({
              files,
              imageCompression,
              logger
            })];
          case 1:
            compressedFiles = _a2.sent().compressedFiles;
            sendingFiles = compressedFiles;
            if (sendingFiles.length === 1) {
              logger.info("Channel|useHandleUploadFiles: sending one file.");
              file = sendingFiles[0];
              sendFileMessage(file, quoteMessage);
            } else if (sendingFiles.length > 1) {
              logger.info("Channel|useHandleUploadFiles: sending multiple files.");
              imageFiles_1 = [];
              otherFiles_1 = [];
              sendingFiles.forEach(function(file2) {
                if (isImage(file2.type)) {
                  imageFiles_1.push(file2);
                } else {
                  otherFiles_1.push(file2);
                }
              });
              return [2, otherFiles_1.reduce(function(previousPromise, item) {
                return previousPromise.then(function() {
                  return sendFileMessage(item, quoteMessage);
                });
              }, function() {
                if (imageFiles_1.length === 0) {
                  return Promise.resolve();
                } else if (imageFiles_1.length === 1) {
                  return sendFileMessage(imageFiles_1[0], quoteMessage);
                } else {
                  return sendMultipleFilesMessage(imageFiles_1, quoteMessage);
                }
              }())];
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [
    sendFileMessage,
    sendMultipleFilesMessage,
    quoteMessage
  ]);
  return handleUploadFiles;
};

// node_modules/@sendbird/uikit-react/Thread/components/ThreadMessageInput.js
var import_react26 = __toESM(require_react(), 1);
var import_react_dom13 = __toESM(require_react_dom(), 1);
var ThreadMessageInput = function(props, ref) {
  var _a;
  var className = props.className, renderFileUploadIcon = props.renderFileUploadIcon, renderVoiceMessageIcon = props.renderVoiceMessageIcon, renderSendMessageIcon = props.renderSendMessageIcon, acceptableMimeTypes = props.acceptableMimeTypes;
  var config = useSendbird().state.config;
  var isMobile = useMediaQueryContext().isMobile;
  var stringSet = useLocalization().stringSet;
  var isOnline = config.isOnline, userMention = config.userMention, logger = config.logger, groupChannel = config.groupChannel;
  var threadContext = useThread();
  var _b = threadContext.state, currentChannel = _b.currentChannel, parentMessage = _b.parentMessage, isMuted = _b.isMuted, isChannelFrozen = _b.isChannelFrozen, allThreadMessages = _b.allThreadMessages, _c = threadContext.actions, sendMessage = _c.sendMessage, sendFileMessage = _c.sendFileMessage, sendVoiceMessage = _c.sendVoiceMessage, sendMultipleFilesMessage = _c.sendMultipleFilesMessage;
  var messageInputRef = (0, import_react26.useRef)();
  var isMentionEnabled = groupChannel.enableMention;
  var isVoiceMessageEnabled = groupChannel.enableVoiceMessage;
  var isMultipleFilesMessageEnabled = (_a = threadContext.state.isMultipleFilesMessageEnabled) !== null && _a !== void 0 ? _a : config.isMultipleFilesMessageEnabled;
  var threadInputDisabled = props.disabled || !isOnline || isMuted || !((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.myRole) === Role.OPERATOR) && isChannelFrozen || parentMessage === null;
  var handleUploadFiles = useHandleUploadFiles({
    sendFileMessage,
    sendMultipleFilesMessage,
    quoteMessage: parentMessage
  }, {
    logger
  });
  var _d = (0, import_react26.useState)(""), mentionNickname = _d[0], setMentionNickname = _d[1];
  var _e = (0, import_react26.useState)([]), mentionedUsers = _e[0], setMentionedUsers = _e[1];
  var _f = (0, import_react26.useState)([]), mentionedUserIds = _f[0], setMentionedUserIds = _f[1];
  var _g = (0, import_react26.useState)(null), selectedUser = _g[0], setSelectedUser = _g[1];
  var _h = (0, import_react26.useState)([]), mentionSuggestedUsers = _h[0], setMentionSuggestedUsers = _h[1];
  var _j = (0, import_react26.useState)(null), messageInputEvent = _j[0], setMessageInputEvent = _j[1];
  var _k = (0, import_react26.useState)(false), showVoiceMessageInput = _k[0], setShowVoiceMessageInput = _k[1];
  var displaySuggestedMentionList = isOnline && isMentionEnabled && mentionNickname.length > 0 && !isDisabledBecauseFrozen2(currentChannel) && !isDisabledBecauseMuted2(currentChannel) && !(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.isBroadcast);
  (0, import_react26.useEffect)(function() {
    setShowVoiceMessageInput(false);
  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);
  var mentionNodes = useDirtyGetMentions({ ref: ref || messageInputRef }, { logger });
  var ableMention = (mentionNodes === null || mentionNodes === void 0 ? void 0 : mentionNodes.length) < (userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount);
  (0, import_react26.useEffect)(function() {
    setMentionedUsers(mentionedUsers.filter(function(_a2) {
      var userId = _a2.userId;
      var i = mentionedUserIds.indexOf(userId);
      if (i < 0) {
        return false;
      } else {
        mentionedUserIds.splice(i, 1);
        return true;
      }
    }));
  }, [mentionedUserIds]);
  if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.isBroadcast) && (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.myRole) !== Role.OPERATOR) {
    return import_react26.default.createElement(import_react26.default.Fragment, null);
  }
  return import_react26.default.createElement(
    "div",
    { className: classnames(showVoiceMessageInput ? "sendbird-thread-message-input--voice-message" : "sendbird-thread-message-input", className) },
    displaySuggestedMentionList && import_react26.default.createElement(SuggestedMentionList, {
      targetNickname: mentionNickname,
      inputEvent: messageInputEvent !== null && messageInputEvent !== void 0 ? messageInputEvent : void 0,
      // renderUserMentionItem={renderUserMentionItem}
      onUserItemClick: function(user) {
        if (user) {
          setMentionedUsers(__spreadArray(__spreadArray([], mentionedUsers, true), [user], false));
        }
        setMentionNickname("");
        setSelectedUser(user);
        setMessageInputEvent(null);
      },
      onFocusItemChange: function() {
        setMessageInputEvent(null);
      },
      onFetchUsers: function(users) {
        setMentionSuggestedUsers(users);
      },
      ableAddMention: ableMention,
      maxMentionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount,
      maxSuggestionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxSuggestionCount
    }),
    showVoiceMessageInput ? import_react26.default.createElement(VoiceMessageInputWrapper, { channel: currentChannel, onSubmitClick: function(recordedFile, duration) {
      sendVoiceMessage(recordedFile, duration, parentMessage);
      setShowVoiceMessageInput(false);
    }, onCancelClick: function() {
      setShowVoiceMessageInput(false);
    } }) : import_react26.default.createElement(MessageInput, { className: "sendbird-thread-message-input__message-input", messageFieldId: "sendbird-message-input-text-field--thread", channel: currentChannel, channelUrl: currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url, isMobile, disabled: threadInputDisabled, acceptableMimeTypes, setMentionedUsers, mentionSelectedUser: selectedUser, isMentionEnabled, isVoiceMessageEnabled, isSelectingMultipleFilesEnabled: isMultipleFilesMessageEnabled, onVoiceMessageIconClick: function() {
      setShowVoiceMessageInput(true);
    }, renderFileUploadIcon, renderVoiceMessageIcon, renderSendMessageIcon, ref: ref || messageInputRef, placeholder: (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.isFrozen) && !((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.myRole) === Role.OPERATOR) && stringSet.MESSAGE_INPUT__PLACE_HOLDER__DISABLED || (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.myMutedState) === z.MUTED && stringSet.MESSAGE_INPUT__PLACE_HOLDER__MUTED_SHORT || (allThreadMessages.length > 0 ? stringSet.THREAD__INPUT__REPLY_TO_THREAD : stringSet.THREAD__INPUT__REPLY_IN_THREAD), onStartTyping: function() {
      var _a2;
      (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.startTyping) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel);
    }, onSendMessage: function(_a2) {
      var _b2;
      var message = _a2.message, mentionTemplate = _a2.mentionTemplate;
      sendMessage({
        message,
        mentionedUsers,
        mentionTemplate,
        quoteMessage: parentMessage
      });
      setMentionNickname("");
      setMentionedUsers([]);
      (_b2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.endTyping) === null || _b2 === void 0 ? void 0 : _b2.call(currentChannel);
    }, onFileUpload: handleUploadFiles, onUserMentioned: function(user) {
      if ((selectedUser === null || selectedUser === void 0 ? void 0 : selectedUser.userId) === (user === null || user === void 0 ? void 0 : user.userId)) {
        setSelectedUser(null);
        setMentionNickname("");
      }
    }, onMentionStringChange: function(mentionText) {
      setMentionNickname(mentionText);
    }, onMentionedUserIdsUpdated: function(userIds) {
      setMentionedUserIds(userIds);
    }, onKeyDown: function(e) {
      if (displaySuggestedMentionList && (mentionSuggestedUsers === null || mentionSuggestedUsers === void 0 ? void 0 : mentionSuggestedUsers.length) > 0 && (e.key === MessageInputKeys.Enter && ableMention || e.key === MessageInputKeys.ArrowUp || e.key === MessageInputKeys.ArrowDown)) {
        setMessageInputEvent(e);
        return true;
      }
      return false;
    } })
  );
};
var ThreadMessageInput$1 = import_react26.default.forwardRef(ThreadMessageInput);

// node_modules/@sendbird/uikit-react/ChannelList/components/ChannelPreview.js
var import_react27 = __toESM(require_react(), 1);
var import_react_dom14 = __toESM(require_react_dom(), 1);
var ChannelPreview = function(_a) {
  var _b, _c, _d, _e;
  var channel = _a.channel, _f = _a.isActive, isActive = _f === void 0 ? false : _f, _g = _a.isSelected, isSelected = _g === void 0 ? false : _g, _h = _a.isTyping, isTyping = _h === void 0 ? false : _h, renderChannelAction = _a.renderChannelAction, onLeaveChannel = _a.onLeaveChannel, onClick = _a.onClick, tabIndex = _a.tabIndex;
  var state = useSendbird().state;
  var config = state.config;
  var stringSet = useLocalization().stringSet;
  var _j = useChannelListContext(), _k = _j.isTypingIndicatorEnabled, isTypingIndicatorEnabled = _k === void 0 ? false : _k, _l = _j.isMessageReceiptStatusEnabled, isMessageReceiptStatusEnabled = _l === void 0 ? false : _l;
  var userId = config.userId;
  var isMessageStatusEnabled = isMessageReceiptStatusEnabled && (((_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.messageType) === "user" || ((_c = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _c === void 0 ? void 0 : _c.messageType) === "file") && ((_e = (_d = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _d === void 0 ? void 0 : _d.sender) === null || _e === void 0 ? void 0 : _e.userId) === userId;
  return import_react27.default.createElement(GroupChannelListItemView, { channel, tabIndex, isTyping: isTypingIndicatorEnabled && isTyping, isSelected: isSelected !== null && isSelected !== void 0 ? isSelected : isActive, channelName: getChannelTitle2(channel, userId, stringSet), isMessageStatusEnabled, onClick, onLeaveChannel, renderChannelAction });
};

// node_modules/@sendbird/uikit-react/ui/MessageSearchItem.js
var import_react28 = __toESM(require_react(), 1);
function getCreatedAt(_a) {
  var createdAt = _a.createdAt, locale = _a.locale, stringSet = _a.stringSet;
  var optionalParam = { locale };
  if (!createdAt) {
    return "";
  }
  if (isToday(createdAt)) {
    return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__TODAY, optionalParam);
  }
  if (isYesterday(createdAt)) {
    return stringSet.MESSAGE_STATUS__YESTERDAY;
  }
  if (isThisYear(createdAt)) {
    return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__THIS_YEAR, optionalParam);
  }
  return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__PREVIOUS_YEAR, optionalParam);
}
function MessageSearchItem(_a) {
  var className = _a.className, message = _a.message, selected = _a.selected, onClick = _a.onClick;
  var createdAt = message.createdAt;
  var messageText = message.message;
  var sender = message.sender || message._sender;
  var profileUrl = sender.profileUrl, nickname = sender.nickname;
  var _b = useLocalization(), stringSet = _b.stringSet, dateLocale = _b.dateLocale;
  return import_react28.default.createElement(
    "div",
    { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
      "sendbird-message-search-item",
      selected ? "sendbird-message-search-item--selected" : ""
    ], false).join(" "), onClick: function(e) {
      e.stopPropagation();
      onClick === null || onClick === void 0 ? void 0 : onClick(message);
    } },
    import_react28.default.createElement(
      "div",
      { className: "sendbird-message-search-item__left" },
      import_react28.default.createElement(Avatar$1, { className: "sendbird-message-search-item__left__sender-avatar", src: profileUrl, alt: "profile image", width: "56px", height: "56px" })
    ),
    import_react28.default.createElement(
      "div",
      { className: "sendbird-message-search-item__right" },
      import_react28.default.createElement(Label, { className: "sendbird-message-search-item__right__sender-name", type: LabelTypography.SUBTITLE_2, color: LabelColors.ONBACKGROUND_1 }, nickname || stringSet.NO_NAME),
      import_react28.default.createElement(Label, { className: "sendbird-message-search-item__right__message-text", type: LabelTypography.BODY_2, color: LabelColors.ONBACKGROUND_3 }, messageText),
      import_react28.default.createElement(Label, { className: "sendbird-message-search-item__right__message-created-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, getCreatedAt({ createdAt, locale: dateLocale, stringSet }))
    ),
    import_react28.default.createElement("div", { className: "sendbird-message-search-item__right-footer" })
  );
}

// node_modules/@sendbird/uikit-react/ui/MessageSearchFileItem.js
var import_react29 = __toESM(require_react(), 1);
function getCreatedAt2(_a) {
  var createdAt = _a.createdAt, locale = _a.locale, stringSet = _a.stringSet;
  var optionalParam = { locale };
  if (!createdAt) {
    return "";
  }
  if (isToday(createdAt)) {
    return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__TODAY, optionalParam);
  }
  if (isYesterday(createdAt)) {
    return stringSet.MESSAGE_STATUS__YESTERDAY;
  }
  if (isThisYear(createdAt)) {
    return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__THIS_YEAR, optionalParam);
  }
  return format(createdAt, stringSet.DATE_FORMAT__LAST_MESSAGE_CREATED_AT__PREVIOUS_YEAR, optionalParam);
}
function getIconOfFileType(message) {
  var _a, _b, _c;
  var fileMessageUrl = (_a = getMessageFirstFileUrl(message)) !== null && _a !== void 0 ? _a : "";
  var fileExtension = (_c = (_b = fileMessageUrl.match(/\.([^.]*?)(?=\?|#|$)/)) === null || _b === void 0 ? void 0 : _b[1]) !== null && _c !== void 0 ? _c : "";
  if (/(jpg|jpeg|png)$/i.test(fileExtension)) {
    return IconTypes.PHOTO;
  } else if (/mp4$/i.test(fileExtension) || isVoiceMessage(message)) {
    return IconTypes.PLAY;
  } else if (/mp3/i.test(fileExtension)) {
    return IconTypes.FILE_AUDIO;
  } else if (/gif/i.test(fileExtension)) {
    return IconTypes.GIF;
  } else {
    return IconTypes.FILE_DOCUMENT;
  }
}
function MessageSearchFileItem(props) {
  var className = props.className, message = props.message, selected = props.selected, onClick = props.onClick;
  var createdAt = message.createdAt;
  var url = getMessageFirstFileUrl(message);
  var name = getMessageFirstFileName(message);
  var sender = message.sender || message._sender;
  var profileUrl = sender.profileUrl, nickname = sender.nickname;
  var _a = useLocalization(), stringSet = _a.stringSet, dateLocale = _a.dateLocale;
  var isVoiceMsg = isVoiceMessage(message);
  var prettyFilename = isVoiceMsg ? stringSet.VOICE_MESSAGE : name || url;
  return import_react29.default.createElement(
    "div",
    { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
      "sendbird-message-search-file-item",
      selected ? "sendbird-message-search-file-item--selected" : ""
    ], false).join(" "), onClick: function(e) {
      e.stopPropagation();
      onClick === null || onClick === void 0 ? void 0 : onClick(message);
    } },
    import_react29.default.createElement(
      "div",
      { className: "sendbird-message-search-file-item__left" },
      import_react29.default.createElement(Avatar$1, { className: "sendbird-message-search-file-item__left__sender-avatar", src: profileUrl, alt: "profile image", width: "56px", height: "56px" })
    ),
    import_react29.default.createElement(
      "div",
      { className: "sendbird-message-search-file-item__right" },
      import_react29.default.createElement(Label, { className: "sendbird-message-search-file-item__right__sender-name", type: LabelTypography.SUBTITLE_2, color: LabelColors.ONBACKGROUND_1 }, nickname || stringSet.NO_NAME),
      import_react29.default.createElement(
        "div",
        { className: "sendbird-message-search-file-item__right__content" },
        !isVoiceMsg && import_react29.default.createElement(
          "div",
          { className: "sendbird-message-search-file-item__right__content__type-icon" },
          import_react29.default.createElement(Icon, { type: getIconOfFileType(message), fillColor: IconColors.PRIMARY, width: "18px", height: "18px" })
        ),
        import_react29.default.createElement(Label, { className: "sendbird-message-search-file-item__right__content__url", type: LabelTypography.BODY_2, color: LabelColors.ONBACKGROUND_1 }, prettyFilename)
      )
    ),
    import_react29.default.createElement(Label, { className: "sendbird-message-search-file-item__message-created-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, getCreatedAt2({ createdAt, locale: dateLocale, stringSet })),
    import_react29.default.createElement("div", { className: "sendbird-message-search-file-item__right-footer" })
  );
}

// node_modules/@sendbird/uikit-react/MessageSearch/components/MessageSearchUI.js
var import_react30 = __toESM(require_react(), 1);
var MessageSearchUI = function(_a) {
  var renderPlaceHolderError = _a.renderPlaceHolderError, renderPlaceHolderLoading = _a.renderPlaceHolderLoading, renderPlaceHolderNoString = _a.renderPlaceHolderNoString, renderPlaceHolderEmptyList = _a.renderPlaceHolderEmptyList, renderSearchItem = _a.renderSearchItem;
  var _b = useMessageSearch(), _c = _b.state, isInvalid = _c.isInvalid, searchString = _c.searchString, requestString = _c.requestString, currentChannel = _c.currentChannel, loading = _c.loading, scrollRef = _c.scrollRef, hasMoreResult = _c.hasMoreResult, onScroll = _c.onScroll, allMessages = _c.allMessages, onResultClick = _c.onResultClick, selectedMessageId = _c.selectedMessageId, _d = _b.actions, setSelectedMessageId = _d.setSelectedMessageId, handleRetryToConnect = _d.handleRetryToConnect;
  var stringSet = (0, import_react30.useContext)(LocalizationContext).stringSet;
  var handleOnScroll = function(e) {
    var scrollElement = e.target;
    var scrollTop = scrollElement.scrollTop, scrollHeight = scrollElement.scrollHeight, clientHeight = scrollElement.clientHeight;
    if (!hasMoreResult) {
      return;
    }
    if (scrollTop + clientHeight >= scrollHeight - 1) {
      onScroll(function() {
      });
    }
  };
  var getChannelName = function() {
    if (!(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.name) && !(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members)) {
      return stringSet.NO_TITLE;
    }
    if (isDefaultChannelName(currentChannel))
      return currentChannel.members.map(function(member) {
        return member.nickname || stringSet.NO_NAME;
      }).join(", ");
    return currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.name;
  };
  if (isInvalid && searchString && requestString) {
    return (renderPlaceHolderError === null || renderPlaceHolderError === void 0 ? void 0 : renderPlaceHolderError()) || import_react30.default.createElement(
      "div",
      { className: "sendbird-message-search" },
      import_react30.default.createElement(PlaceHolder, { type: PlaceHolderTypes.WRONG, retryToConnect: handleRetryToConnect })
    );
  }
  if (loading && searchString && requestString) {
    return (renderPlaceHolderLoading === null || renderPlaceHolderLoading === void 0 ? void 0 : renderPlaceHolderLoading()) || import_react30.default.createElement(
      "div",
      { className: "sendbird-message-search" },
      import_react30.default.createElement(PlaceHolder, { type: PlaceHolderTypes.SEARCHING })
    );
  }
  if (!searchString) {
    return (renderPlaceHolderNoString === null || renderPlaceHolderNoString === void 0 ? void 0 : renderPlaceHolderNoString()) || import_react30.default.createElement(
      "div",
      { className: "sendbird-message-search" },
      import_react30.default.createElement(PlaceHolder, { type: PlaceHolderTypes.SEARCH_IN, searchInString: getChannelName() })
    );
  }
  return import_react30.default.createElement("div", { className: "sendbird-message-search", onScroll: handleOnScroll, ref: scrollRef }, allMessages.length > 0 ? allMessages.map(function(message) {
    if (renderSearchItem) {
      return renderSearchItem({ message, onResultClick });
    }
    if (message.messageType === "file") {
      return import_react30.default.createElement(MessageSearchFileItem, { className: "sendbird-message-search__message-search-item", message, key: message.messageId, selected: selectedMessageId === message.messageId, onClick: function() {
        onResultClick === null || onResultClick === void 0 ? void 0 : onResultClick(message);
        setSelectedMessageId(message.messageId);
      } });
    }
    return import_react30.default.createElement(MessageSearchItem, { className: "sendbird-message-search__message-search-item", message, key: message.messageId, selected: selectedMessageId === message.messageId, onClick: function() {
      onResultClick === null || onResultClick === void 0 ? void 0 : onResultClick(message);
      setSelectedMessageId(message.messageId);
    } });
  }) : (renderPlaceHolderEmptyList === null || renderPlaceHolderEmptyList === void 0 ? void 0 : renderPlaceHolderEmptyList()) || import_react30.default.createElement(PlaceHolder, { type: PlaceHolderTypes.NO_RESULTS }));
};

// node_modules/@sendbird/uikit-react/MessageSearch.js
var import_react31 = __toESM(require_react(), 1);
function MessageSearchPannel(props) {
  var channelUrl = props.channelUrl, onResultClick = props.onResultClick, onCloseClick = props.onCloseClick, messageSearchQuery = props.messageSearchQuery, renderPlaceHolderError = props.renderPlaceHolderError, renderPlaceHolderLoading = props.renderPlaceHolderLoading, renderPlaceHolderNoString = props.renderPlaceHolderNoString, renderPlaceHolderEmptyList = props.renderPlaceHolderEmptyList, renderSearchItem = props.renderSearchItem;
  var _a = (0, import_react31.useState)(""), searchString = _a[0], setSearchString = _a[1];
  var _b = (0, import_react31.useState)(""), inputString = _b[0], setInputString = _b[1];
  var _c = (0, import_react31.useState)(false), loading = _c[0], setLoading = _c[1];
  var stringSet = (0, import_react31.useContext)(LocalizationContext).stringSet;
  var timeout = null;
  (0, import_react31.useEffect)(function() {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      setSearchString(inputString);
      setLoading(true);
      timeout = null;
    }, 500);
  }, [inputString]);
  var handleOnChangeInputString = function(e) {
    setInputString(e.target.value);
  };
  var handleOnResultLoaded = function() {
    setLoading(false);
  };
  var handleOnClickResetStringButton = function(e) {
    e.stopPropagation();
    setInputString("");
    setSearchString("");
  };
  return import_react31.default.createElement(
    "div",
    { className: "sendbird-message-search-pannel" },
    import_react31.default.createElement(Header$1, { className: "sendbird-message-search-pannel__header", renderMiddle: function() {
      return import_react31.default.createElement(Header$1.Title, { title: stringSet.SEARCH_IN_CHANNEL });
    }, renderRight: function() {
      return import_react31.default.createElement(Header$1.IconButton, { className: "sendbird-message-search-pannel__header__close-button", onClick: onCloseClick, type: IconTypes.CLOSE, color: IconColors.ON_BACKGROUND_1 });
    } }),
    import_react31.default.createElement(
      "div",
      { className: "sendbird-message-search-pannel__input" },
      import_react31.default.createElement(
        "div",
        { className: "sendbird-message-search-pannel__input__container" },
        import_react31.default.createElement(Icon, { className: "sendbird-message-search-pannel__input__container__search-icon", type: IconTypes.SEARCH, fillColor: IconColors.ON_BACKGROUND_3, width: "24px", height: "24px" }),
        import_react31.default.createElement("input", { className: "sendbird-message-search-pannel__input__container__input-area", placeholder: stringSet.SEARCH, value: inputString, onChange: handleOnChangeInputString }),
        inputString && loading && import_react31.default.createElement(
          Loader,
          { className: "sendbird-message-search-pannel__input__container__spinner", width: "20px", height: "20px" },
          import_react31.default.createElement(Icon, { type: IconTypes.SPINNER, fillColor: IconColors.PRIMARY, width: "20px", height: "20px" })
        ),
        !loading && inputString && import_react31.default.createElement(Icon, { className: "sendbird-message-search-pannel__input__container__reset-input-button", type: IconTypes.REMOVE, fillColor: IconColors.ON_BACKGROUND_3, width: "20px", height: "20px", onClick: handleOnClickResetStringButton })
      )
    ),
    import_react31.default.createElement(
      "div",
      { className: "sendbird-message-search-pannel__message-search" },
      import_react31.default.createElement(
        MessageSearchProvider,
        { channelUrl, searchString, onResultClick, onResultLoaded: handleOnResultLoaded, messageSearchQuery },
        import_react31.default.createElement(MessageSearchUI, { renderPlaceHolderError, renderPlaceHolderLoading, renderPlaceHolderNoString, renderPlaceHolderEmptyList, renderSearchItem })
      )
    )
  );
}

// node_modules/@sendbird/uikit-react/chunks/bundle-ByyQIaJp.js
var import_react32 = __toESM(require_react(), 1);
var RemoveMessage = function(props) {
  var _a, _b;
  var onCancel = props.onCancel, onSubmit = props.onSubmit, message = props.message;
  var stringSet = (0, import_react32.useContext)(LocalizationContext).stringSet;
  var deleteMessage = useThread().actions.deleteMessage;
  return import_react32.default.createElement(Modal, { type: ButtonTypes.DANGER, disabled: ((_b = (_a = message.threadInfo) === null || _a === void 0 ? void 0 : _a.replyCount) !== null && _b !== void 0 ? _b : 0) > 0, onCancel, onSubmit: function() {
    deleteMessage(message).then(function() {
      onCancel === null || onCancel === void 0 ? void 0 : onCancel();
      onSubmit === null || onSubmit === void 0 ? void 0 : onSubmit();
    });
  }, submitText: stringSet.MESSAGE_MENU__DELETE, titleText: getModalDeleteMessageTitle(stringSet, message) });
};

// node_modules/@sendbird/uikit-react/Thread/components/ParentMessageInfoItem.js
var import_react33 = __toESM(require_react(), 1);
var import_react_dom15 = __toESM(require_react_dom(), 1);
function ParentMessageInfoItem(_a) {
  var _this = this;
  var _b, _c, _d, _e, _f, _g, _h, _j;
  var className = _a.className, message = _a.message, showFileViewer = _a.showFileViewer, _k = _a.onBeforeDownloadFileMessage, onBeforeDownloadFileMessage = _k === void 0 ? null : _k;
  var _l = useSendbird().state, stores = _l.stores, config = _l.config, eventHandlers = _l.eventHandlers;
  var logger = config.logger;
  var onPressUserProfileHandler = (_b = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.reaction) === null || _b === void 0 ? void 0 : _b.onPressUserProfile;
  var currentUserId = (_d = (_c = stores === null || stores === void 0 ? void 0 : stores.userStore) === null || _c === void 0 ? void 0 : _c.user) === null || _d === void 0 ? void 0 : _d.userId;
  var stringSet = useLocalization().stringSet;
  var _m = useThread(), _o = _m.state, currentChannel = _o.currentChannel, emojiContainer = _o.emojiContainer, nicknamesMap = _o.nicknamesMap, filterEmojiCategoryIds = _o.filterEmojiCategoryIds, toggleReaction = _m.actions.toggleReaction;
  var isMobile = useMediaQueryContext().isMobile;
  var isReactionEnabled = config.groupChannel.enableReactions;
  var isMentionEnabled = config.groupChannel.enableMention;
  var threadMessageKindKey = useThreadMessageKindKeySelector({
    threadMessageKind: ThreadMessageKind.PARENT,
    isMobile
  });
  var statefulFileInfoList = useFileInfoListWithUploaded(message);
  var isMentionedMessage = isMentionEnabled && (message === null || message === void 0 ? void 0 : message.isUserMessage()) && ((_e = message === null || message === void 0 ? void 0 : message.mentionedMessageTemplate) === null || _e === void 0 ? void 0 : _e.length) > 0 && (message === null || message === void 0 ? void 0 : message.mentionedUsers) && message.mentionedUsers.length > 0;
  var isReactionActivated = isReactionEnabled && config.groupChannel.replyType === "thread" && ((_f = message === null || message === void 0 ? void 0 : message.reactions) === null || _f === void 0 ? void 0 : _f.length) > 0;
  var tokens = (0, import_react33.useMemo)(function() {
    var _a2;
    if (isMentionedMessage) {
      return tokenizeMessage({
        mentionedUsers: (_a2 = message === null || message === void 0 ? void 0 : message.mentionedUsers) !== null && _a2 !== void 0 ? _a2 : void 0,
        messageText: message === null || message === void 0 ? void 0 : message.mentionedMessageTemplate,
        includeMarkdown: config.groupChannel.enableMarkdownForUserMessage
      });
    }
    return tokenizeMessage({
      messageText: message === null || message === void 0 ? void 0 : message.message,
      includeMarkdown: config.groupChannel.enableMarkdownForUserMessage
    });
  }, [message === null || message === void 0 ? void 0 : message.updatedAt, message === null || message === void 0 ? void 0 : message.message]);
  var downloadFileWithUrl = function() {
    if (isFileMessage(message))
      openURL(message.url);
  };
  var handleOnClickTextButton = onBeforeDownloadFileMessage ? function() {
    return __awaiter(_this, void 0, void 0, function() {
      var allowDownload, err_1;
      var _a2, _b2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            if (!(message.messageType === "file"))
              return [3, 4];
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, , 4]);
            return [4, onBeforeDownloadFileMessage({ message })];
          case 2:
            allowDownload = _c2.sent();
            if (allowDownload) {
              downloadFileWithUrl();
            } else {
              (_a2 = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "ParentMessageInfoItem: Not allowed to download.");
            }
            return [3, 4];
          case 3:
            err_1 = _c2.sent();
            (_b2 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b2 === void 0 ? void 0 : _b2.call(logger, "ParentMessageInfoItem: Error occurred while determining download continuation:", err_1);
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  } : downloadFileWithUrl;
  var _p = (0, import_react33.useState)(false), isImageRendered = _p[0], setImageRendered = _p[1];
  var thumbnailUrl = ((_g = message === null || message === void 0 ? void 0 : message.thumbnails) === null || _g === void 0 ? void 0 : _g.length) > 0 ? (_h = message === null || message === void 0 ? void 0 : message.thumbnails[0]) === null || _h === void 0 ? void 0 : _h.url : "";
  return import_react33.default.createElement(
    "div",
    { className: "sendbird-parent-message-info-item ".concat(className) },
    isUserMessage(message) && import_react33.default.createElement(
      Label,
      { className: "sendbird-parent-message-info-item__text-message", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 },
      import_react33.default.createElement(TextFragment, { tokens }),
      isEditedMessage(message) && import_react33.default.createElement(Label, { className: "sendbird-parent-message-info-item__text-message edited", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_2 }, " ".concat(stringSet.MESSAGE_EDITED, " "))
    ),
    // Instead of the FileMessageItemBody component
    getUIKitMessageType(message) === getUIKitMessageTypes().FILE && import_react33.default.createElement(
      "div",
      { className: "sendbird-parent-message-info-item__file-message" },
      import_react33.default.createElement(
        "div",
        { className: "sendbird-parent-message-info-item__file-message__file-icon" },
        import_react33.default.createElement(Icon, { className: "sendbird-parent-message-info-item__file-message__file-icon__icon", type: {
          IMAGE: IconTypes.PHOTO,
          VIDEO: IconTypes.PLAY,
          AUDIO: IconTypes.FILE_AUDIO,
          GIF: IconTypes.GIF,
          OTHERS: IconTypes.FILE_DOCUMENT
        }[getUIKitFileType(message === null || message === void 0 ? void 0 : message.type)], fillColor: IconColors.PRIMARY, width: "24px", height: "24px" })
      ),
      import_react33.default.createElement(
        TextButton,
        { className: "sendbird-parent-message-info-item__file-message__file-name", onClick: handleOnClickTextButton, color: Colors.ONBACKGROUND_1 },
        import_react33.default.createElement(Label, { className: "sendbird-parent-message-info-item__file-message__file-name__text", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 }, truncateString((message === null || message === void 0 ? void 0 : message.name) || (message === null || message === void 0 ? void 0 : message.url), 30))
      )
    ),
    isMultipleFilesMessage(message) && import_react33.default.createElement(MultipleFilesMessageItemBody, { className: "sendbird-parent-message-info-item__multiple-files-message-wrapper", message, isByMe: false, isReactionEnabled, threadMessageKindKey, statefulFileInfoList, onBeforeDownloadFileMessage }),
    isVoiceMessage(message) && import_react33.default.createElement(
      "div",
      { className: "sendbird-parent-message-info-item__voice-message" },
      import_react33.default.createElement(VoiceMessageItemBody, { className: "sendbird-parent-message-info-item__voice-message__item", message, channelUrl: currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url, isByMe: false, isReactionEnabled })
    ),
    isThumbnailMessage(message) && import_react33.default.createElement(
      "div",
      { className: "sendbird-parent-message-info-item__thumbnail-message", onClick: function() {
        if (isSentMessage(message)) {
          showFileViewer === null || showFileViewer === void 0 ? void 0 : showFileViewer(true);
        }
      } },
      import_react33.default.createElement(ImageRenderer, { className: "sendbird-parent-message-info-item__thumbnail-message__thumbnail", url: thumbnailUrl || (message === null || message === void 0 ? void 0 : message.url) || (message === null || message === void 0 ? void 0 : message.plainUrl), alt: message === null || message === void 0 ? void 0 : message.type, width: "200px", height: "148px", onLoad: function() {
        setImageRendered(true);
      }, placeHolder: function(_a2) {
        var style = _a2.style;
        return import_react33.default.createElement(
          "div",
          { className: "sendbird-parent-message-info-item__thumbnail-message__placeholder", style },
          import_react33.default.createElement(
            "div",
            { className: "sendbird-parent-message-info-item__thumbnail-message__placeholder__icon" },
            import_react33.default.createElement(Icon, { type: isVideoMessage(message) ? IconTypes.PLAY : IconTypes.PHOTO, fillColor: IconColors.ON_BACKGROUND_2, width: "34px", height: "34px" })
          )
        );
      } }),
      isVideoMessage(message) && !thumbnailUrl && !isImageRendered && import_react33.default.createElement(
        "video",
        { className: "sendbird-parent-message-info-item__thumbnail-message__video" },
        import_react33.default.createElement("source", { src: (message === null || message === void 0 ? void 0 : message.url) || (message === null || message === void 0 ? void 0 : message.plainUrl), type: message === null || message === void 0 ? void 0 : message.type })
      ),
      import_react33.default.createElement("div", { className: "sendbird-parent-message-info-item__thumbnail-message__image-cover" }),
      (isVideoMessage(message) || isGifMessage(message)) && import_react33.default.createElement(
        "div",
        { className: "sendbird-parent-message-info-item__thumbnail-message__icon-wrapper" },
        import_react33.default.createElement(
          "div",
          { className: "sendbird-parent-message-info-item__thumbnail-message__icon-wrapper__icon" },
          import_react33.default.createElement(Icon, { type: isVideoMessage(message) ? IconTypes.PLAY : IconTypes.GIF, fillColor: IconColors.ON_BACKGROUND_2, width: "34px", height: "34px" })
        )
      )
    ),
    getUIKitMessageType(message) === ((_j = getUIKitMessageTypes === null || getUIKitMessageTypes === void 0 ? void 0 : getUIKitMessageTypes()) === null || _j === void 0 ? void 0 : _j.UNKNOWN) && import_react33.default.createElement(
      "div",
      { className: "sendbird-parent-message-info-item__unknown-message" },
      import_react33.default.createElement(Label, { className: "sendbird-parent-message-info-item__unknown-message__header", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 }, stringSet.UNKNOWN__UNKNOWN_MESSAGE_TYPE),
      import_react33.default.createElement(Label, { className: "sendbird-parent-message-info-item__unknown-message__description", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_2 }, stringSet.UNKNOWN__CANNOT_READ_MESSAGE)
    ),
    isReactionActivated && import_react33.default.createElement(
      "div",
      { className: "sendbird-parent-message-info__reactions" },
      import_react33.default.createElement(EmojiReactions, { userId: currentUserId, message, channel: currentChannel, isByMe: false, emojiContainer, memberNicknamesMap: nicknamesMap, toggleReaction, onPressUserProfile: onPressUserProfileHandler, filterEmojiCategoryIds })
    )
  );
}

// node_modules/@sendbird/uikit-react/Thread/components/ParentMessageInfo.js
var import_react34 = __toESM(require_react(), 1);
var import_react_dom16 = __toESM(require_react_dom(), 1);
function ParentMessageInfo(_a) {
  var _this = this;
  var _b, _c, _d, _e, _f, _g;
  var className = _a.className, _h = _a.renderEmojiMenu, renderEmojiMenu = _h === void 0 ? function(props) {
    return import_react34.default.createElement(MessageEmojiMenu, __assign({}, props));
  } : _h, _j = _a.renderMessageMenu, renderMessageMenu = _j === void 0 ? function(props) {
    return import_react34.default.createElement(MessageMenu, __assign({}, props));
  } : _j;
  var _k = useSendbird().state, stores = _k.stores, config = _k.config;
  var isOnline = config.isOnline, userMention = config.userMention, logger = config.logger, groupChannel = config.groupChannel;
  var userId = (_c = (_b = stores.userStore.user) === null || _b === void 0 ? void 0 : _b.userId) !== null && _c !== void 0 ? _c : "";
  var _l = useLocalization(), dateLocale = _l.dateLocale, stringSet = _l.stringSet;
  var _m = useThread(), _o = _m.state, currentChannel = _o.currentChannel, parentMessage = _o.parentMessage, allThreadMessages = _o.allThreadMessages, emojiContainer = _o.emojiContainer, onMoveToParentMessage = _o.onMoveToParentMessage, onHeaderActionClick = _o.onHeaderActionClick, isMuted = _o.isMuted, isChannelFrozen = _o.isChannelFrozen, onBeforeDownloadFileMessage = _o.onBeforeDownloadFileMessage, filterEmojiCategoryIds = _o.filterEmojiCategoryIds, _p = _m.actions, toggleReaction = _p.toggleReaction, updateMessage = _p.updateMessage, deleteMessage = _p.deleteMessage;
  var isMobile = useMediaQueryContext().isMobile;
  var isMenuMounted = useElementObserver("#".concat(getObservingId(parentMessage.messageId), ".").concat(MENU_OBSERVING_CLASS_NAME), [
    document.getElementById(MENU_ROOT_ID),
    document.getElementById(EMOJI_MENU_ROOT_ID)
  ]);
  var _q = (0, import_react34.useState)(false), showRemove = _q[0], setShowRemove = _q[1];
  var _r = (0, import_react34.useState)(false), showFileViewer = _r[0], setShowFileViewer = _r[1];
  var isReactionEnabled = getIsReactionEnabled({
    channel: currentChannel,
    config
  });
  var isMentionEnabled = groupChannel.enableMention;
  var replyType = getCaseResolvedReplyType(groupChannel.replyType).upperCase;
  var isByMe = userId === parentMessage.sender.userId;
  var mobileMenuRef = (0, import_react34.useRef)(null);
  var _s = (0, import_react34.useState)(false), showMobileMenu = _s[0], setShowMobileMenu = _s[1];
  var longPress = useLongPress({
    onLongPress: function() {
      if (isMobile) {
        setShowMobileMenu(true);
      }
    }
  }, {
    shouldPreventDefault: false
  });
  var _t = (0, import_react34.useState)(false), showEditInput = _t[0], setShowEditInput = _t[1];
  var disabled = !isOnline || isMuted || isChannelFrozen && !((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.myRole) === Role.OPERATOR);
  var editMessageInputRef = (0, import_react34.useRef)(null);
  var _u = (0, import_react34.useState)(""), mentionNickname = _u[0], setMentionNickname = _u[1];
  var _v = (0, import_react34.useState)([]), mentionedUsers = _v[0], setMentionedUsers = _v[1];
  var _w = (0, import_react34.useState)([]), mentionedUserIds = _w[0], setMentionedUserIds = _w[1];
  var _x = (0, import_react34.useState)(null), messageInputEvent = _x[0], setMessageInputEvent = _x[1];
  var _y = (0, import_react34.useState)(null), selectedUser = _y[0], setSelectedUser = _y[1];
  var _z = (0, import_react34.useState)([]), mentionSuggestedUsers = _z[0], setMentionSuggestedUsers = _z[1];
  var displaySuggestedMentionList = isOnline && isMentionEnabled && mentionNickname.length > 0 && !isMuted && !(isChannelFrozen && !(currentChannel.myRole === Role.OPERATOR));
  var mentionNodes = useDirtyGetMentions({ ref: editMessageInputRef }, { logger });
  var ableMention = (mentionNodes === null || mentionNodes === void 0 ? void 0 : mentionNodes.length) < (userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount);
  (0, import_react34.useEffect)(function() {
    setMentionedUsers(mentionedUsers.filter(function(_a2) {
      var userId2 = _a2.userId;
      var i = mentionedUserIds.indexOf(userId2);
      if (i < 0) {
        return false;
      } else {
        mentionedUserIds.splice(i, 1);
        return true;
      }
    }));
  }, [mentionedUserIds]);
  var handleOnDownloadClick = function(e) {
    return __awaiter(_this, void 0, void 0, function() {
      var allowDownload, err_1;
      var _a2, _b2;
      return __generator(this, function(_c2) {
        switch (_c2.label) {
          case 0:
            if (!onBeforeDownloadFileMessage)
              return [
                2
                /*return*/
              ];
            _c2.label = 1;
          case 1:
            _c2.trys.push([1, 3, , 4]);
            return [4, onBeforeDownloadFileMessage({ message: parentMessage })];
          case 2:
            allowDownload = _c2.sent();
            if (!allowDownload) {
              e.preventDefault();
              (_a2 = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "ParentMessageInfo: Not allowed to download.");
            }
            return [3, 4];
          case 3:
            err_1 = _c2.sent();
            (_b2 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b2 === void 0 ? void 0 : _b2.call(logger, "ParentMessageInfo: Error occurred while determining download continuation:", err_1);
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var avatarRef = (0, import_react34.useRef)(null);
  var _0 = useUserProfileContext(), disableUserProfile = _0.disableUserProfile, renderUserProfile = _0.renderUserProfile;
  if (showEditInput && ((_d = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.isUserMessage) === null || _d === void 0 ? void 0 : _d.call(parentMessage))) {
    return import_react34.default.createElement(
      import_react34.default.Fragment,
      null,
      displaySuggestedMentionList && import_react34.default.createElement(SuggestedMentionList, {
        className: "parent-message-info--suggested-mention-list",
        targetNickname: mentionNickname,
        inputEvent: messageInputEvent !== null && messageInputEvent !== void 0 ? messageInputEvent : void 0,
        // renderUserMentionItem={renderUserMentionItem}
        onUserItemClick: function(user) {
          if (user) {
            setMentionedUsers(__spreadArray(__spreadArray([], mentionedUsers, true), [user], false));
          }
          setMentionNickname("");
          setSelectedUser(user);
          setMessageInputEvent(null);
        },
        onFocusItemChange: function() {
          setMessageInputEvent(null);
        },
        onFetchUsers: function(users) {
          setMentionSuggestedUsers(users);
        },
        ableAddMention: ableMention,
        maxMentionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount,
        maxSuggestionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxSuggestionCount
      }),
      import_react34.default.createElement(MessageInput, { channel: currentChannel, isEdit: true, disabled, ref: editMessageInputRef, mentionSelectedUser: selectedUser, isMentionEnabled, message: parentMessage, onStartTyping: function() {
        var _a2;
        (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.startTyping) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel);
      }, onUpdateMessage: function(_a2) {
        var _b2;
        var messageId = _a2.messageId, message = _a2.message, mentionTemplate = _a2.mentionTemplate;
        updateMessage({
          messageId,
          message,
          mentionedUsers,
          mentionTemplate
        });
        setShowEditInput(false);
        (_b2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.endTyping) === null || _b2 === void 0 ? void 0 : _b2.call(currentChannel);
      }, onCancelEdit: function() {
        var _a2;
        setMentionNickname("");
        setMentionedUsers([]);
        setMentionedUserIds([]);
        setMentionSuggestedUsers([]);
        setShowEditInput(false);
        (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.endTyping) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel);
      }, onUserMentioned: function(user) {
        if ((selectedUser === null || selectedUser === void 0 ? void 0 : selectedUser.userId) === (user === null || user === void 0 ? void 0 : user.userId)) {
          setSelectedUser(null);
          setMentionNickname("");
        }
      }, onMentionStringChange: function(mentionText) {
        setMentionNickname(mentionText);
      }, onMentionedUserIdsUpdated: function(userIds) {
        setMentionedUserIds(userIds);
      }, onKeyDown: function(e) {
        if (displaySuggestedMentionList && (mentionSuggestedUsers === null || mentionSuggestedUsers === void 0 ? void 0 : mentionSuggestedUsers.length) > 0 && (e.key === MessageInputKeys.Enter && ableMention || e.key === MessageInputKeys.ArrowUp || e.key === MessageInputKeys.ArrowDown)) {
          setMessageInputEvent(e);
          return true;
        }
        return false;
      } })
    );
  }
  return import_react34.default.createElement(
    "div",
    __assign({ className: "sendbird-parent-message-info ".concat(className) }, isMobile ? __assign({}, longPress) : {}, { ref: mobileMenuRef }),
    import_react34.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
      var _a2, _b2, _c2;
      return import_react34.default.createElement(Avatar$1, { className: "sendbird-parent-message-info__sender", ref: avatarRef, src: ((_b2 = (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) === null || _a2 === void 0 ? void 0 : _a2.find(function(m) {
        var _a3;
        return (m === null || m === void 0 ? void 0 : m.userId) === ((_a3 = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender) === null || _a3 === void 0 ? void 0 : _a3.userId);
      })) === null || _b2 === void 0 ? void 0 : _b2.profileUrl) || ((_c2 = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender) === null || _c2 === void 0 ? void 0 : _c2.profileUrl), alt: "thread message sender", width: "40px", height: "40px", onClick: function() {
        if (!disableUserProfile) {
          toggleDropdown();
        }
      } });
    }, menuItems: function(closeDropdown) {
      return renderUserProfile ? renderUserProfile({
        user: parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender,
        close: closeDropdown,
        currentUserId: userId,
        avatarRef
      }) : import_react34.default.createElement(
        MenuItems,
        { parentRef: avatarRef, parentContainRef: avatarRef, closeDropdown, style: { paddingTop: "0px", paddingBottom: "0px" } },
        import_react34.default.createElement(UserProfile, { user: parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender, currentUserId: userId, onSuccess: closeDropdown })
      );
    } }),
    import_react34.default.createElement(
      "div",
      { className: "sendbird-parent-message-info__content" },
      import_react34.default.createElement(
        "div",
        { className: "sendbird-parent-message-info__content__info" },
        import_react34.default.createElement(Label, { className: isReactionEnabled ? "sendbird-parent-message-info__content__info__sender-name--use-reaction" : "sendbird-parent-message-info__content__info__sender-name", type: LabelTypography.CAPTION_2, color: LabelColors.ONBACKGROUND_2 }, ((_f = (_e = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) === null || _e === void 0 ? void 0 : _e.find(function(member) {
          var _a2;
          return (member === null || member === void 0 ? void 0 : member.userId) === ((_a2 = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender) === null || _a2 === void 0 ? void 0 : _a2.userId);
        })) === null || _f === void 0 ? void 0 : _f.nickname) || (getSenderName === null || getSenderName === void 0 ? void 0 : getSenderName(parentMessage))),
        import_react34.default.createElement(Label, { className: "sendbird-parent-message-info__content__info__sent-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, format((parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.createdAt) || 0, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, { locale: dateLocale }))
      ),
      import_react34.default.createElement(ParentMessageInfoItem, { message: parentMessage, showFileViewer: setShowFileViewer, onBeforeDownloadFileMessage })
    ),
    !isMobile && import_react34.default.createElement(
      "div",
      { className: "sendbird-parent-message-info__menu-container" },
      renderMessageMenu({
        className: classnames("sendbird-parent-message-info__context-menu", isReactionEnabled && "use-reaction", isMenuMounted && "sendbird-mouse-hover"),
        channel: currentChannel,
        message: parentMessage,
        isByMe: userId === ((_g = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender) === null || _g === void 0 ? void 0 : _g.userId),
        disableDeleteMessage: allThreadMessages.length > 0,
        replyType,
        showEdit: setShowEditInput,
        showRemove: setShowRemove,
        onMoveToParentMessage: function() {
          onMoveToParentMessage === null || onMoveToParentMessage === void 0 ? void 0 : onMoveToParentMessage({ message: parentMessage, channel: currentChannel });
        },
        deleteMessage
      }),
      isReactionEnabled && renderEmojiMenu({
        className: classnames("sendbird-parent-message-info__reaction-menu", isMenuMounted && "sendbird-mouse-hover"),
        message: parentMessage,
        userId,
        emojiContainer,
        toggleReaction,
        filterEmojiCategoryIds
      })
    ),
    showRemove && import_react34.default.createElement(RemoveMessage, { onCancel: function() {
      return setShowRemove(false);
    }, onSubmit: function() {
      onHeaderActionClick === null || onHeaderActionClick === void 0 ? void 0 : onHeaderActionClick();
    }, message: parentMessage }),
    showFileViewer && import_react34.default.createElement(FileViewer, { message: parentMessage, onClose: function() {
      return setShowFileViewer(false);
    }, onDelete: function() {
      deleteMessage(parentMessage).then(function() {
        setShowFileViewer(false);
      });
    }, onDownloadClick: handleOnDownloadClick }),
    showMobileMenu && import_react34.default.createElement(MobileMenu, { parentRef: mobileMenuRef, channel: currentChannel, message: parentMessage, userId, replyType, hideMenu: function() {
      setShowMobileMenu(false);
    }, deleteMessage, deleteMenuState: (allThreadMessages === null || allThreadMessages === void 0 ? void 0 : allThreadMessages.length) === 0 ? "ACTIVE" : "HIDE", isReactionEnabled, isByMe, emojiContainer, showEdit: setShowEditInput, showRemove: setShowRemove, toggleReaction, isOpenedFromThread: true, onDownloadClick: handleOnDownloadClick })
  );
}

// node_modules/@sendbird/uikit-react/Thread/components/ThreadHeader.js
var import_react35 = __toESM(require_react(), 1);
function ThreadHeader(_a) {
  var className = _a.className, channelName = _a.channelName, renderActionIcon = _a.renderActionIcon, onActionIconClick = _a.onActionIconClick, onChannelNameClick = _a.onChannelNameClick;
  var stringSet = useLocalization().stringSet;
  var MemoizedActionIcon = (0, import_react35.useMemo)(function() {
    if (typeof renderActionIcon === "function" && onActionIconClick) {
      return renderActionIcon({ onActionIconClick });
    }
    return null;
  }, [renderActionIcon]);
  return import_react35.default.createElement(Header$1, { className: "sendbird-thread-header ".concat(className), renderMiddle: function() {
    return import_react35.default.createElement(Header$1.Title, { title: stringSet.THREAD__HEADER_TITLE, subtitle: channelName, onClickSubtitle: onChannelNameClick });
  }, renderRight: function() {
    return MemoizedActionIcon || import_react35.default.createElement(
      "div",
      { className: "sendbird-thread-header__action" },
      import_react35.default.createElement(Header$1.IconButton, { onClick: function(e) {
        return onActionIconClick(e);
      }, type: IconTypes.CLOSE, color: IconColors.ON_BACKGROUND_1 })
    );
  } });
}

// node_modules/@sendbird/uikit-react/Thread/components/ThreadListItem.js
var import_react36 = __toESM(require_react(), 1);
var import_react_dom17 = __toESM(require_react_dom(), 1);
function ThreadListItemContent(props) {
  var _this = this;
  var _a, _b, _c;
  var className = props.className, userId = props.userId, channel = props.channel, message = props.message, _d = props.chainTop, chainTop = _d === void 0 ? false : _d, _e = props.chainBottom, chainBottom = _e === void 0 ? false : _e, _f = props.isReactionEnabled, isReactionEnabled = _f === void 0 ? false : _f, _g = props.disableQuoteMessage, disableQuoteMessage = _g === void 0 ? false : _g, replyType = props.replyType, nicknamesMap = props.nicknamesMap, emojiContainer = props.emojiContainer, showEdit = props.showEdit, showRemove = props.showRemove, showFileViewer = props.showFileViewer, resendMessage = props.resendMessage, toggleReaction = props.toggleReaction, onReplyInThread = props.onReplyInThread;
  var _h = deleteNullish(props), _j = _h.renderSenderProfile, renderSenderProfile = _j === void 0 ? function(props2) {
    return import_react36.default.createElement(MessageProfile, __assign({}, props2));
  } : _j, _k = _h.renderMessageBody, renderMessageBody = _k === void 0 ? function(props2) {
    return import_react36.default.createElement(MessageBody, __assign({}, props2));
  } : _k, _l = _h.renderMessageHeader, renderMessageHeader = _l === void 0 ? function(props2) {
    return import_react36.default.createElement(MessageHeader, __assign({}, props2));
  } : _l, _m = _h.renderMessageMenu, renderMessageMenu = _m === void 0 ? function(props2) {
    return import_react36.default.createElement(MessageMenu, __assign({}, props2));
  } : _m, _o = _h.renderEmojiMenu, renderEmojiMenu = _o === void 0 ? function() {
    return import_react36.default.createElement(MessageEmojiMenu, __assign({}, props));
  } : _o, _p = _h.renderEmojiReactions, renderEmojiReactions = _p === void 0 ? function(props2) {
    return import_react36.default.createElement(EmojiReactions, __assign({}, props2));
  } : _p, _q = _h.renderMobileMenuOnLongPress, renderMobileMenuOnLongPress = _q === void 0 ? function(props2) {
    return import_react36.default.createElement(MobileMenu, __assign({}, props2));
  } : _q;
  var isMobile = useMediaQueryContext().isMobile;
  var _r = useLocalization(), dateLocale = _r.dateLocale, stringSet = _r.stringSet;
  var _s = useSendbird().state, config = _s.config, eventHandlers = _s.eventHandlers;
  var logger = config.logger;
  var onPressUserProfileHandler = (_a = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.reaction) === null || _a === void 0 ? void 0 : _a.onPressUserProfile;
  var isMenuMounted = useElementObserver("#".concat(getObservingId(message.messageId), ".").concat(MENU_OBSERVING_CLASS_NAME), [
    document.getElementById(MENU_ROOT_ID),
    document.getElementById(EMOJI_MENU_ROOT_ID)
  ]);
  var _t = useThread(), _u = _t.state, onBeforeDownloadFileMessage = _u.onBeforeDownloadFileMessage, filterEmojiCategoryIds = _u.filterEmojiCategoryIds, deleteMessage = _t.actions.deleteMessage;
  var isByMe = userId === ((_b = message === null || message === void 0 ? void 0 : message.sender) === null || _b === void 0 ? void 0 : _b.userId) || (message === null || message === void 0 ? void 0 : message.sendingStatus) === "pending" || (message === null || message === void 0 ? void 0 : message.sendingStatus) === "failed";
  var useReplying = !!((replyType === "QUOTE_REPLY" || replyType === "THREAD") && (message === null || message === void 0 ? void 0 : message.parentMessageId) && (message === null || message === void 0 ? void 0 : message.parentMessage) && !disableQuoteMessage);
  var supposedHoverClassName = isMenuMounted ? "sendbird-mouse-hover" : "";
  var isReactionEnabledInChannel = isReactionEnabled && !(channel === null || channel === void 0 ? void 0 : channel.isEphemeral);
  var isOgMessageEnabledInGroupChannel = (channel === null || channel === void 0 ? void 0 : channel.isGroupChannel()) && config.groupChannel.enableOgtag;
  var mobileMenuRef = (0, import_react36.useRef)(null);
  var _v = (0, import_react36.useState)(false), showMobileMenu = _v[0], setShowMobileMenu = _v[1];
  var longPress = useLongPress({
    onLongPress: function() {
      if (isMobile) {
        setShowMobileMenu(true);
      }
    }
  }, {
    shouldPreventDefault: false
  });
  var threadMessageKindKey = useThreadMessageKindKeySelector({
    threadMessageKind: ThreadMessageKind.CHILD,
    isMobile
  });
  var statefulFileInfoList = useFileInfoListWithUploaded(message);
  return import_react36.default.createElement(
    "div",
    { className: classnames("sendbird-thread-list-item-content", className, isByMe ? "outgoing" : "incoming"), ref: mobileMenuRef },
    import_react36.default.createElement(
      "div",
      { className: classnames("sendbird-thread-list-item-content__left", isReactionEnabledInChannel && "use-reaction", isByMe ? "outgoing" : "incoming") },
      !isByMe && !chainBottom && renderSenderProfile(__assign(__assign({}, props), { className: "sendbird-thread-list-item-content__left__avatar", isByMe, displayThreadReplies: false })),
      isByMe && !isMobile && import_react36.default.createElement(
        "div",
        { className: classnames("sendbird-thread-list-item-content-menu", isReactionEnabledInChannel && "use-reaction", isByMe ? "outgoing" : "incoming", supposedHoverClassName) },
        renderMessageMenu({
          className: "sendbird-thread-list-item-content-menu__normal-menu",
          channel,
          message,
          isByMe,
          replyType,
          showEdit,
          showRemove,
          resendMessage,
          onReplyInThread,
          deleteMessage
        }),
        isReactionEnabledInChannel && import_react36.default.createElement(import_react36.default.Fragment, null, renderEmojiMenu({
          className: "sendbird-thread-list-item-content-menu__reaction-menu",
          message,
          userId,
          emojiContainer,
          toggleReaction,
          filterEmojiCategoryIds
        }))
      )
    ),
    import_react36.default.createElement(
      "div",
      __assign({ className: "sendbird-thread-list-item-content__middle" }, isMobile ? __assign({}, longPress) : {}),
      !isByMe && !chainTop && !useReplying && renderMessageHeader(props),
      import_react36.default.createElement(
        "div",
        { className: getClassName(["sendbird-thread-list-item-content__middle__body-container"]) },
        isByMe && !chainBottom && import_react36.default.createElement(
          "div",
          { className: getClassName(["sendbird-thread-list-item-content__middle__body-container__created-at", "left", supposedHoverClassName]) },
          import_react36.default.createElement(
            "div",
            { className: "sendbird-thread-list-item-content__middle__body-container__created-at__component-container" },
            import_react36.default.createElement(MessageStatus, { message, channel })
          )
        ),
        renderMessageBody({
          className: "sendbird-thread-list-item-content__middle__message-item-body",
          message,
          channel,
          showFileViewer,
          mouseHover: false,
          isMobile,
          config,
          isReactionEnabledInChannel,
          isByMe,
          onBeforeDownloadFileMessage,
          /** This is for internal customization to keep the legacy */
          customSubcomponentsProps: {
            ThumbnailMessageItemBody: {
              style: {
                width: isMobile ? "100%" : "200px",
                height: "148px"
              }
            },
            MultipleFilesMessageItemBody: {
              threadMessageKindKey,
              statefulFileInfoList
            }
          }
          // TODO: Support these props in Thread
          // onMessageHeightChange,
          // onTemplateMessageRenderedCallback,
        }),
        isReactionEnabledInChannel && ((_c = message === null || message === void 0 ? void 0 : message.reactions) === null || _c === void 0 ? void 0 : _c.length) > 0 && import_react36.default.createElement("div", { className: getClassName([
          "sendbird-thread-list-item-content-reactions",
          !isByMe || isThumbnailMessage(message) || isOgMessageEnabledInGroupChannel && isOGMessage(message) || isMultipleFilesMessage(message) ? "" : "primary"
        ]) }, renderEmojiReactions({
          userId,
          message,
          channel,
          isByMe,
          emojiContainer,
          memberNicknamesMap: nicknamesMap,
          toggleReaction,
          onPressUserProfile: onPressUserProfileHandler,
          filterEmojiCategoryIds
        })),
        !isByMe && !chainBottom && import_react36.default.createElement(Label, { className: getClassName(["sendbird-thread-list-item-content__middle__body-container__created-at", "right", supposedHoverClassName]), type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, format((message === null || message === void 0 ? void 0 : message.createdAt) || 0, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, {
          locale: dateLocale
        }))
      )
    ),
    import_react36.default.createElement("div", { className: classnames("sendbird-thread-list-item-content__right", chainTop && "chain-top", isByMe ? "outgoing" : "incoming") }, !isByMe && !isMobile && import_react36.default.createElement(
      "div",
      { className: "sendbird-thread-list-item-content-menu ".concat(supposedHoverClassName) },
      isReactionEnabledInChannel && renderEmojiMenu({
        className: "sendbird-thread-list-item-content-menu__reaction-menu",
        message,
        userId,
        emojiContainer,
        toggleReaction,
        filterEmojiCategoryIds
      }),
      renderMessageMenu({
        className: "sendbird-thread-list-item-content-menu__normal-menu",
        channel,
        message,
        isByMe,
        replyType,
        showRemove,
        resendMessage,
        onReplyInThread,
        deleteMessage
      })
    )),
    showMobileMenu && renderMobileMenuOnLongPress({
      parentRef: mobileMenuRef,
      channel,
      message,
      userId,
      replyType,
      hideMenu: function() {
        setShowMobileMenu(false);
      },
      isReactionEnabled,
      isByMe,
      emojiContainer,
      showEdit,
      showRemove,
      toggleReaction,
      isOpenedFromThread: true,
      deleteMessage,
      onDownloadClick: function(e) {
        return __awaiter(_this, void 0, void 0, function() {
          var allowDownload, err_1;
          var _a2, _b2;
          return __generator(this, function(_c2) {
            switch (_c2.label) {
              case 0:
                if (!onBeforeDownloadFileMessage)
                  return [
                    2
                    /*return*/
                  ];
                _c2.label = 1;
              case 1:
                _c2.trys.push([1, 3, , 4]);
                return [4, onBeforeDownloadFileMessage({ message })];
              case 2:
                allowDownload = _c2.sent();
                if (!allowDownload) {
                  e.preventDefault();
                  (_a2 = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "ThreadListItemContent: Not allowed to download.");
                }
                return [3, 4];
              case 3:
                err_1 = _c2.sent();
                (_b2 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b2 === void 0 ? void 0 : _b2.call(logger, "ThreadListItemContent: Error occurred while determining download continuation:", err_1);
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
    })
  );
}
function ThreadListItem(props) {
  var _this = this;
  var _a, _b, _c, _d;
  var className = props.className, message = props.message, chainTop = props.chainTop, chainBottom = props.chainBottom, hasSeparator = props.hasSeparator, renderCustomSeparator = props.renderCustomSeparator, handleScroll = props.handleScroll;
  var _e = useSendbird().state, stores = _e.stores, config = _e.config;
  var isOnline = config.isOnline, userMention = config.userMention, logger = config.logger, groupChannel = config.groupChannel;
  var userId = (_b = (_a = stores === null || stores === void 0 ? void 0 : stores.userStore) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.userId;
  var _f = useLocalization(), dateLocale = _f.dateLocale, stringSet = _f.stringSet;
  var _g = useThread(), _h = _g.state, openingMessage = _h.message, currentChannel = _h.currentChannel, nicknamesMap = _h.nicknamesMap, emojiContainer = _h.emojiContainer, threadListState = _h.threadListState, isMuted = _h.isMuted, isChannelFrozen = _h.isChannelFrozen, onBeforeDownloadFileMessage = _h.onBeforeDownloadFileMessage, _j = _g.actions, toggleReaction = _j.toggleReaction, updateMessage = _j.updateMessage, resendMessage = _j.resendMessage, deleteMessage = _j.deleteMessage;
  var _k = (0, import_react36.useState)(false), showEdit = _k[0], setShowEdit = _k[1];
  var _l = (0, import_react36.useState)(false), showRemove = _l[0], setShowRemove = _l[1];
  var _m = (0, import_react36.useState)(false), showFileViewer = _m[0], setShowFileViewer = _m[1];
  var isReactionEnabled = getIsReactionEnabled({
    channel: currentChannel,
    config
  });
  var isMentionEnabled = groupChannel.enableMention;
  var replyType = getCaseResolvedReplyType(groupChannel.replyType).upperCase;
  var messageScrollRef = (0, import_react36.useRef)(null);
  (0, import_react36.useLayoutEffect)(function() {
    var _a2;
    if ((openingMessage === null || openingMessage === void 0 ? void 0 : openingMessage.messageId) === (message === null || message === void 0 ? void 0 : message.messageId) && (messageScrollRef === null || messageScrollRef === void 0 ? void 0 : messageScrollRef.current)) {
      (_a2 = messageScrollRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollIntoView({ block: "center", inline: "center" });
    }
  }, [openingMessage, messageScrollRef === null || messageScrollRef === void 0 ? void 0 : messageScrollRef.current]);
  (0, import_react36.useLayoutEffect)(function() {
    handleScroll === null || handleScroll === void 0 ? void 0 : handleScroll();
  }, [showEdit, (_c = message === null || message === void 0 ? void 0 : message.reactions) === null || _c === void 0 ? void 0 : _c.length]);
  var editMessageInputRef = (0, import_react36.useRef)(null);
  var _o = (0, import_react36.useState)(""), mentionNickname = _o[0], setMentionNickname = _o[1];
  var _p = (0, import_react36.useState)([]), mentionedUsers = _p[0], setMentionedUsers = _p[1];
  var _q = (0, import_react36.useState)([]), mentionedUserIds = _q[0], setMentionedUserIds = _q[1];
  var _r = (0, import_react36.useState)(null), messageInputEvent = _r[0], setMessageInputEvent = _r[1];
  var _s = (0, import_react36.useState)(null), selectedUser = _s[0], setSelectedUser = _s[1];
  var _t = (0, import_react36.useState)([]), mentionSuggestedUsers = _t[0], setMentionSuggestedUsers = _t[1];
  var displaySuggestedMentionList = isOnline && isMentionEnabled && mentionNickname.length > 0 && !isMuted && !(isChannelFrozen && !(currentChannel.myRole === Role.OPERATOR));
  var mentionNodes = useDirtyGetMentions({ ref: editMessageInputRef }, { logger });
  var ableMention = (mentionNodes === null || mentionNodes === void 0 ? void 0 : mentionNodes.length) < (userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount);
  (0, import_react36.useEffect)(function() {
    setMentionedUsers(mentionedUsers.filter(function(_a2) {
      var userId2 = _a2.userId;
      var i = mentionedUserIds.indexOf(userId2);
      if (i < 0) {
        return false;
      } else {
        mentionedUserIds.splice(i, 1);
        return true;
      }
    }));
  }, [mentionedUserIds]);
  var disabled = !(threadListState === ThreadListStateTypes.INITIALIZED) || !isOnline || isMuted || isChannelFrozen;
  var MemorizedSeparator = (0, import_react36.useMemo)(function() {
    if (typeof renderCustomSeparator === "function") {
      return renderCustomSeparator === null || renderCustomSeparator === void 0 ? void 0 : renderCustomSeparator({ message });
    }
  }, [message, renderCustomSeparator]);
  if (showEdit && message.isUserMessage()) {
    return import_react36.default.createElement(
      import_react36.default.Fragment,
      null,
      displaySuggestedMentionList && import_react36.default.createElement(SuggestedMentionList, {
        targetNickname: mentionNickname,
        inputEvent: messageInputEvent !== null && messageInputEvent !== void 0 ? messageInputEvent : void 0,
        // renderUserMentionItem={renderUserMentionItem}
        onUserItemClick: function(user) {
          if (user) {
            setMentionedUsers(__spreadArray(__spreadArray([], mentionedUsers, true), [user], false));
          }
          setMentionNickname("");
          setSelectedUser(user);
          setMessageInputEvent(null);
        },
        onFocusItemChange: function() {
          setMessageInputEvent(null);
        },
        onFetchUsers: function(users) {
          setMentionSuggestedUsers(users);
        },
        ableAddMention: ableMention,
        maxMentionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxMentionCount,
        maxSuggestionCount: userMention === null || userMention === void 0 ? void 0 : userMention.maxSuggestionCount
      }),
      import_react36.default.createElement(MessageInput, { isEdit: true, channel: currentChannel, disabled, ref: editMessageInputRef, mentionSelectedUser: selectedUser, isMentionEnabled, message, onStartTyping: function() {
        var _a2;
        (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.startTyping) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel);
      }, onUpdateMessage: function(_a2) {
        var _b2;
        var messageId = _a2.messageId, message2 = _a2.message, mentionTemplate = _a2.mentionTemplate;
        updateMessage({
          messageId,
          message: message2,
          mentionedUsers,
          mentionTemplate
        });
        setShowEdit(false);
        (_b2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.endTyping) === null || _b2 === void 0 ? void 0 : _b2.call(currentChannel);
      }, onCancelEdit: function() {
        var _a2;
        setMentionNickname("");
        setMentionedUsers([]);
        setMentionedUserIds([]);
        setMentionSuggestedUsers([]);
        setShowEdit(false);
        (_a2 = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.endTyping) === null || _a2 === void 0 ? void 0 : _a2.call(currentChannel);
      }, onUserMentioned: function(user) {
        if ((selectedUser === null || selectedUser === void 0 ? void 0 : selectedUser.userId) === (user === null || user === void 0 ? void 0 : user.userId)) {
          setSelectedUser(null);
          setMentionNickname("");
        }
      }, onMentionStringChange: function(mentionText) {
        setMentionNickname(mentionText);
      }, onMentionedUserIdsUpdated: function(userIds) {
        setMentionedUserIds(userIds);
      }, onKeyDown: function(e) {
        if (displaySuggestedMentionList && (mentionSuggestedUsers === null || mentionSuggestedUsers === void 0 ? void 0 : mentionSuggestedUsers.length) > 0 && (e.key === MessageInputKeys.Enter && ableMention || e.key === MessageInputKeys.ArrowUp || e.key === MessageInputKeys.ArrowDown)) {
          setMessageInputEvent(e);
          return true;
        }
        return false;
      } })
    );
  }
  return import_react36.default.createElement(
    "div",
    { ref: messageScrollRef, className: classnames("sendbird-thread-list-item", className), "data-testid": "sendbird-thread-list-item" },
    hasSeparator && (message === null || message === void 0 ? void 0 : message.createdAt) && (MemorizedSeparator || import_react36.default.createElement(
      DateSeparator,
      null,
      import_react36.default.createElement(Label, { type: LabelTypography.CAPTION_2, color: LabelColors.ONBACKGROUND_2 }, format(message === null || message === void 0 ? void 0 : message.createdAt, stringSet.DATE_FORMAT__THREAD_LIST__DATE_SEPARATOR, { locale: dateLocale }))
    )),
    import_react36.default.createElement(ThreadListItemContent, __assign({}, props, { userId, channel: currentChannel, message, chainTop, chainBottom, isReactionEnabled, disableQuoteMessage: true, replyType, nicknamesMap, emojiContainer, resendMessage, showRemove: setShowRemove, showFileViewer: setShowFileViewer, toggleReaction, showEdit: setShowEdit })),
    showRemove && import_react36.default.createElement(RemoveMessage, { message, onCancel: function() {
      return setShowRemove(false);
    } }),
    showFileViewer && import_react36.default.createElement(FileViewer, { message, isByMe: ((_d = message === null || message === void 0 ? void 0 : message.sender) === null || _d === void 0 ? void 0 : _d.userId) === userId, onClose: function() {
      return setShowFileViewer(false);
    }, onDelete: function() {
      deleteMessage(message);
      setShowFileViewer(false);
    }, onDownloadClick: function(e) {
      return __awaiter(_this, void 0, void 0, function() {
        var allowDownload, err_1;
        var _a2, _b2;
        return __generator(this, function(_c2) {
          switch (_c2.label) {
            case 0:
              if (!onBeforeDownloadFileMessage)
                return [
                  2
                  /*return*/
                ];
              _c2.label = 1;
            case 1:
              _c2.trys.push([1, 3, , 4]);
              return [4, onBeforeDownloadFileMessage({ message })];
            case 2:
              allowDownload = _c2.sent();
              if (!allowDownload) {
                e.preventDefault();
                (_a2 = logger.info) === null || _a2 === void 0 ? void 0 : _a2.call(logger, "ThreadListItem: Not allowed to download.");
              }
              return [3, 4];
            case 3:
              err_1 = _c2.sent();
              (_b2 = logger.error) === null || _b2 === void 0 ? void 0 : _b2.call(logger, "ThreadListItem: Error occurred while determining download continuation:", err_1);
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    } })
  );
}

// node_modules/@sendbird/uikit-react/Thread/components/ThreadList.js
var import_react37 = __toESM(require_react(), 1);
var import_react_dom18 = __toESM(require_react_dom(), 1);
function ThreadList(_a) {
  var className = _a.className, _b = _a.renderMessage, renderMessage = _b === void 0 ? function(props) {
    return import_react37.default.createElement(ThreadListItem, __assign({}, props));
  } : _b, renderCustomSeparator = _a.renderCustomSeparator, scrollRef = _a.scrollRef, scrollBottom = _a.scrollBottom;
  var config = useSendbird().state.config;
  var stringSet = useLocalization().stringSet;
  var userId = config.userId;
  var _c = useThread().state, currentChannel = _c.currentChannel, allThreadMessages = _c.allThreadMessages, localThreadMessages = _c.localThreadMessages;
  return import_react37.default.createElement(
    "div",
    { className: "sendbird-thread-list ".concat(className) },
    allThreadMessages.map(function(message, idx) {
      var _a2;
      var isByMe = ((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId) === userId;
      var prevMessage = allThreadMessages[idx - 1];
      var nextMessage = allThreadMessages[idx + 1];
      var _b2 = compareMessagesForGrouping(prevMessage, message, nextMessage, stringSet, currentChannel, getCaseResolvedReplyType(config.groupChannel.replyType).upperCase), chainTop = _b2[0], chainBottom = _b2[1];
      var hasSeparator = !((prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.createdAt) > 0 && isSameDay2(message === null || message === void 0 ? void 0 : message.createdAt, prevMessage === null || prevMessage === void 0 ? void 0 : prevMessage.createdAt));
      var handleScroll = function() {
        var current = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;
        if (current && scrollBottom) {
          var bottom = current.scrollHeight - current.scrollTop - current.offsetHeight;
          if (scrollBottom < bottom) {
            current.scrollTop += bottom - scrollBottom;
          }
        }
      };
      return import_react37.default.createElement(MessageProvider, { message, isByMe, key: message === null || message === void 0 ? void 0 : message.messageId }, renderMessage({
        message,
        chainTop,
        chainBottom,
        hasSeparator,
        renderCustomSeparator,
        handleScroll
      }));
    }),
    localThreadMessages.map(function(message) {
      var _a2;
      var isByMe = ((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId) === userId;
      var handleScroll = function() {
        var current = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;
        if (current) {
          var bottom = current.scrollHeight - current.scrollTop - current.offsetHeight;
          if (scrollBottom < bottom) {
            current.scrollTop += bottom - scrollBottom;
          }
        }
      };
      return import_react37.default.createElement(MessageProvider, { message, isByMe, key: message === null || message === void 0 ? void 0 : message.messageId }, renderMessage({
        message,
        hasSeparator: false,
        renderCustomSeparator,
        handleScroll
      }));
    })
  );
}

// node_modules/@sendbird/uikit-react/Thread/components/ThreadUI.js
var import_react38 = __toESM(require_react(), 1);
var import_react_dom19 = __toESM(require_react_dom(), 1);
var useMemorizedHeader = function(_a) {
  var renderHeader = _a.renderHeader;
  return (0, import_react38.useMemo)(function() {
    if (typeof renderHeader === "function") {
      return renderHeader();
    }
    return null;
  }, [renderHeader]);
};
var useMemorizedParentMessageInfo = function(_a) {
  var parentMessage = _a.parentMessage, parentMessageState = _a.parentMessageState, renderParentMessageInfo = _a.renderParentMessageInfo, renderParentMessageInfoPlaceholder = _a.renderParentMessageInfoPlaceholder;
  return (0, import_react38.useMemo)(function() {
    if (parentMessageState === ParentMessageStateTypes.NIL || parentMessageState === ParentMessageStateTypes.LOADING || parentMessageState === ParentMessageStateTypes.INVALID) {
      if (typeof renderParentMessageInfoPlaceholder === "function") {
        return renderParentMessageInfoPlaceholder(parentMessageState);
      }
      switch (parentMessageState) {
        case ParentMessageStateTypes.NIL: {
          return import_react38.default.createElement(PlaceHolder, { className: "sendbird-thread-ui__parent-message-info placeholder-nil", type: PlaceHolderTypes.NO_RESULTS, iconSize: "64px" });
        }
        case ParentMessageStateTypes.LOADING: {
          return import_react38.default.createElement(PlaceHolder, { className: "sendbird-thread-ui__parent-message-info placeholder-loading", type: PlaceHolderTypes.LOADING, iconSize: "64px" });
        }
        case ParentMessageStateTypes.INVALID: {
          return import_react38.default.createElement(PlaceHolder, { className: "sendbird-thread-ui__parent-message-info placeholder-invalid", type: PlaceHolderTypes.WRONG, iconSize: "64px" });
        }
        default: {
          return null;
        }
      }
    } else if (parentMessageState === ParentMessageStateTypes.INITIALIZED) {
      if (typeof renderParentMessageInfo === "function") {
        return renderParentMessageInfo();
      }
    }
    return null;
  }, [
    parentMessage,
    parentMessageState,
    renderParentMessageInfo,
    renderParentMessageInfoPlaceholder
  ]);
};
var useMemorizedThreadList = function(_a) {
  var threadListState = _a.threadListState, renderThreadListPlaceHolder = _a.renderThreadListPlaceHolder;
  return (0, import_react38.useMemo)(function() {
    if (threadListState === ThreadListStateTypes.NIL || threadListState === ThreadListStateTypes.LOADING || threadListState === ThreadListStateTypes.INVALID) {
      if (typeof renderThreadListPlaceHolder === "function") {
        return renderThreadListPlaceHolder(threadListState);
      }
      switch (threadListState) {
        case ThreadListStateTypes.LOADING: {
          return import_react38.default.createElement(PlaceHolder, { className: "sendbird-thread-ui__thread-list placeholder-loading", type: PlaceHolderTypes.LOADING, iconSize: "64px" });
        }
        case ThreadListStateTypes.INVALID: {
          return import_react38.default.createElement(PlaceHolder, { className: "sendbird-thread-ui__thread-list placeholder-invalid", type: PlaceHolderTypes.WRONG, iconSize: "64px" });
        }
        case ThreadListStateTypes.NIL: {
          return import_react38.default.createElement(import_react38.default.Fragment, null);
        }
        default: {
          return null;
        }
      }
    }
    return null;
  }, [
    threadListState,
    renderThreadListPlaceHolder
  ]);
};
var ThreadUI = function(_a) {
  var _b, _c, _d, _e;
  var renderHeader = _a.renderHeader, _f = _a.renderParentMessageInfo, renderParentMessageInfo = _f === void 0 ? function() {
    return import_react38.default.createElement(ParentMessageInfo, { className: "sendbird-thread-ui__parent-message-info" });
  } : _f, renderMessage = _a.renderMessage, renderMessageInput = _a.renderMessageInput, renderCustomSeparator = _a.renderCustomSeparator, renderParentMessageInfoPlaceholder = _a.renderParentMessageInfoPlaceholder, renderThreadListPlaceHolder = _a.renderThreadListPlaceHolder, renderFileUploadIcon = _a.renderFileUploadIcon, renderVoiceMessageIcon = _a.renderVoiceMessageIcon, renderSendMessageIcon = _a.renderSendMessageIcon;
  var _g = useSendbird().state, stores = _g.stores, config = _g.config;
  var currentUserId = (_d = (_c = (_b = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk) === null || _c === void 0 ? void 0 : _c.currentUser) === null || _d === void 0 ? void 0 : _d.userId;
  var stringSet = useLocalization().stringSet;
  var _h = useThread(), _j = _h.state, currentChannel = _j.currentChannel, allThreadMessages = _j.allThreadMessages, parentMessage = _j.parentMessage, parentMessageState = _j.parentMessageState, threadListState = _j.threadListState, hasMorePrev = _j.hasMorePrev, hasMoreNext = _j.hasMoreNext, onHeaderActionClick = _j.onHeaderActionClick, onMoveToParentMessage = _j.onMoveToParentMessage, _k = _h.actions, fetchPrevThreads = _k.fetchPrevThreads, fetchNextThreads = _k.fetchNextThreads;
  var replyCount = allThreadMessages.length;
  var isByMe = currentUserId === ((_e = parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.sender) === null || _e === void 0 ? void 0 : _e.userId);
  var MemorizedHeader = useMemorizedHeader({ renderHeader });
  var MemorizedParentMessageInfo = useMemorizedParentMessageInfo({
    parentMessage,
    parentMessageState,
    renderParentMessageInfo,
    renderParentMessageInfoPlaceholder
  });
  var MemorizedThreadList = useMemorizedThreadList({
    threadListState,
    renderThreadListPlaceHolder
  });
  var _l = (0, import_react38.useState)(0), scrollBottom = _l[0], setScrollBottom = _l[1];
  var scrollRef = (0, import_react38.useRef)(null);
  var onScroll = function(e) {
    var _a2;
    var element = e.target;
    var scrollTop = element.scrollTop, clientHeight = element.clientHeight, scrollHeight = element.scrollHeight;
    var threadItemNodes = (_a2 = scrollRef.current) === null || _a2 === void 0 ? void 0 : _a2.querySelectorAll(".sendbird-thread-list-item");
    var firstNode = threadItemNodes === null || threadItemNodes === void 0 ? void 0 : threadItemNodes[0];
    if (isAboutSame2(scrollTop, 0, 10) && hasMorePrev) {
      fetchPrevThreads(function(messages) {
        var _a3;
        if (messages) {
          try {
            (_a3 = firstNode === null || firstNode === void 0 ? void 0 : firstNode.scrollIntoView) === null || _a3 === void 0 ? void 0 : _a3.call(firstNode, { block: "start", inline: "nearest" });
          } catch (error) {
          }
        }
      });
    }
    if (isAboutSame2(clientHeight + scrollTop, scrollHeight, 10) && hasMoreNext) {
      var scrollTop_1 = scrollTop;
      fetchNextThreads(function(messages) {
        if (messages) {
          try {
            element.scrollTop = scrollTop_1;
            if (scrollRef.current) {
              scrollRef.current.scrollTop = scrollTop_1;
            }
          } catch (error) {
          }
        }
      });
    }
    if (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) {
      var current = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;
      setScrollBottom(current.scrollHeight - current.scrollTop - current.offsetHeight);
    }
  };
  return import_react38.default.createElement(
    "div",
    { className: "sendbird-thread-ui" },
    MemorizedHeader || import_react38.default.createElement(ThreadHeader, { className: "sendbird-thread-ui__header", channelName: getChannelTitle(currentChannel, currentUserId !== null && currentUserId !== void 0 ? currentUserId : "", stringSet), onActionIconClick: onHeaderActionClick, onChannelNameClick: function() {
      onMoveToParentMessage === null || onMoveToParentMessage === void 0 ? void 0 : onMoveToParentMessage({ message: parentMessage, channel: currentChannel });
    } }),
    import_react38.default.createElement(
      "div",
      { className: classnames("sendbird-thread-ui--scroll", "sendbird-conversation__messages"), ref: scrollRef, onScroll, dir: getHTMLTextDirection(config === null || config === void 0 ? void 0 : config.htmlTextDirection, config === null || config === void 0 ? void 0 : config.forceLeftToRightMessageLayout) },
      import_react38.default.createElement(MessageProvider, { message: parentMessage, isByMe }, MemorizedParentMessageInfo),
      replyCount > 0 && import_react38.default.createElement(
        "div",
        { className: "sendbird-thread-ui__reply-counts" },
        import_react38.default.createElement(Label, { type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_3 }, "".concat(replyCount, " ").concat(replyCount > 1 ? stringSet.THREAD__THREAD_REPLIES : stringSet.THREAD__THREAD_REPLY))
      ),
      MemorizedThreadList || import_react38.default.createElement(ThreadList, { className: "sendbird-thread-ui__thread-list", renderMessage, renderCustomSeparator, scrollRef, scrollBottom })
    ),
    (renderMessageInput === null || renderMessageInput === void 0 ? void 0 : renderMessageInput()) || import_react38.default.createElement(ThreadMessageInput$1, { className: "sendbird-thread-ui__message-input", renderFileUploadIcon, renderVoiceMessageIcon, renderSendMessageIcon })
  );
};

// node_modules/@sendbird/uikit-react/Thread.js
var import_react39 = __toESM(require_react(), 1);
var import_react_dom20 = __toESM(require_react_dom(), 1);
var Thread = function(props) {
  var _a;
  return import_react39.default.createElement(
    "div",
    { className: classnames("sendbird-thread", (_a = props === null || props === void 0 ? void 0 : props.className) !== null && _a !== void 0 ? _a : "") },
    import_react39.default.createElement(
      ThreadProvider,
      __assign({}, props),
      import_react39.default.createElement(ThreadUI, __assign({}, props))
    )
  );
};

// node_modules/@sendbird/uikit-react/chunks/bundle-BhCmYlZ1.js
var import_react40 = __toESM(require_react(), 1);
var shouldFetchMore = function(messageLength, maxMessages) {
  if (typeof maxMessages !== "number") {
    return true;
  }
  return maxMessages > messageLength;
};
var scrollIntoLast2 = function(initialTry, scrollRef) {
  if (initialTry === void 0) {
    initialTry = 0;
  }
  var MAX_TRIES = 10;
  if (initialTry > MAX_TRIES) {
    return;
  }
  var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector(".sendbird-openchannel-conversation-scroll__container__item-container");
  if (scrollDOM) {
    var applyScroll = function() {
      scrollDOM.style.overflow = "auto";
      scrollDOM.scrollTop = scrollDOM.scrollHeight;
    };
    setTimeout(applyScroll);
  } else {
    setTimeout(function() {
      scrollIntoLast2(initialTry + 1, scrollRef);
    }, 500 * initialTry);
  }
};
var kFormatter = function(num) {
  if (Math.abs(num) > 999999) {
    return "".concat((Math.abs(num) / 1e6).toFixed(1), "M");
  }
  if (Math.abs(num) > 999) {
    return "".concat((Math.abs(num) / 1e3).toFixed(1), "K");
  }
  return "".concat(num);
};
var isOperator = function(openChannel, userId) {
  var operators = openChannel === null || openChannel === void 0 ? void 0 : openChannel.operators;
  if (operators.map(function(operator) {
    return operator.userId;
  }).indexOf(userId) < 0) {
    return false;
  }
  return true;
};
var isDisabledBecauseFrozen3 = function(openChannel, userId) {
  if (!openChannel)
    return false;
  var isFrozen = openChannel.isFrozen;
  return isFrozen && !isOperator(openChannel, userId);
};
var isDisabledBecauseMuted3 = function(mutedParticipantIds, userId) {
  return mutedParticipantIds.indexOf(userId) > -1;
};
var fetchWithListQuery = function(listQuery, logger, eachQueryNextCallback) {
  var fetchList = function(query) {
    var hasNext = query.hasNext;
    if (hasNext) {
      query.next().then(function(users) {
        eachQueryNextCallback(users);
        fetchList(query);
      }).catch(function(error) {
        logger.warning("OpenChannel | FetchUserList failed", error);
      });
    } else {
      logger.info("OpenChannel | FetchUserList finished");
    }
  };
  logger.info("OpenChannel | FetchUserList start", listQuery);
  fetchList(listQuery);
};
var SET_CURRENT_CHANNEL2 = "SET_CURRENT_CHANNEL";
var SET_CHANNEL_INVALID = "SET_CHANNEL_INVALID";
var RESET_MESSAGES = "RESET_MESSAGES";
var EXIT_CURRENT_CHANNEL = "EXIT_CURRENT_CHANNEL";
var GET_PREV_MESSAGES_START = "GET_PREV_MESSAGES_START";
var GET_PREV_MESSAGES_SUCESS = "GET_PREV_MESSAGES_SUCESS";
var GET_PREV_MESSAGES_FAIL = "GET_PREV_MESSAGES_FAIL";
var SENDING_MESSAGE_FAILED = "SENDING_MESSAGE_FAILED";
var SENDING_MESSAGE_SUCCEEDED = "SENDING_MESSAGE_SUCCEEDED";
var SENDING_MESSAGE_START = "SENDING_MESSAGE_START";
var RESENDING_MESSAGE_START = "RESENDING_MESSAGE_START";
var FETCH_PARTICIPANT_LIST = "FETCH_PARTICIPANT_LIST";
var FETCH_BANNED_USER_LIST = "FETCH_BANNED_USER_LIST";
var FETCH_MUTED_USER_LIST = "FETCH_MUTED_USER_LIST";
var TRIM_MESSAGE_LIST = "TRIM_MESSAGE_LIST";
var ON_MESSAGE_RECEIVED = "ON_MESSAGE_RECEIVED";
var ON_MESSAGE_UPDATED = "ON_MESSAGE_UPDATED";
var ON_MESSAGE_DELETED = "ON_MESSAGE_DELETED";
var ON_MESSAGE_DELETED_BY_REQ_ID = "ON_MESSAGE_DELETED_BY_REQ_ID";
var ON_OPERATOR_UPDATED = "ON_OPERATOR_UPDATED";
var ON_USER_ENTERED = "ON_USER_ENTERED";
var ON_USER_EXITED = "ON_USER_EXITED";
var ON_USER_MUTED = "ON_USER_MUTED";
var ON_USER_UNMUTED = "ON_USER_UNMUTED";
var ON_USER_BANNED = "ON_USER_BANNED";
var ON_USER_UNBANNED = "ON_USER_UNBANNED";
var ON_CHANNEL_FROZEN2 = "ON_CHANNEL_FROZEN";
var ON_CHANNEL_UNFROZEN2 = "ON_CHANNEL_UNFROZEN";
var ON_CHANNEL_CHANGED2 = "ON_CHANNEL_CHANGED";
var ON_CHANNEL_DELETED2 = "ON_CHANNEL_DELETED";
var ON_META_DATA_CREATED = "ON_META_DATA_CREATED";
var ON_META_DATA_UPDATED = "ON_META_DATA_UPDATED";
var ON_META_DATA_DELETED = "ON_META_DATA_DELETED";
var ON_META_COUNTERS_CREATED = "ON_META_COUNTERS_CREATED";
var ON_META_COUNTERS_UPDATED = "ON_META_COUNTERS_UPDATED";
var ON_META_COUNTERS_DELETED = "ON_META_COUNTERS_DELETED";
var ON_MENTION_RECEIVED = "ON_MENTION_RECEIVED";
function reducer(state, action) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  switch (action.type) {
    case RESET_MESSAGES: {
      return __assign(__assign({}, state), { allMessages: [] });
    }
    case EXIT_CURRENT_CHANNEL: {
      if (((_a = action.payload) === null || _a === void 0 ? void 0 : _a.url) === ((_b = state.currentOpenChannel) === null || _b === void 0 ? void 0 : _b.url)) {
        return __assign(__assign({}, state), { currentOpenChannel: null });
      }
      return state;
    }
    case SET_CURRENT_CHANNEL2: {
      var gottenChannel = action.payload;
      var operators = gottenChannel.operators;
      if (!state.isInvalid && state.currentOpenChannel && state.currentOpenChannel.url && state.currentOpenChannel.url === gottenChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { currentOpenChannel: gottenChannel, isInvalid: false, operators, participants: operators, bannedParticipantIds: [], mutedParticipantIds: [] });
    }
    case SET_CHANNEL_INVALID: {
      return __assign(__assign({}, state), { isInvalid: true });
    }
    case GET_PREV_MESSAGES_START: {
      return __assign(__assign({}, state), { loading: true });
    }
    case GET_PREV_MESSAGES_SUCESS:
    case GET_PREV_MESSAGES_FAIL: {
      var isFailed = action.type === GET_PREV_MESSAGES_FAIL;
      var _j = action.payload, _k = _j.currentOpenChannel, currentOpenChannel = _k === void 0 ? {} : _k, _l = _j.messages, messages = _l === void 0 ? [] : _l, hasMore = _j.hasMore, lastMessageTimestamp = _j.lastMessageTimestamp;
      var actionChannelUrl = currentOpenChannel.url;
      var receivedMessages_1 = isFailed ? [] : messages;
      var _hasMore = isFailed ? false : hasMore;
      var _lastMessageTimestamp = isFailed ? 0 : lastMessageTimestamp;
      var stateChannel = state.currentOpenChannel;
      var stateChannelUrl = stateChannel === null || stateChannel === void 0 ? void 0 : stateChannel.url;
      if (actionChannelUrl !== stateChannelUrl) {
        return state;
      }
      var filteredAllMessages = state.allMessages.filter(function(message) {
        return !receivedMessages_1.find(function(_a2) {
          var messageId = _a2.messageId;
          return compareIds(messageId, message.messageId);
        });
      });
      return __assign(__assign({}, state), { loading: false, initialized: true, hasMore: _hasMore, lastMessageTimestamp: _lastMessageTimestamp, allMessages: __spreadArray(__spreadArray([], receivedMessages_1, true), filteredAllMessages, true) });
    }
    case SENDING_MESSAGE_START: {
      var _m = action.payload, message_1 = _m.message, channel = _m.channel;
      if ((channel === null || channel === void 0 ? void 0 : channel.url) !== ((_c = state.currentOpenChannel) === null || _c === void 0 ? void 0 : _c.url) || state.allMessages.some(function(m) {
        return m.reqId === message_1.reqId;
      })) {
        return state;
      }
      return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [
        message_1
      ], false) });
    }
    case SENDING_MESSAGE_SUCCEEDED: {
      var sentMessage_1 = action.payload;
      var newMessages = state.allMessages.map(function(m) {
        return compareIds(m.reqId, sentMessage_1.reqId) ? sentMessage_1 : m;
      });
      return __assign(__assign({}, state), { allMessages: newMessages });
    }
    case SENDING_MESSAGE_FAILED: {
      var sentMessage_2 = action.payload;
      sentMessage_2.sendingStatus = "failed";
      if (!state.allMessages.some(function(m) {
        return (m === null || m === void 0 ? void 0 : m.reqId) === (sentMessage_2 === null || sentMessage_2 === void 0 ? void 0 : sentMessage_2.reqId);
      })) {
        return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages.filter(function(m) {
          return !compareIds(m.reqId, sentMessage_2);
        }), true), [
          sentMessage_2
        ], false) });
      } else {
        return __assign(__assign({}, state), { allMessages: state.allMessages.map(function(m) {
          return compareIds(m.reqId, sentMessage_2.reqId) ? sentMessage_2 : m;
        }) });
      }
    }
    case TRIM_MESSAGE_LIST: {
      var allMessages = state.allMessages;
      var messageLimit = (_d = action.payload) === null || _d === void 0 ? void 0 : _d.messageLimit;
      if (messageLimit && messageLimit > 0 && (allMessages === null || allMessages === void 0 ? void 0 : allMessages.length) > messageLimit) {
        var sliceAt = allMessages.length - messageLimit;
        return __assign(__assign({}, state), { allMessages: allMessages.slice(sliceAt) });
      }
      return state;
    }
    case RESENDING_MESSAGE_START: {
      var eventedChannel = action.payload.channel;
      var resentMessage_1 = action.payload.message;
      if (eventedChannel.url !== ((_e = state.currentOpenChannel) === null || _e === void 0 ? void 0 : _e.url)) {
        return state;
      }
      return __assign(__assign({}, state), { allMessages: state.allMessages.map(function(m) {
        return compareIds(m.reqId, resentMessage_1.reqId) ? resentMessage_1 : m;
      }) });
    }
    case FETCH_PARTICIPANT_LIST: {
      var eventedChannel = action.payload.channel;
      var fetchedParticipantList = action.payload.users;
      if (eventedChannel.url !== ((_f = state.currentOpenChannel) === null || _f === void 0 ? void 0 : _f.url)) {
        return state;
      }
      return __assign(__assign({}, state), { participants: __spreadArray(__spreadArray([], state.participants, true), fetchedParticipantList, true) });
    }
    case FETCH_BANNED_USER_LIST: {
      var eventedChannel = action.payload.channel;
      var fetchedBannedUserList = action.payload.users;
      if (eventedChannel.url !== ((_g = state.currentOpenChannel) === null || _g === void 0 ? void 0 : _g.url) || !fetchedBannedUserList.every(function(user) {
        return typeof user.userId === "string";
      })) {
        return state;
      }
      return __assign(__assign({}, state), { bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), fetchedBannedUserList.map(function(user) {
        return user.userId;
      }), true) });
    }
    case FETCH_MUTED_USER_LIST: {
      var eventedChannel = action.payload.channel;
      var fetchedMutedUserList = action.payload.users;
      if (eventedChannel.url !== ((_h = state.currentOpenChannel) === null || _h === void 0 ? void 0 : _h.url) || !fetchedMutedUserList.every(function(user) {
        return typeof user.userId === "string";
      })) {
        return state;
      }
      return __assign(__assign({}, state), { mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), fetchedMutedUserList.map(function(user) {
        return user.userId;
      }), true) });
    }
    case ON_MESSAGE_RECEIVED: {
      var eventedChannel = action.payload.channel;
      var receivedMessage = action.payload.message;
      var currentOpenChannel = state.currentOpenChannel;
      if (!compareIds(eventedChannel.url, currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url) || !(state.allMessages.map(function(message) {
        return message.messageId;
      }).indexOf(receivedMessage.messageId) < 0)) {
        return state;
      }
      return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [receivedMessage], false) });
    }
    case ON_MESSAGE_UPDATED: {
      var eventedChannel = action.payload.channel;
      var updatedMessage_1 = action.payload.message;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { allMessages: state.allMessages.map(function(message) {
        return message.isIdentical(updatedMessage_1) ? updatedMessage_1 : message;
      }) });
    }
    case ON_MESSAGE_DELETED: {
      var eventedChannel = action.payload.channel;
      var deletedMessageId_1 = action.payload.messageId;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function(message) {
        return !compareIds(message.messageId, deletedMessageId_1);
      }) });
    }
    case ON_MESSAGE_DELETED_BY_REQ_ID: {
      return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function(m) {
        return !compareIds(m.reqId, action.payload);
      }) });
    }
    case ON_OPERATOR_UPDATED: {
      var eventedChannel = action.payload.channel;
      var updatedOperators = action.payload.operators;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { currentOpenChannel: eventedChannel, operators: updatedOperators });
    }
    case ON_USER_ENTERED: {
      var eventedChannel = action.payload.channel;
      var enteredUser = action.payload.user;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { participants: __spreadArray(__spreadArray([], state.participants, true), [enteredUser], false) });
    }
    case ON_USER_EXITED: {
      var eventedChannel = action.payload.channel;
      var exitedUser_1 = action.payload.user;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { participants: state.participants.filter(function(participant) {
        return !compareIds(participant.userId, exitedUser_1.userId);
      }) });
    }
    case ON_USER_MUTED: {
      var eventedChannel = action.payload.channel;
      var mutedUser = action.payload.user;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url || state.mutedParticipantIds.indexOf(mutedUser.userId) >= 0) {
        return state;
      }
      return __assign(__assign({}, state), { mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), [mutedUser.userId], false) });
    }
    case ON_USER_UNMUTED: {
      var eventedChannel = action.payload.channel;
      var unmutedUser_1 = action.payload.user;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url || state.mutedParticipantIds.indexOf(unmutedUser_1.userId) < 0) {
        return state;
      }
      return __assign(__assign({}, state), { mutedParticipantIds: state.mutedParticipantIds.filter(function(userId) {
        return userId !== unmutedUser_1.userId;
      }) });
    }
    case ON_USER_BANNED: {
      var eventedChannel = action.payload.channel;
      var bannedUser = action.payload.user;
      var currentUser = action.payload.currentUser;
      var currentChannel = state.currentOpenChannel;
      if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url) && (bannedUser === null || bannedUser === void 0 ? void 0 : bannedUser.userId) === (currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId)) {
        return __assign(__assign({}, state), { currentOpenChannel: null });
      } else if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {
        return __assign(__assign({}, state), { bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), [bannedUser.userId], false) });
      }
      return state;
    }
    case ON_USER_UNBANNED: {
      var eventedChannel = action.payload.channel;
      var unbannedUser_1 = action.payload.user;
      var currentChannel = state.currentOpenChannel;
      if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {
        return __assign(__assign({}, state), { bannedParticipantIds: state.bannedParticipantIds.filter(function(userId) {
          return userId !== unbannedUser_1.userId;
        }) });
      }
      return state;
    }
    case ON_CHANNEL_FROZEN2: {
      var frozenChannel = action.payload;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== frozenChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { frozen: true });
    }
    case ON_CHANNEL_UNFROZEN2: {
      var unfrozenChannel = action.payload;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== unfrozenChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { frozen: false });
    }
    case ON_CHANNEL_CHANGED2: {
      var changedChannel = action.payload;
      var currentChannel = state.currentOpenChannel;
      if (!currentChannel || currentChannel.url && currentChannel.url !== changedChannel.url) {
        return state;
      }
      return __assign(__assign({}, state), { currentOpenChannel: changedChannel });
    }
    case ON_CHANNEL_DELETED2: {
      var deletedChannelUrl = action.payload;
      var currentChannel = state === null || state === void 0 ? void 0 : state.currentOpenChannel;
      if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === deletedChannelUrl) {
        return __assign(__assign({}, state), { currentOpenChannel: null });
      }
      return state;
    }
    case ON_META_DATA_CREATED: {
      return state;
    }
    case ON_META_DATA_UPDATED: {
      return state;
    }
    case ON_META_DATA_DELETED: {
      return state;
    }
    case ON_META_COUNTERS_CREATED: {
      return state;
    }
    case ON_META_COUNTERS_UPDATED: {
      return state;
    }
    case ON_META_COUNTERS_DELETED: {
      return state;
    }
    case ON_MENTION_RECEIVED: {
      return state;
    }
    default:
      return state;
  }
}
var initialState6 = {
  allMessages: [],
  loading: false,
  initialized: false,
  currentOpenChannel: null,
  isInvalid: false,
  hasMore: false,
  lastMessageTimestamp: 0,
  frozen: false,
  operators: [],
  participants: [],
  bannedParticipantIds: [],
  mutedParticipantIds: []
};
function useSetChannel2(_a, _b) {
  var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, fetchingParticipants = _a.fetchingParticipants, userId = _a.userId, currentOpenChannel = _a.currentOpenChannel;
  var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;
  (0, import_react40.useEffect)(function() {
    var _a2;
    if (channelUrl && sdkInit && (sdk === null || sdk === void 0 ? void 0 : sdk.openChannel)) {
      if (currentOpenChannel && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.exit)) {
        (_a2 = currentOpenChannel.exit) === null || _a2 === void 0 ? void 0 : _a2.call(currentOpenChannel).then(function() {
          logger.info("OpenChannel | useSetChannel: Exit from the previous open channel", currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url);
          messagesDispatcher({
            type: EXIT_CURRENT_CHANNEL,
            payload: currentOpenChannel
          });
        });
      }
      logger.info("OpenChannel | useSetChannel: Fetching channel", channelUrl);
      sdk.openChannel.getChannel(channelUrl).then(function(openChannel) {
        logger.info("OpenChannel | useSetChannel: Succeeded to fetch channel", openChannel);
        messagesDispatcher({
          type: SET_CURRENT_CHANNEL2,
          payload: openChannel
        });
        openChannel.enter().then(function() {
          if (openChannel.isOperator(userId)) {
            var bannedParticipantListQuery = openChannel.createBannedUserListQuery();
            var mutedParticipantListQuery = openChannel.createMutedUserListQuery();
            fetchWithListQuery(bannedParticipantListQuery, logger, function(users) {
              messagesDispatcher({
                type: FETCH_BANNED_USER_LIST,
                payload: {
                  channel: openChannel,
                  users
                }
              });
            });
            fetchWithListQuery(mutedParticipantListQuery, logger, function(users) {
              messagesDispatcher({
                type: FETCH_MUTED_USER_LIST,
                payload: {
                  channel: openChannel,
                  users
                }
              });
            });
          } else {
            openChannel.getMyMutedInfo().then(function(mutedInfo) {
              if (mutedInfo === null || mutedInfo === void 0 ? void 0 : mutedInfo.isMuted) {
                messagesDispatcher({
                  type: FETCH_MUTED_USER_LIST,
                  payload: {
                    channel: openChannel,
                    users: [sdk === null || sdk === void 0 ? void 0 : sdk.currentUser]
                  }
                });
              }
            });
          }
          if (fetchingParticipants) {
            var participantListQuery = openChannel.createParticipantListQuery({
              limit: openChannel.participantCount
            });
            fetchWithListQuery(participantListQuery, logger, function(users) {
              messagesDispatcher({
                type: FETCH_PARTICIPANT_LIST,
                payload: {
                  channel: openChannel,
                  users
                }
              });
            });
          }
        }).catch(function(error) {
          logger.warning("OpenChannel | useSetChannel: Failed to enter channel", { channelUrl, error });
          messagesDispatcher({
            type: SET_CHANNEL_INVALID,
            payload: null
          });
        });
      }).catch(function(error) {
        logger.warning("OpenChannel | useSetChannel: Failed to fetch channel", { channelUrl, error });
        messagesDispatcher({
          type: SET_CHANNEL_INVALID,
          payload: null
        });
      });
    }
  }, [channelUrl, sdkInit, fetchingParticipants]);
}
function useHandleChannelEvents2(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel, checkScrollBottom = _a.checkScrollBottom;
  var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;
  (0, import_react40.useEffect)(function() {
    var _a2, _b2;
    var messageReceiverId = uuidv4();
    if (currentOpenChannel && currentOpenChannel.url && ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a2 === void 0 ? void 0 : _a2.addOpenChannelHandler)) {
      logger.info("OpenChannel | useHandleChannelEvents: Setup evnet handler", messageReceiverId);
      var channelHandlerParams = {
        onMessageReceived: function(channel, message) {
          var scrollToEnd = checkScrollBottom();
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMessageReceived", { channelUrl, message });
          messagesDispatcher({
            type: ON_MESSAGE_RECEIVED,
            payload: { channel, message }
          });
          if (scrollToEnd) {
            try {
              setTimeout(function() {
                scrollIntoLast2(0, scrollRef);
              });
            } catch (error) {
              logger.warning("OpenChannel | onMessageReceived | scroll to end failed");
            }
          }
        },
        onMessageUpdated: function(channel, message) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMessageUpdated", { channelUrl, message });
          messagesDispatcher({
            type: ON_MESSAGE_UPDATED,
            payload: { channel, message }
          });
        },
        onMessageDeleted: function(channel, messageId) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMessageDeleted", { channelUrl, messageId });
          messagesDispatcher({
            type: ON_MESSAGE_DELETED,
            payload: { channel, messageId }
          });
        },
        onOperatorUpdated: function(channel, operators) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onOperatorUpdated", { channelUrl, operators });
          messagesDispatcher({
            type: ON_OPERATOR_UPDATED,
            payload: { channel, operators }
          });
        },
        onUserEntered: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserEntered", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_ENTERED,
            payload: { channel, user }
          });
        },
        onUserExited: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserExited", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_EXITED,
            payload: { channel, user }
          });
        },
        onUserMuted: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserMuted", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_MUTED,
            payload: { channel, user }
          });
        },
        onUserUnmuted: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserUnmuted", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_UNMUTED,
            payload: { channel, user }
          });
        },
        onUserBanned: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserBanned", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_BANNED,
            payload: { channel, user, currentUser: sdk === null || sdk === void 0 ? void 0 : sdk.currentUser }
          });
        },
        onUserUnbanned: function(channel, user) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onUserUnbanned", { channelUrl, user });
          messagesDispatcher({
            type: ON_USER_UNBANNED,
            payload: { channel, user }
          });
        },
        onChannelFrozen: function(channel) {
          logger.info("OpenChannel | useHandleChannelEvents: onChannelFrozen", channel);
          messagesDispatcher({
            type: ON_CHANNEL_FROZEN2,
            payload: channel
          });
        },
        onChannelUnfrozen: function(channel) {
          logger.info("OpenChannel | useHandleChannelEvents: onChannelUnfrozen", channel);
          messagesDispatcher({
            type: ON_CHANNEL_UNFROZEN2,
            payload: channel
          });
        },
        onChannelChanged: function(channel) {
          logger.info("OpenChannel | useHandleChannelEvents: onChannelChanged", channel);
          messagesDispatcher({
            type: ON_CHANNEL_CHANGED2,
            payload: channel
          });
        },
        onMetaDataCreated: function(channel, metaData) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaDataCreated", { channelUrl, metaData });
          messagesDispatcher({
            type: ON_META_DATA_CREATED,
            payload: { channel, metaData }
          });
        },
        onMetaDataUpdated: function(channel, metaData) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaDataUpdated", { channelUrl, metaData });
          messagesDispatcher({
            type: ON_META_DATA_UPDATED,
            payload: { channel, metaData }
          });
        },
        onMetaDataDeleted: function(channel, metaDataKeys) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaDataDeleted", { channelUrl, metaDataKeys });
          messagesDispatcher({
            type: ON_META_DATA_DELETED,
            payload: { channel, metaDataKeys }
          });
        },
        onMetaCounterCreated: function(channel, metaCounter) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaCountersCreated", { channelUrl, metaCounter });
          messagesDispatcher({
            type: ON_META_COUNTERS_CREATED,
            payload: { channel, metaCounter }
          });
        },
        onMetaCounterUpdated: function(channel, metaCounter) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaCountersUpdated", { channelUrl, metaCounter });
          messagesDispatcher({
            type: ON_META_COUNTERS_UPDATED,
            payload: { channel, metaCounter }
          });
        },
        onMetaCounterDeleted: function(channel, metaCounterKeys) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMetaCountersDeleted", { channelUrl, metaCounterKeys });
          messagesDispatcher({
            type: ON_META_COUNTERS_DELETED,
            payload: { channel, metaCounterKeys }
          });
        },
        onMentionReceived: function(channel, message) {
          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;
          logger.info("OpenChannel | useHandleChannelEvents: onMentionReceived", { channelUrl, message });
          messagesDispatcher({
            type: ON_MENTION_RECEIVED,
            payload: { channel, message }
          });
        },
        onChannelDeleted: function(channelUrl, channelType) {
          if (channelType === H.OPEN && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url) === channelUrl) {
            messagesDispatcher({
              type: ON_CHANNEL_DELETED2,
              payload: channelUrl
            });
          }
        }
      };
      var ChannelHandler = new Ae(channelHandlerParams);
      (_b2 = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _b2 === void 0 ? void 0 : _b2.addOpenChannelHandler(messageReceiverId, ChannelHandler);
    }
    return function() {
      var _a3;
      if ((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a3 === void 0 ? void 0 : _a3.removeOpenChannelHandler) {
        logger.info("OpenChannel | useHandleChannelEvents: Removing message receiver handler", messageReceiverId);
        sdk.openChannel.removeOpenChannelHandler(messageReceiverId);
      }
    };
  }, [currentOpenChannel]);
}
function useInitialMessagesFetch(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel, userFilledMessageListParams = _a.userFilledMessageListParams;
  var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;
  (0, import_react40.useEffect)(function() {
    logger === null || logger === void 0 ? void 0 : logger.info("OpenChannel | useInitialMessagesFetch: Setup started", currentOpenChannel);
    messagesDispatcher({
      type: RESET_MESSAGES,
      payload: null
    });
    if (currentOpenChannel && currentOpenChannel.getMessagesByTimestamp) {
      var messageListParams_1 = {
        nextResultSize: 0,
        prevResultSize: 30,
        isInclusive: true,
        includeReactions: false
      };
      if (userFilledMessageListParams) {
        Object.keys(userFilledMessageListParams).forEach(function(key) {
          messageListParams_1[key] = userFilledMessageListParams[key];
        });
        logger === null || logger === void 0 ? void 0 : logger.info("OpenChannel | useInitialMessagesFetch: Used customizedMessageListParams");
      }
      logger === null || logger === void 0 ? void 0 : logger.info("OpenChannel | useInitialMessagesFetch: Fetching messages", { currentOpenChannel, messageListParams: messageListParams_1 });
      messagesDispatcher({
        type: GET_PREV_MESSAGES_START,
        payload: null
      });
      currentOpenChannel.getMessagesByTimestamp((/* @__PURE__ */ new Date()).getTime(), messageListParams_1).then(function(messages) {
        logger === null || logger === void 0 ? void 0 : logger.info("OpenChannel | useInitialMessagesFetch: Fetching messages succeeded", messages);
        var hasMore = messages && messages.length > 0;
        var lastMessageTimestamp = hasMore ? messages[0].createdAt : null;
        messagesDispatcher({
          type: GET_PREV_MESSAGES_SUCESS,
          payload: {
            currentOpenChannel,
            messages,
            hasMore,
            lastMessageTimestamp
          }
        });
        setTimeout(function() {
          scrollIntoLast2(0, scrollRef);
        });
      }).catch(function(error) {
        logger === null || logger === void 0 ? void 0 : logger.error("OpenChannel | useInitialMessagesFetch: Fetching messages failed", error);
        messagesDispatcher({
          type: GET_PREV_MESSAGES_FAIL,
          payload: {
            currentOpenChannel,
            messages: [],
            hasMore: false,
            lastMessageTimestamp: 0
          }
        });
      });
    }
  }, [currentOpenChannel, userFilledMessageListParams]);
}
function useScrollCallback2(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel, lastMessageTimestamp = _a.lastMessageTimestamp, fetchMore = _a.fetchMore;
  var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, hasMore = _b.hasMore, userFilledMessageListParams = _b.userFilledMessageListParams;
  return (0, import_react40.useCallback)(function(callback) {
    if (fetchMore && hasMore) {
      logger.info("OpenChannel | useScrollCallback: start");
      var messageListParams_1 = {
        prevResultSize: 30,
        includeReactions: false,
        nextResultSize: 0
      };
      if (userFilledMessageListParams) {
        Object.keys(userFilledMessageListParams).forEach(function(key) {
          messageListParams_1[key] = userFilledMessageListParams[key];
        });
        logger.info("OpenChannel | useScrollCallback: Used userFilledMessageListParams", userFilledMessageListParams);
      }
      logger.info("OpenChannel | useScrollCallback: Fetching messages", { currentOpenChannel, messageListParams: messageListParams_1 });
      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.getMessagesByTimestamp(lastMessageTimestamp || (/* @__PURE__ */ new Date()).getTime(), messageListParams_1).then(function(messages) {
        logger.info("OpenChannel | useScrollCallback: Fetching messages succeeded", messages);
        var hasMore2 = messages && messages.length > 0;
        var lastMessageTimestamp2 = hasMore2 ? messages[0].createdAt : null;
        messagesDispatcher({
          type: GET_PREV_MESSAGES_SUCESS,
          payload: {
            currentOpenChannel,
            messages,
            hasMore: hasMore2,
            lastMessageTimestamp: lastMessageTimestamp2
          }
        });
        setTimeout(function() {
          callback();
        });
      }).catch(function(error) {
        logger.error("OpenChannel | useScrollCallback: Fetching messages failed", error);
        messagesDispatcher({
          type: GET_PREV_MESSAGES_FAIL,
          payload: {
            currentOpenChannel,
            messages: [],
            hasMore: false,
            lastMessageTimestamp: 0
          }
        });
      });
    }
  }, [currentOpenChannel, lastMessageTimestamp, fetchMore, sdk]);
}
function useCheckScrollBottom(_a, _b) {
  var conversationScrollRef = _a.conversationScrollRef;
  var logger = _b.logger;
  return (0, import_react40.useCallback)(function() {
    var isBottom = true;
    if (conversationScrollRef && (conversationScrollRef === null || conversationScrollRef === void 0 ? void 0 : conversationScrollRef.current)) {
      try {
        var conversationScroll = conversationScrollRef.current;
        isBottom = conversationScroll.scrollHeight <= conversationScroll.scrollTop + conversationScroll.clientHeight;
      } catch (error) {
        logger.error("OpenChannel | useCheckScrollBottom", error);
      }
    }
    return isBottom;
  }, [conversationScrollRef]);
}
function useSendMessageCallback(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage, messageInputRef = _a.messageInputRef;
  var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;
  return (0, import_react40.useCallback)(function() {
    var _a2;
    if (sdk) {
      var text = (_a2 = messageInputRef.current) === null || _a2 === void 0 ? void 0 : _a2.innerText;
      var createParamsDefault = function(txt) {
        var message = txt;
        var params2 = {
          message
        };
        return params2;
      };
      var createCustomParams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === "function";
      if (createCustomParams) {
        logger.info("OpenChannel | useSendMessageCallback: Creating params using onBeforeSendUserMessage", onBeforeSendUserMessage);
      }
      var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text !== null && text !== void 0 ? text : "") : createParamsDefault(text !== null && text !== void 0 ? text : "");
      logger.info("OpenChannel | useSendMessageCallback: Sending message has started", params);
      var pendingMsg_1;
      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendUserMessage(params).onPending(function(pendingMessage) {
        messagesDispatcher({
          type: SENDING_MESSAGE_START,
          payload: {
            message: pendingMessage,
            channel: currentOpenChannel
          }
        });
        pendingMsg_1 = pendingMessage;
        setTimeout(function() {
          return scrollIntoLast2(0, scrollRef);
        });
      }).onSucceeded(function(message) {
        logger.info("OpenChannel | useSendMessageCallback: Sending message succeeded", message);
        messagesDispatcher({
          type: SENDING_MESSAGE_SUCCEEDED,
          payload: message
        });
      }).onFailed(function(error) {
        logger.warning("OpenChannel | useSendMessageCallback: Sending message failed", error);
        messagesDispatcher({
          type: SENDING_MESSAGE_FAILED,
          payload: pendingMsg_1
        });
        if ((error === null || error === void 0 ? void 0 : error.code) === 900041) {
          messagesDispatcher({
            type: ON_USER_MUTED,
            payload: {
              channel: currentOpenChannel,
              user: sdk.currentUser
            }
          });
        }
      });
    }
  }, [currentOpenChannel, onBeforeSendUserMessage, messageInputRef]);
}
function useFileUploadCallback(_a, _b) {
  var _this = this;
  var currentOpenChannel = _a.currentOpenChannel, _c = _a.imageCompression, imageCompression = _c === void 0 ? {} : _c, onBeforeSendFileMessage = _a.onBeforeSendFileMessage;
  var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;
  var stringSet = useLocalization().stringSet;
  var openModal = useGlobalModalContext().openModal;
  var uikitUploadSizeLimit = useSendbird().state.config.uikitUploadSizeLimit;
  return (0, import_react40.useCallback)(function(files) {
    return __awaiter(_this, void 0, void 0, function() {
      var file_1, createCustomParams, createParamsDefault, compressedFiles, compressedFile, params;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!sdk)
              return [3, 2];
            file_1 = Array.isArray(files) ? files[0] : files;
            createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === "function";
            createParamsDefault = function(file) {
              var params2 = {};
              params2.file = file;
              return params2;
            };
            if (file_1.size > uikitUploadSizeLimit) {
              logger.info("OpenChannel | useFileUploadCallback: Cannot upload file size exceeding ".concat(uikitUploadSizeLimit));
              openModal({
                modalProps: {
                  titleText: stringSet.FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT.replace("%d", "".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB))),
                  hideFooter: true
                },
                childElement: function(_a3) {
                  var closeModal = _a3.closeModal;
                  return import_react40.default.createElement(ModalFooter, { type: ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal });
                }
              });
              return [
                2
                /*return*/
              ];
            }
            return [4, compressImages({
              files: [file_1],
              imageCompression,
              logger
            })];
          case 1:
            compressedFiles = _a2.sent().compressedFiles;
            compressedFile = compressedFiles[0];
            if (createCustomParams) {
              logger.info("OpenChannel | useFileUploadCallback: Creating params using onBeforeSendFileMessage", onBeforeSendFileMessage);
            }
            params = onBeforeSendFileMessage ? onBeforeSendFileMessage(compressedFile) : createParamsDefault(compressedFile);
            logger.info("OpenChannel | useFileUploadCallback: Uploading file message start", params);
            currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendFileMessage(params).onPending(function(pendingMessage) {
              messagesDispatcher({
                type: SENDING_MESSAGE_START,
                payload: {
                  // TODO: remove data pollution
                  message: __assign(__assign({}, pendingMessage), {
                    url: URL.createObjectURL(file_1),
                    // pending thumbnail message seems to be failed
                    requestState: "pending",
                    isUserMessage: pendingMessage.isUserMessage,
                    isFileMessage: pendingMessage.isFileMessage,
                    isAdminMessage: pendingMessage.isAdminMessage,
                    isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage
                  }),
                  channel: currentOpenChannel
                }
              });
              setTimeout(function() {
                return scrollIntoLast2(0, scrollRef);
              });
            }).onSucceeded(function(message) {
              logger.info("OpenChannel | useFileUploadCallback: Sending message succeeded", message);
              messagesDispatcher({
                type: SENDING_MESSAGE_SUCCEEDED,
                payload: message
              });
            }).onFailed(function(error, message) {
              logger.error("OpenChannel | useFileUploadCallback: Sending file message failed", { message, error });
              message.localUrl = URL.createObjectURL(file_1);
              message.file = file_1;
              messagesDispatcher({
                type: SENDING_MESSAGE_FAILED,
                payload: message
              });
            });
            _a2.label = 2;
          case 2:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [currentOpenChannel, onBeforeSendFileMessage, imageCompression]);
}
function useUpdateMessageCallback2(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage;
  var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;
  return (0, import_react40.useCallback)(function(messageId, text, callback) {
    var createParamsDefault = function(txt) {
      return {
        message: txt
      };
    };
    if (onBeforeSendUserMessage && typeof onBeforeSendUserMessage === "function") {
      logger.info("OpenChannel | useUpdateMessageCallback: Creating params using onBeforeUpdateUserMessage");
    }
    var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text) : createParamsDefault(text);
    currentOpenChannel.updateUserMessage(messageId, params).then(function(message) {
      if (callback) {
        callback();
      }
      logger.info("OpenChannel | useUpdateMessageCallback: Updating message succeeded", { message, params });
      messagesDispatcher({
        type: ON_MESSAGE_UPDATED,
        payload: {
          channel: currentOpenChannel,
          message
        }
      });
    });
  }, [currentOpenChannel, onBeforeSendUserMessage]);
}
function useDeleteMessageCallback2(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel;
  var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;
  return (0, import_react40.useCallback)(function(message, callback) {
    logger.info("OpenChannel | useDeleteMessageCallback: Deleting message", message);
    var sendingStatus = message.sendingStatus;
    logger.info("OpenChannel | useDeleteMessageCallback: Deleting message requestState", sendingStatus);
    if (sendingStatus === "failed" || sendingStatus === "pending") {
      logger.info("OpenChannel | useDeleteMessageCallback: Deleted message from local", message);
      messagesDispatcher({
        type: ON_MESSAGE_DELETED_BY_REQ_ID,
        payload: message.reqId
      });
      if (callback) {
        callback();
      }
    } else {
      if (!(message.messageType === "file" || message.messageType === "user")) {
        return;
      }
      var messageToDelete = message;
      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.deleteMessage(messageToDelete).then(function() {
        logger.info("OpenChannel | useDeleteMessageCallback: Deleting message on server", sendingStatus);
        if (callback) {
          callback();
        }
        logger.info("OpenChannel | useDeleteMessageCallback: Deleting message succeeded", message);
        messagesDispatcher({
          type: ON_MESSAGE_DELETED,
          payload: {
            channel: currentOpenChannel,
            messageId: message.messageId
          }
        });
      }).catch(function(error) {
        logger.warning("OpenChannel | useDeleteMessageCallback: Deleting message failed", error);
      });
    }
  }, [currentOpenChannel]);
}
function useResendMessageCallback2(_a, _b) {
  var currentOpenChannel = _a.currentOpenChannel;
  var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;
  return (0, import_react40.useCallback)(function(failedMessage) {
    logger.info("OpenChannel | useResendMessageCallback: Resending message has started", failedMessage);
    if (typeof (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) === "boolean" && failedMessage.isResendable) {
      if (failedMessage.isUserMessage()) {
        currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function(message) {
          messagesDispatcher({
            type: RESENDING_MESSAGE_START,
            payload: {
              channel: currentOpenChannel,
              message
            }
          });
        }).onSucceeded(function(message) {
          logger.info("OpenChannel | useResendMessageCallback: Reseding message succeeded", message);
          messagesDispatcher({
            type: SENDING_MESSAGE_SUCCEEDED,
            payload: message
          });
        }).onFailed(function(error, message) {
          logger.warning("OpenChannel | useResendMessageCallback: Resending message failed", error);
          messagesDispatcher({
            type: SENDING_MESSAGE_FAILED,
            payload: message
          });
        });
      }
      if (failedMessage.isFileMessage()) {
        currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function(message) {
          messagesDispatcher({
            type: RESENDING_MESSAGE_START,
            payload: {
              channel: currentOpenChannel,
              message
            }
          });
        }).onSucceeded(function(message) {
          logger.info("OpenChannel | useResendMessageCallback: Resending file message succeeded", message);
          messagesDispatcher({
            type: SENDING_MESSAGE_SUCCEEDED,
            payload: message
          });
        }).onFailed(function(error, message) {
          logger.warning("OpenChannel | useResendMessageCallback: Resending file message failed", error);
          messagesDispatcher({
            type: SENDING_MESSAGE_FAILED,
            payload: message
          });
        });
      }
    } else {
      console.error("OpenChannel | useResendMessageCallback: Message is not resendable");
      logger.warning("OpenChannel | useResendMessageCallback: Message is not resendable", failedMessage);
    }
  }, [currentOpenChannel]);
}
var THROTTLE_TIMER = 5e3;
function useTrimMessageList(_a, _b) {
  var messagesLength = _a.messagesLength, messageLimit = _a.messageLimit;
  var messagesDispatcher = _b.messagesDispatcher, logger = _b.logger;
  var _c = (0, import_react40.useState)(false), inProgress = _c[0], setInProgress = _c[1];
  (0, import_react40.useEffect)(function() {
    if (inProgress) {
      return;
    }
    if (typeof messagesLength === "number" && typeof messageLimit === "number" && messagesLength > messageLimit) {
      logger.info("Trimming MessageList");
      messagesDispatcher({
        type: TRIM_MESSAGE_LIST,
        payload: { messageLimit }
      });
    }
    setInProgress(true);
    setTimeout(function() {
      setInProgress(false);
    }, THROTTLE_TIMER);
  }, [messagesLength, messageLimit]);
}
var OpenChannelContext = import_react40.default.createContext(null);
var OpenChannelProvider = function(props) {
  var _a;
  var channelUrl = props.channelUrl, children = props.children, _b = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _b === void 0 ? true : _b, queries = props.queries, onBeforeSendUserMessage = props.onBeforeSendUserMessage, messageLimit = props.messageLimit, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onChatHeaderActionClick = props.onChatHeaderActionClick, onBackClick = props.onBackClick, disableUserProfile = props.disableUserProfile, renderUserProfile = props.renderUserProfile;
  var fetchingParticipants = false;
  var state = useSendbird().state;
  var sdk = state.stores.sdkStore.sdk;
  var sdkInit = state.stores.sdkStore.initialized;
  var user = state.stores.userStore.user;
  var config = state.config;
  var userId = config.userId, isOnline = config.isOnline, logger = config.logger, pubSub = config.pubSub, imageCompression = config.imageCompression;
  var _c = (0, import_react40.useReducer)(reducer, initialState6), messagesStore = _c[0], messagesDispatcher = _c[1];
  var allMessages = messagesStore.allMessages, loading = messagesStore.loading, initialized = messagesStore.initialized, currentOpenChannel = messagesStore.currentOpenChannel, isInvalid = messagesStore.isInvalid, hasMore = messagesStore.hasMore, lastMessageTimestamp = messagesStore.lastMessageTimestamp, operators = messagesStore.operators, bannedParticipantIds = messagesStore.bannedParticipantIds, mutedParticipantIds = messagesStore.mutedParticipantIds;
  var messageInputRef = (0, import_react40.useRef)(null);
  var conversationScrollRef = (0, import_react40.useRef)(null);
  var userFilledMessageListParams = queries === null || queries === void 0 ? void 0 : queries.messageListParams;
  var disabled = !initialized || !isOnline || isDisabledBecauseFrozen3(currentOpenChannel, userId) || isDisabledBecauseMuted3(mutedParticipantIds, userId);
  var amIBanned = (0, import_react40.useMemo)(function() {
    return bannedParticipantIds.indexOf(user.userId) >= 0;
  }, [channelUrl, bannedParticipantIds, user]);
  var amIMuted = (0, import_react40.useMemo)(function() {
    return mutedParticipantIds.indexOf(user.userId) >= 0;
  }, [channelUrl, mutedParticipantIds, user]);
  var amIOperator = (0, import_react40.useMemo)(function() {
    return operators.map(function(operator) {
      return operator.userId;
    }).indexOf(user.userId) >= 0;
  }, [channelUrl, operators, user]);
  useSetChannel2({ channelUrl, sdkInit, fetchingParticipants, userId, currentOpenChannel }, { sdk, logger, messagesDispatcher });
  var checkScrollBottom = useCheckScrollBottom({ conversationScrollRef }, { logger });
  useHandleChannelEvents2({ currentOpenChannel, checkScrollBottom }, { sdk, logger, messagesDispatcher, scrollRef: conversationScrollRef });
  useInitialMessagesFetch({ currentOpenChannel, userFilledMessageListParams }, { logger, messagesDispatcher, scrollRef: conversationScrollRef });
  var fetchMore = shouldFetchMore(allMessages === null || allMessages === void 0 ? void 0 : allMessages.length, messageLimit);
  var onScroll = useScrollCallback2({ currentOpenChannel, lastMessageTimestamp, fetchMore }, { sdk, logger, messagesDispatcher, hasMore, userFilledMessageListParams });
  var handleSendMessage = useSendMessageCallback({ currentOpenChannel, onBeforeSendUserMessage, checkScrollBottom, messageInputRef }, { sdk, logger, messagesDispatcher, scrollRef: conversationScrollRef });
  var handleFileUpload = useFileUploadCallback({ currentOpenChannel, onBeforeSendFileMessage, checkScrollBottom, imageCompression }, { sdk, logger, messagesDispatcher, scrollRef: conversationScrollRef });
  var updateMessage = useUpdateMessageCallback2({ currentOpenChannel, onBeforeSendUserMessage }, { logger, messagesDispatcher });
  var deleteMessage = useDeleteMessageCallback2({ currentOpenChannel }, { logger, messagesDispatcher });
  var resendMessage = useResendMessageCallback2({ currentOpenChannel }, { logger, messagesDispatcher });
  useTrimMessageList({ messagesLength: allMessages === null || allMessages === void 0 ? void 0 : allMessages.length, messageLimit }, { messagesDispatcher, logger });
  (0, import_react40.useEffect)(function() {
    var subscriber = /* @__PURE__ */ new Map();
    if (!pubSub || !pubSub.subscribe) {
      return;
    }
    subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function(msg) {
      var channel = msg.channel, message = msg.message;
      scrollIntoLast2(0, conversationScrollRef);
      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        messagesDispatcher({
          type: SENDING_MESSAGE_SUCCEEDED,
          payload: message
        });
      }
    }));
    subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function(msg) {
      var channel = msg.channel, message = msg.message;
      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        messagesDispatcher({
          type: SENDING_MESSAGE_START,
          payload: { message, channel }
        });
      }
    }));
    subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function(msg) {
      var channel = msg.channel, message = msg.message;
      scrollIntoLast2(0, conversationScrollRef);
      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        messagesDispatcher({
          type: SENDING_MESSAGE_SUCCEEDED,
          payload: { message, channel }
        });
      }
    }));
    subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function(msg) {
      var channel = msg.channel, message = msg.message, fromSelector = msg.fromSelector;
      if (fromSelector && channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        messagesDispatcher({
          type: ON_MESSAGE_UPDATED,
          payload: { channel, message }
        });
      }
    }));
    subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function(msg) {
      var channel = msg.channel, messageId = msg.messageId;
      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {
        messagesDispatcher({
          type: ON_MESSAGE_DELETED,
          payload: messageId
        });
      }
    }));
    return function() {
      if (subscriber) {
        subscriber.forEach(function(s) {
          try {
            s.remove();
          } catch (_a2) {
          }
        });
      }
    };
  }, [channelUrl, sdkInit]);
  return import_react40.default.createElement(
    OpenChannelContext.Provider,
    { value: {
      // props
      channelUrl,
      children,
      isMessageGroupingEnabled,
      queries,
      onBeforeSendUserMessage,
      messageLimit,
      onBeforeSendFileMessage,
      onChatHeaderActionClick,
      onBackClick,
      // store
      allMessages,
      loading,
      initialized,
      currentOpenChannel,
      isInvalid,
      hasMore,
      lastMessageTimestamp,
      operators,
      bannedParticipantIds,
      mutedParticipantIds,
      // derived/utils
      messageInputRef,
      conversationScrollRef,
      disabled,
      amIBanned,
      amIMuted,
      amIOperator,
      checkScrollBottom,
      fetchMore,
      onScroll,
      handleSendMessage,
      handleFileUpload,
      updateMessage,
      deleteMessage,
      resendMessage,
      frozen: messagesStore.frozen,
      disableUserProfile,
      renderUserProfile,
      participants: messagesStore.participants
    } },
    import_react40.default.createElement(UserProfileProvider, { isOpenChannel: true, renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile, disableUserProfile: (_a = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _a !== void 0 ? _a : config === null || config === void 0 ? void 0 : config.disableUserProfile }, children)
  );
};
var useOpenChannelContext = function() {
  var context = import_react40.default.useContext(OpenChannelContext);
  if (!context)
    throw new Error("OpenChannelContext not found. Use within the OpenChannel module");
  return context;
};

// node_modules/@sendbird/uikit-react/OpenChannel/components/OpenChannelInput.js
var import_react41 = __toESM(require_react(), 1);
var import_react_dom21 = __toESM(require_react_dom(), 1);
var OpenChannelInput = import_react41.default.forwardRef(function(props, ref) {
  var _a = useOpenChannelContext(), currentOpenChannel = _a.currentOpenChannel, disabled = _a.disabled, handleSendMessage = _a.handleSendMessage, handleFileUpload = _a.handleFileUpload, amIMuted = _a.amIMuted;
  var channel = currentOpenChannel;
  var stringSet = (0, import_react41.useContext)(LocalizationContext).stringSet;
  var value = props.value;
  function getPlaceHolderString() {
    if (amIMuted) {
      return stringSet.MESSAGE_INPUT__PLACE_HOLDER__MUTED;
    }
    if (disabled) {
      return stringSet.MESSAGE_INPUT__PLACE_HOLDER__DISABLED;
    }
    return "";
  }
  if (!channel) {
    return null;
  }
  return import_react41.default.createElement(
    "div",
    { className: "sendbird-openchannel-footer" },
    import_react41.default.createElement(MessageInput, { channel: currentOpenChannel, ref, value, disabled, isVoiceMessageEnabled: false, onSendMessage: handleSendMessage, onFileUpload: handleFileUpload, placeholder: getPlaceHolderString() })
  );
});

// node_modules/@sendbird/uikit-react/chunks/bundle-Bt36atB_.js
var copyToClipboard = function(text) {
  if (window.clipboardData && window.clipboardData.setData) {
    return window.clipboardData.setData("Text", text);
  }
  if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
    var textarea = document.createElement("textarea");
    textarea.textContent = text;
    textarea.style.position = "fixed";
    document.body.appendChild(textarea);
    textarea.select();
    try {
      return document.execCommand("copy");
    } catch (ex) {
      return false;
    } finally {
      document.body.removeChild(textarea);
    }
  }
  return false;
};

// node_modules/@sendbird/uikit-react/chunks/bundle-BI-KSAb4.js
var import_react42 = __toESM(require_react(), 1);
var OpenChannelMessageStatusTypes = {
  NONE: "none",
  PENDING: "pending",
  FAILED: "failed",
  CANCELED: "canceled",
  SUCCEEDED: "succeeded"
};
var getSenderFromMessage = function(message) {
  return message.sender || message._sender;
};
var checkIsSent = function(status) {
  return status === OpenChannelMessageStatusTypes.SUCCEEDED;
};
var checkIsPending = function(status) {
  return status === OpenChannelMessageStatusTypes.PENDING;
};
var checkIsFailed = function(status) {
  return status === OpenChannelMessageStatusTypes.FAILED;
};
var checkIsByMe = function(message, userId) {
  return getSenderFromMessage(message).userId === userId;
};
var isFineCopy = function(_a) {
  var _b;
  var message = _a.message;
  return (message === null || message === void 0 ? void 0 : message.messageType) === "user" && ((_b = message === null || message === void 0 ? void 0 : message.message) === null || _b === void 0 ? void 0 : _b.length) > 0;
};
var isFineResend = function(_a) {
  var message = _a.message, status = _a.status, userId = _a.userId;
  return checkIsByMe(message, userId) && checkIsFailed(status) && (message === null || message === void 0 ? void 0 : message.isResendable);
};
var isFineEdit = function(_a) {
  var _b;
  var message = _a.message, status = _a.status, userId = _a.userId;
  return checkIsByMe(message, userId) && checkIsSent(status) && ((_b = message === null || message === void 0 ? void 0 : message.isUserMessage) === null || _b === void 0 ? void 0 : _b.call(message));
};
var isFineDelete = function(_a) {
  var message = _a.message, userId = _a.userId;
  return checkIsByMe(message, userId);
};
var isFineDownload = function(_a) {
  var _b;
  var message = _a.message, status = _a.status;
  if (((_b = message === null || message === void 0 ? void 0 : message.isFileMessage) === null || _b === void 0 ? void 0 : _b.call(message)) && checkIsSent(status)) {
    return true;
  }
  return false;
};
var showMenuTrigger = function(props) {
  var message = props.message, status = props.status, userId = props.userId;
  if (message.messageType === "user") {
    return isFineDelete({ message, status, userId }) || isFineEdit({ message, status, userId }) || isFineCopy({ message, status, userId }) || isFineResend({ message, status, userId });
  } else {
    return isFineDelete({ message, status, userId }) || isFineResend({ message, status, userId });
  }
};
var OpenChannelMobileMenu = function(props) {
  var message = props.message, parentRef = props.parentRef, resendMessage = props.resendMessage, showEdit = props.showEdit, showRemove = props.showRemove, copyToClipboard2 = props.copyToClipboard, hideMenu = props.hideMenu, _a = props.isEphemeral, isEphemeral = _a === void 0 ? false : _a;
  var userMessage = message;
  var status = message === null || message === void 0 ? void 0 : message.sendingStatus;
  var stringSet = useLocalization().stringSet;
  var userId = useSendbird().state.config.userId;
  var fileMessage = message;
  return import_react42.default.createElement(ContextMenu, { isOpen: true, menuItems: function() {
    return import_react42.default.createElement(
      MenuItems,
      { className: "sendbird-openchannel__mobile-menu", parentRef, parentContainRef: parentRef, closeDropdown: hideMenu },
      isFineCopy({ message: userMessage, userId, status }) && import_react42.default.createElement(
        MenuItem,
        { className: "sendbird-openchannel-og-message__top__context-menu__copy", onClick: function() {
          copyToClipboard2 === null || copyToClipboard2 === void 0 ? void 0 : copyToClipboard2();
        }, testID: "open_channel_mobile_context_menu_copy" },
        import_react42.default.createElement(import_react42.default.Fragment, null, stringSet.CONTEXT_MENU_DROPDOWN__COPY)
      ),
      !isEphemeral && isFineEdit({ message, userId, status }) && import_react42.default.createElement(
        MenuItem,
        { className: "sendbird-openchannel-og-message__top__context-menu__edit", onClick: function() {
          showEdit === null || showEdit === void 0 ? void 0 : showEdit();
        }, testID: "open_channel_mobile_context_menu_edit" },
        import_react42.default.createElement(import_react42.default.Fragment, null, stringSet.CONTEXT_MENU_DROPDOWN__EDIT)
      ),
      isFineResend({ message, userId, status }) && import_react42.default.createElement(
        MenuItem,
        { onClick: function() {
          resendMessage === null || resendMessage === void 0 ? void 0 : resendMessage();
        }, testID: "open_channel_mobile_context_menu_resend" },
        import_react42.default.createElement(import_react42.default.Fragment, null, stringSet.CONTEXT_MENU_DROPDOWN__RESEND)
      ),
      !isEphemeral && isFineDelete({ message, userId, status }) && import_react42.default.createElement(
        MenuItem,
        { onClick: function() {
          showRemove === null || showRemove === void 0 ? void 0 : showRemove();
        }, testID: "open_channel_mobile_context_menu_delete" },
        import_react42.default.createElement(import_react42.default.Fragment, null, stringSet.CONTEXT_MENU_DROPDOWN__DELETE)
      ),
      isFineDownload({ message, status }) && import_react42.default.createElement(
        MenuItem,
        { onClick: function() {
          hideMenu();
        }, testID: "open_channel_mobile_context_menu_download_file" },
        import_react42.default.createElement("a", { className: "sendbird-openchannel__mobile-menu-hyperlink", rel: "noopener noreferrer", href: fileMessage === null || fileMessage === void 0 ? void 0 : fileMessage.url, target: "_blank" }, stringSet.CONTEXT_MENU_DROPDOWN__SAVE)
      )
    );
  } });
};

// node_modules/@sendbird/uikit-react/ui/OpenchannelUserMessage.js
var import_react43 = __toESM(require_react(), 1);
var import_react_dom22 = __toESM(require_react_dom(), 1);
function OpenchannelUserMessage(_a) {
  var className = _a.className, message = _a.message, isOperator2 = _a.isOperator, _b = _a.isEphemeral, isEphemeral = _b === void 0 ? false : _b, userId = _a.userId, resendMessage = _a.resendMessage, disabled = _a.disabled, showEdit = _a.showEdit, showRemove = _a.showRemove, chainTop = _a.chainTop;
  var _c = useLocalization(), stringSet = _c.stringSet, dateLocale = _c.dateLocale;
  var _d = useUserProfileContext(), disableUserProfile = _d.disableUserProfile, renderUserProfile = _d.renderUserProfile;
  var messageRef = (0, import_react43.useRef)();
  var avatarRef = (0, import_react43.useRef)();
  var contextMenuRef = (0, import_react43.useRef)();
  var mobileMenuRef = (0, import_react43.useRef)();
  var _e = (0, import_react43.useState)({}), contextStyle = _e[0], setContextStyle = _e[1];
  var _f = (0, import_react43.useState)(false), contextMenu = _f[0], setContextMenu = _f[1];
  var status = message === null || message === void 0 ? void 0 : message.sendingStatus;
  var isPending = checkIsPending(status);
  var isFailed = checkIsFailed(status);
  var sender = getSenderFromMessage(message);
  (0, import_react43.useEffect)(function() {
    var _a2;
    if (((_a2 = messageRef === null || messageRef === void 0 ? void 0 : messageRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) && messageRef.current.clientHeight > 36) {
      setContextStyle({ top: "8px " });
    } else {
      setContextStyle({ top: "2px" });
    }
  }, [window.innerWidth]);
  var onLongPress = useLongPress({
    onLongPress: function() {
      setContextMenu(true);
    }
  });
  var isMobile = useMediaQueryContext().isMobile;
  if (!message || message.messageType !== "user") {
    return import_react43.default.createElement(import_react43.default.Fragment, null);
  }
  return import_react43.default.createElement(
    import_react43.default.Fragment,
    null,
    import_react43.default.createElement(
      "div",
      { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
        "sendbird-openchannel-user-message"
      ], false).join(" "), ref: messageRef },
      import_react43.default.createElement("div", { className: "sendbird-openchannel-user-message__left" }, !chainTop && import_react43.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
        return import_react43.default.createElement(Avatar$1, { className: "sendbird-openchannel-user-message__left__avatar", src: sender.profileUrl || "", ref: avatarRef, width: "28px", height: "28px", onClick: function() {
          if (!disableUserProfile) {
            toggleDropdown();
          }
        } });
      }, menuItems: function(closeDropdown) {
        return renderUserProfile ? renderUserProfile({
          user: sender,
          close: closeDropdown,
          currentUserId: userId,
          avatarRef
        }) : import_react43.default.createElement(
          MenuItems,
          { parentRef: avatarRef, parentContainRef: avatarRef, closeDropdown, style: { paddingTop: "0px", paddingBottom: "0px" } },
          import_react43.default.createElement(UserProfile, { user: sender, onSuccess: closeDropdown, disableMessaging: true })
        );
      } })),
      import_react43.default.createElement(
        "div",
        { className: "sendbird-openchannel-user-message__right" },
        !chainTop && import_react43.default.createElement(
          "div",
          { className: "sendbird-openchannel-user-message__right__top" },
          import_react43.default.createElement(Label, { className: "sendbird-openchannel-user-message__right__top__sender-name", type: LabelTypography.CAPTION_2, color: isOperator2 ? LabelColors.SECONDARY_3 : LabelColors.ONBACKGROUND_2 }, sender && (sender.friendName || sender.nickname || sender.userId)),
          import_react43.default.createElement(Label, { className: "sendbird-openchannel-user-message__right__top__sent-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_3 }, (message === null || message === void 0 ? void 0 : message.createdAt) && format(message === null || message === void 0 ? void 0 : message.createdAt, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, {
            locale: dateLocale
          }))
        ),
        import_react43.default.createElement(
          "div",
          __assign({}, isMobile ? __assign({}, onLongPress) : {}, { className: "sendbird-openchannel-user-message__right__bottom", ref: mobileMenuRef }),
          import_react43.default.createElement(
            Label,
            { className: "sendbird-openchannel-user-message__right__bottom__message", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 },
            message === null || message === void 0 ? void 0 : message.message,
            isEditedMessage(message) && import_react43.default.createElement(Label, { key: uuidv4(), type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_2, className: "sendbird-openchannel-user-message-word" }, " ".concat(stringSet.MESSAGE_EDITED, " "))
          )
        ),
        (isPending || isFailed) && import_react43.default.createElement(
          "div",
          { className: "sendbird-openchannel-user-message__right__tail" },
          isPending && import_react43.default.createElement(
            Loader,
            { width: "16px", height: "16px" },
            import_react43.default.createElement(Icon, { className: "sendbird-openchannel-user-message__right__tail__pending", type: IconTypes.SPINNER, fillColor: IconColors.PRIMARY, width: "16px", height: "16px" })
          ),
          isFailed && import_react43.default.createElement(Icon, { className: "sendbird-openchannel-user-message__right__tail__failed", type: IconTypes.ERROR, fillColor: IconColors.ERROR, width: "16px", height: "16px" })
        )
      ),
      !isMobile && import_react43.default.createElement(
        "div",
        { className: "sendbird-openchannel-user-message__context-menu", ref: contextMenuRef, style: contextStyle },
        import_react43.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
          return showMenuTrigger({ message, userId, status }) && import_react43.default.createElement(
            IconButton,
            { className: "sendbird-openchannel-user-message__context-menu--icon", width: "32px", height: "32px", onClick: function() {
              toggleDropdown();
            } },
            import_react43.default.createElement(Icon, { type: IconTypes.MORE, fillColor: IconColors.CONTENT_INVERSE, width: "24px", height: "24px" })
          );
        }, menuItems: function(closeDropdown) {
          return import_react43.default.createElement(
            MenuItems,
            { parentRef: contextMenuRef, parentContainRef: contextMenuRef, closeDropdown, openLeft: true },
            isFineCopy({ message, userId, status }) && import_react43.default.createElement(MenuItem, { className: "sendbird-openchannel-user-message__context-menu__copy", onClick: function() {
              copyToClipboard(message.message);
              closeDropdown();
            }, testID: "open_channel_user_message_menu_copy" }, stringSet.CONTEXT_MENU_DROPDOWN__COPY),
            !isEphemeral && isFineEdit({ message, userId, status }) && import_react43.default.createElement(MenuItem, { className: "sendbird-openchannel-user-message__context-menu__edit", onClick: function() {
              if (disabled) {
                return;
              }
              showEdit(true);
              closeDropdown();
            }, testID: "open_channel_user_message_menu_edit" }, stringSet.CONTEXT_MENU_DROPDOWN__EDIT),
            isFineResend({ message, userId, status }) && import_react43.default.createElement(MenuItem, { className: "sendbird-openchannel-user-message__context-menu__resend", onClick: function() {
              resendMessage(message);
              closeDropdown();
            }, testID: "open_channel_user_message_menu_resend" }, stringSet.CONTEXT_MENU_DROPDOWN__RESEND),
            !isEphemeral && isFineDelete({ message, userId, status }) && import_react43.default.createElement(MenuItem, { className: "sendbird-openchannel-user-message__context-menu__delete", onClick: function() {
              if (disabled) {
                return;
              }
              showRemove(true);
              closeDropdown();
            }, testID: "open_channel_user_message_menu_delete" }, stringSet.CONTEXT_MENU_DROPDOWN__DELETE)
          );
        } })
      )
    ),
    contextMenu && import_react43.default.createElement(OpenChannelMobileMenu, { message, parentRef: mobileMenuRef, hideMenu: function() {
      setContextMenu(false);
    }, showRemove: function() {
      setContextMenu(false);
      showRemove(true);
    }, showEdit: function() {
      setContextMenu(false);
      showEdit(true);
    }, copyToClipboard: function() {
      setContextMenu(false);
      copyToClipboard(message === null || message === void 0 ? void 0 : message.message);
    }, resendMessage: function() {
      setContextMenu(false);
      resendMessage(message);
    } })
  );
}

// node_modules/@sendbird/uikit-react/ui/OpenChannelAdminMessage.js
var import_react44 = __toESM(require_react(), 1);
function OpenChannelAdminMessage(_a) {
  var className = _a.className, message = _a.message;
  return import_react44.default.createElement(
    "div",
    { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
      "sendbird-openchannel-admin-message"
    ], false).join(" ") },
    import_react44.default.createElement(Label, { className: "sendbird-openchannel-admin-message__text", type: LabelTypography.CAPTION_2, color: LabelColors.ONBACKGROUND_2 }, message.message || "")
  );
}

// node_modules/@sendbird/uikit-react/ui/OpenchannelOGMessage.js
var import_react45 = __toESM(require_react(), 1);
var import_react_dom23 = __toESM(require_react_dom(), 1);
function OpenChannelOGMessage(_a) {
  var _b, _c, _d;
  var message = _a.message, isOperator2 = _a.isOperator, _e = _a.isEphemeral, isEphemeral = _e === void 0 ? false : _e, className = _a.className, disabled = _a.disabled, showEdit = _a.showEdit, showRemove = _a.showRemove, resendMessage = _a.resendMessage, chainTop = _a.chainTop, userId = _a.userId;
  var status = message === null || message === void 0 ? void 0 : message.sendingStatus;
  var ogMetaData = (_b = message.ogMetaData) !== null && _b !== void 0 ? _b : null;
  var defaultImage = ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.defaultImage;
  var _f = useLocalization(), stringSet = _f.stringSet, dateLocale = _f.dateLocale;
  var isMobile = useMediaQueryContext().isMobile;
  var _g = useUserProfileContext(), disableUserProfile = _g.disableUserProfile, renderUserProfile = _g.renderUserProfile;
  var _h = (0, import_react45.useState)({}), contextStyle = _h[0], setContextStyle = _h[1];
  var _j = (0, import_react45.useState)(false), showContextMenu = _j[0], setShowContextMenu = _j[1];
  var openLink = function() {
    return openURL(ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.url);
  };
  var onLongPress = useLongPress({
    onLongPress: function() {
      return setShowContextMenu(true);
    },
    onClick: openLink
  }, {
    delay: 300
  });
  var messageComponentRef = (0, import_react45.useRef)();
  var contextMenuRef = (0, import_react45.useRef)();
  var mobileMenuRef = (0, import_react45.useRef)();
  var avatarRef = (0, import_react45.useRef)();
  var isPending = checkIsPending(status);
  var isFailed = checkIsFailed(status);
  var sender = getSenderFromMessage(message);
  var tokens = (0, import_react45.useMemo)(function() {
    return tokenizeMessage({
      messageText: message.message
    });
  }, [message === null || message === void 0 ? void 0 : message.updatedAt, message === null || message === void 0 ? void 0 : message.message]);
  (0, import_react45.useEffect)(function() {
    var _a2, _b2;
    if (((_a2 = messageComponentRef === null || messageComponentRef === void 0 ? void 0 : messageComponentRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientHeight) && ((_b2 = messageComponentRef === null || messageComponentRef === void 0 ? void 0 : messageComponentRef.current) === null || _b2 === void 0 ? void 0 : _b2.clientHeight) > 36) {
      setContextStyle({ top: "8px " });
    } else {
      setContextStyle({ top: "2px" });
    }
  }, [window.innerWidth]);
  if (!message || message.messageType !== "user") {
    return import_react45.default.createElement(import_react45.default.Fragment, null);
  }
  return import_react45.default.createElement(
    import_react45.default.Fragment,
    null,
    import_react45.default.createElement(
      "div",
      __assign({ className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
        "sendbird-openchannel-og-message"
      ], false).join(" "), ref: messageComponentRef }, isMobile ? __assign({}, onLongPress) : {}),
      import_react45.default.createElement(
        "div",
        { className: "sendbird-openchannel-og-message__top" },
        import_react45.default.createElement("div", { className: "sendbird-openchannel-og-message__top__left" }, !chainTop && import_react45.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
          return import_react45.default.createElement(Avatar$1, { className: "sendbird-openchannel-og-message__top__left__avatar", src: sender.profileUrl || "", ref: avatarRef, width: "28px", height: "28px", onClick: function() {
            if (!disableUserProfile) {
              toggleDropdown();
            }
          } });
        }, menuItems: function(closeDropdown) {
          return renderUserProfile ? renderUserProfile({
            user: sender,
            close: closeDropdown,
            currentUserId: userId,
            avatarRef
          }) : import_react45.default.createElement(
            MenuItems,
            { parentRef: avatarRef, parentContainRef: avatarRef, closeDropdown, style: { paddingTop: "0px", paddingBottom: "0px" } },
            import_react45.default.createElement(UserProfile, { user: sender, onSuccess: closeDropdown, disableMessaging: true })
          );
        } })),
        import_react45.default.createElement(
          "div",
          { className: "sendbird-openchannel-og-message__top__right" },
          !chainTop && import_react45.default.createElement(
            "div",
            { className: "sendbird-openchannel-og-message__top__right__title" },
            import_react45.default.createElement(Label, { className: "sendbird-openchannel-og-message__top__right__title__sender-name", type: LabelTypography.CAPTION_2, color: isOperator2 ? LabelColors.SECONDARY_3 : LabelColors.ONBACKGROUND_2 }, sender && (sender.friendName || sender.nickname || sender.userId)),
            import_react45.default.createElement(Label, { className: "sendbird-openchannel-og-message__top__right__title__sent-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_3 }, (message === null || message === void 0 ? void 0 : message.createdAt) && format(message === null || message === void 0 ? void 0 : message.createdAt, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, {
              locale: dateLocale
            }))
          ),
          import_react45.default.createElement(
            "div",
            { className: "sendbird-openchannel-og-message__top__right__description" },
            import_react45.default.createElement(
              Label,
              { className: "sendbird-openchannel-og-message__top__right__description__message", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 },
              import_react45.default.createElement(TextFragment, { tokens }),
              ((_c = message === null || message === void 0 ? void 0 : message.updatedAt) !== null && _c !== void 0 ? _c : 0) > 0 && import_react45.default.createElement(Label, { key: uuidv4(), className: "sendbird-openchannel-og-message--word", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_2 }, stringSet.MESSAGE_EDITED)
            )
          )
        ),
        !isMobile && import_react45.default.createElement(
          "div",
          { className: "sendbird-openchannel-og-message__top__context-menu", ref: contextMenuRef, style: contextStyle },
          import_react45.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
            return showMenuTrigger({ message, userId, status }) && import_react45.default.createElement(
              IconButton,
              { className: "sendbird-openchannel-og-message__top__context-menu--icon", width: "32px", height: "32px", onClick: function() {
                toggleDropdown();
              } },
              import_react45.default.createElement(Icon, { type: IconTypes.MORE, fillColor: IconColors.CONTENT_INVERSE, width: "24px", height: "24px" })
            );
          }, menuItems: function(closeDropdown) {
            return import_react45.default.createElement(
              MenuItems,
              { parentRef: contextMenuRef, parentContainRef: contextMenuRef, closeDropdown, openLeft: true },
              isFineCopy({ message, userId, status }) && import_react45.default.createElement(MenuItem, { className: "sendbird-openchannel-og-message__top__context-menu__copy", onClick: function() {
                copyToClipboard(message.message);
                closeDropdown();
              }, testID: "open_channel_og_message_menu_copy" }, stringSet.CONTEXT_MENU_DROPDOWN__COPY),
              !isEphemeral && isFineEdit({ message, userId, status }) && import_react45.default.createElement(MenuItem, { className: "sendbird-openchannel-og-message__top__context-menu__edit", onClick: function() {
                if (disabled) {
                  return;
                }
                showEdit(true);
                closeDropdown();
              }, testID: "open_channel_og_message_menu_edit" }, stringSet.CONTEXT_MENU_DROPDOWN__EDIT),
              isFineResend({ message, userId, status }) && import_react45.default.createElement(MenuItem, { className: "sendbird-openchannel-og-message__top__context-menu__resend", onClick: function() {
                resendMessage(message);
                closeDropdown();
              }, testID: "open_channel_og_message_menu_resend" }, stringSet.CONTEXT_MENU_DROPDOWN__RESEND),
              !isEphemeral && isFineDelete({ message, userId, status }) && import_react45.default.createElement(MenuItem, { className: "sendbird-openchannel-og-message__top__context-menu__delete", onClick: function() {
                if (disabled) {
                  return;
                }
                showRemove(true);
                closeDropdown();
              }, testID: "open_channel_og_message_menu_delete" }, stringSet.CONTEXT_MENU_DROPDOWN__DELETE)
            );
          } })
        )
      ),
      import_react45.default.createElement(
        "div",
        { className: "sendbird-openchannel-og-message__bottom" },
        import_react45.default.createElement(
          "div",
          { className: "sendbird-openchannel-og-message__bottom__og-tag", ref: mobileMenuRef },
          (ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.url) && import_react45.default.createElement(Label, { className: "sendbird-openchannel-og-message__bottom__og-tag__url", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_2 }, ogMetaData.url),
          (ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.title) && import_react45.default.createElement(LinkLabel, { className: "sendbird-openchannel-og-message__bottom__og-tag__title", src: (_d = ogMetaData.url) !== null && _d !== void 0 ? _d : "", type: LabelTypography.SUBTITLE_2, color: LabelColors.PRIMARY }, ogMetaData.title),
          (ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.description) && import_react45.default.createElement(Label, { className: "sendbird-openchannel-og-message__bottom__og-tag__description", type: LabelTypography.BODY_2, color: LabelColors.ONBACKGROUND_1 }, ogMetaData.description),
          (ogMetaData === null || ogMetaData === void 0 ? void 0 : ogMetaData.url) && import_react45.default.createElement("div", { className: "sendbird-openchannel-og-message__bottom__og-tag__thumbnail", role: "button", onClick: openLink, onKeyDown: openLink, tabIndex: 0 }, defaultImage && import_react45.default.createElement(ImageRenderer, { className: "sendbird-openchannel-og-message__bottom__og-tag__thumbnail__image", url: defaultImage.url || "", alt: defaultImage.alt || "", width: "334px", height: "189px", defaultComponent: import_react45.default.createElement(
            "div",
            { className: "sendbird-openchannel-og-message__bottom__og-tag__thumbnail__image--placeholder" },
            import_react45.default.createElement(Icon, { type: IconTypes.THUMBNAIL_NONE, width: "56px", height: "56px" })
          ) }))
        ),
        (isPending || isFailed) && import_react45.default.createElement(
          "div",
          { className: "sendbird-openchannel-og-message__top__right__tail" },
          isPending && import_react45.default.createElement(
            Loader,
            { width: "16px", height: "16px" },
            import_react45.default.createElement(Icon, { className: "sendbird-openchannel-og-message__top__right__tail__pending", type: IconTypes.SPINNER, fillColor: IconColors.PRIMARY, width: "16px", height: "16px" })
          ),
          isFailed && import_react45.default.createElement(Icon, { className: "sendbird-openchannel-og-message__top__right__tail__failed", type: IconTypes.ERROR, fillColor: IconColors.ERROR, width: "16px", height: "16px" })
        )
      )
    ),
    showContextMenu && import_react45.default.createElement(OpenChannelMobileMenu, { message, parentRef: mobileMenuRef, hideMenu: function() {
      setShowContextMenu(false);
    }, showRemove: function() {
      setShowContextMenu(false);
      showRemove(true);
    }, showEdit: function() {
      setShowContextMenu(false);
      showEdit(true);
    }, copyToClipboard: function() {
      setShowContextMenu(false);
      copyToClipboard(message === null || message === void 0 ? void 0 : message.message);
    }, resendMessage: function() {
      setShowContextMenu(false);
      resendMessage(message);
    } })
  );
}

// node_modules/@sendbird/uikit-react/ui/OpenchannelThumbnailMessage.js
var import_react46 = __toESM(require_react(), 1);
var import_react_dom24 = __toESM(require_react_dom(), 1);
var SUPPORTING_TYPES = {
  IMAGE: "IMAGE",
  VIDEO: "VIDEO",
  UNSUPPORTED: "UNSUPPORTED"
};
var SUPPORTED_MIMES = {
  IMAGE: [
    "image/jpeg",
    "image/jpg",
    "image/png",
    "image/gif",
    "image/webp"
  ],
  VIDEO: [
    "video/mpeg",
    "video/ogg",
    "video/webm",
    "video/mp4"
  ]
};
var getSupportingFileType = function(type) {
  if (SUPPORTED_MIMES.IMAGE.indexOf(type) >= 0) {
    return SUPPORTING_TYPES.IMAGE;
  }
  if (SUPPORTED_MIMES.VIDEO.indexOf(type) >= 0) {
    return SUPPORTING_TYPES.VIDEO;
  }
  return SUPPORTING_TYPES.UNSUPPORTED;
};
function OpenchannelThumbnailMessage(_a) {
  var _b;
  var className = _a.className, message = _a.message, isOperator2 = _a.isOperator, _c = _a.isEphemeral, isEphemeral = _c === void 0 ? false : _c, disabled = _a.disabled, userId = _a.userId, chainTop = _a.chainTop, onClick = _a.onClick, showRemove = _a.showRemove, resendMessage = _a.resendMessage;
  var type = message.type, url = message.url, thumbnails = message.thumbnails, localUrl = message.localUrl;
  var status = message === null || message === void 0 ? void 0 : message.sendingStatus;
  var thumbnailUrl = thumbnails && thumbnails.length > 0 && thumbnails[0].url || null;
  var _d = useLocalization(), stringSet = _d.stringSet, dateLocale = _d.dateLocale;
  var _e = useUserProfileContext(), disableUserProfile = _e.disableUserProfile, renderUserProfile = _e.renderUserProfile;
  var _f = (0, import_react46.useState)(360), messageWidth = _f[0], setMessageWidth = _f[1];
  var _g = (0, import_react46.useState)(false), contextMenu = _g[0], setContextMenu = _g[1];
  var messageRef = (0, import_react46.useRef)(null);
  var mobileMenuRef = (0, import_react46.useRef)(null);
  var contextMenuRef = (0, import_react46.useRef)(null);
  var avatarRef = (0, import_react46.useRef)(null);
  var onLongPress = useLongPress({
    onLongPress: function() {
      setContextMenu(true);
    },
    onClick: function() {
      onClick(true);
    }
  });
  var isMobile = useMediaQueryContext().isMobile;
  var memorizedThumbnailPlaceHolder = (0, import_react46.useMemo)(function() {
    return function(type2) {
      return function(_a2) {
        var style = _a2.style;
        return (
          // eslint-disable-line
          import_react46.default.createElement(
            "div",
            { style },
            import_react46.default.createElement(Icon, { type: type2, fillColor: IconColors.ON_BACKGROUND_2, width: "56px", height: "56px" })
          )
        );
      };
    };
  }, []);
  var isMessageSent = checkIsSent(status);
  var isPending = checkIsPending(status);
  var isFailed = checkIsFailed(status);
  var sender = getSenderFromMessage(message);
  (0, import_react46.useEffect)(function() {
    var _a2, _b2;
    var thumbnailWidth = ((_b2 = (_a2 = messageRef === null || messageRef === void 0 ? void 0 : messageRef.current) === null || _a2 === void 0 ? void 0 : _a2.clientWidth) !== null && _b2 !== void 0 ? _b2 : 0) - 80;
    setMessageWidth(thumbnailWidth > 360 ? 360 : thumbnailWidth);
  }, []);
  return import_react46.default.createElement(
    import_react46.default.Fragment,
    null,
    import_react46.default.createElement(
      "div",
      { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
        "sendbird-openchannel-thumbnail-message"
      ], false).join(" "), ref: messageRef },
      import_react46.default.createElement("div", { className: "sendbird-openchannel-thumbnail-message__left" }, !chainTop && import_react46.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
        return import_react46.default.createElement(Avatar$1, { className: "sendbird-openchannel-thumbnail-message__left__avatar", src: sender.profileUrl || "", ref: avatarRef, width: "28px", height: "28px", onClick: function() {
          if (!disableUserProfile) {
            toggleDropdown();
          }
        } });
      }, menuItems: function(closeDropdown) {
        return renderUserProfile ? renderUserProfile({
          user: sender,
          close: closeDropdown,
          currentUserId: userId,
          avatarRef
        }) : import_react46.default.createElement(
          MenuItems,
          { parentRef: avatarRef, parentContainRef: avatarRef, closeDropdown, style: { paddingTop: "0px", paddingBottom: "0px" } },
          import_react46.default.createElement(UserProfile, { user: sender, onSuccess: closeDropdown, disableMessaging: true })
        );
      } })),
      import_react46.default.createElement(
        "div",
        { className: "sendbird-openchannel-thumbnail-message__right" },
        !chainTop && import_react46.default.createElement(
          "div",
          { className: "sendbird-openchannel-thumbnail-message__right__title" },
          import_react46.default.createElement(Label, { className: "sendbird-openchannel-thumbnail-message__right__title__sender-name", type: LabelTypography.CAPTION_2, color: isOperator2 ? LabelColors.SECONDARY_3 : LabelColors.ONBACKGROUND_2 }, sender && (sender.friendName || sender.nickname || sender.userId)),
          import_react46.default.createElement(Label, { className: "sendbird-openchannel-thumbnail-message__right__title__sent-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_3 }, (message === null || message === void 0 ? void 0 : message.createdAt) && format(message.createdAt, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, {
            locale: dateLocale
          }))
        ),
        import_react46.default.createElement(
          "div",
          { className: "sendbird-openchannel-thumbnail-message__right__body", ref: mobileMenuRef },
          import_react46.default.createElement(
            "div",
            __assign({ className: "sendbird-openchannel-thumbnail-message__right__body__wrap", role: "button", onClick: function() {
              if (isMessageSent) {
                onClick(true);
              }
            }, onKeyDown: function() {
              if (isMessageSent) {
                onClick(true);
              }
            }, tabIndex: 0 }, isMobile ? __assign({}, onLongPress) : {}),
            import_react46.default.createElement("div", { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__overlay" }),
            (_b = {}, _b[SUPPORTING_TYPES.VIDEO] = url || localUrl ? import_react46.default.createElement(
              "div",
              { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__video" },
              thumbnailUrl ? import_react46.default.createElement(ImageRenderer, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__video", url: thumbnailUrl, width: messageWidth, height: "270px", alt: "image", placeHolder: memorizedThumbnailPlaceHolder(IconTypes.PLAY) }) : import_react46.default.createElement(
                "video",
                { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__video__video" },
                import_react46.default.createElement("source", { src: url || localUrl, type })
              ),
              import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__video__icon", type: IconTypes.PLAY, fillColor: IconColors.ON_BACKGROUND_2, width: "56px", height: "56px" })
            ) : import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__video--icon", type: IconTypes.PHOTO, fillColor: IconColors.ON_BACKGROUND_2, width: "56px", height: "56px" }), _b[SUPPORTING_TYPES.IMAGE] = url || localUrl ? import_react46.default.createElement(ImageRenderer, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__image", url: thumbnailUrl || url || localUrl || "", alt: "image", width: messageWidth, height: "270px", placeHolder: memorizedThumbnailPlaceHolder(IconTypes.PHOTO) }) : import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__image--icon", type: IconTypes.PHOTO, fillColor: IconColors.ON_BACKGROUND_2, width: "56px", height: "56px" }), _b[SUPPORTING_TYPES.UNSUPPORTED] = import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__body__wrap__unknown", type: IconTypes.PHOTO, fillColor: IconColors.ON_BACKGROUND_2, width: "56px", height: "56px" }), _b)[getSupportingFileType(type)]
          )
        ),
        (isPending || isFailed) && import_react46.default.createElement(
          "div",
          { className: "sendbird-openchannel-thumbnail-message__right__tail" },
          isPending && import_react46.default.createElement(
            Loader,
            { width: "16px", height: "16px" },
            import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__tail__pending", type: IconTypes.SPINNER, fillColor: IconColors.PRIMARY, width: "16px", height: "16px" })
          ),
          isFailed && import_react46.default.createElement(Icon, { className: "sendbird-openchannel-thumbnail-message__right__tail__failed", type: IconTypes.ERROR, fillColor: IconColors.ERROR, width: "16px", height: "16px" })
        )
      ),
      !isMobile && import_react46.default.createElement("div", { className: "sendbird-openchannel-thumbnail-message__context-menu", ref: contextMenuRef }, (isFineResend({ message, userId, status }) || !isEphemeral) && import_react46.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
        return showMenuTrigger({ message, userId, status }) && import_react46.default.createElement(
          IconButton,
          { className: "sendbird-openchannel-thumbnail-message__context-menu--icon", width: "32px", height: "32px", onClick: toggleDropdown },
          import_react46.default.createElement(Icon, { type: IconTypes.MORE, fillColor: IconColors.CONTENT_INVERSE, width: "24px", height: "24px" })
        );
      }, menuItems: function(closeDropdown) {
        return import_react46.default.createElement(
          MenuItems,
          { parentRef: contextMenuRef, parentContainRef: contextMenuRef, closeDropdown, openLeft: true },
          isFineResend({ message, userId, status }) && import_react46.default.createElement(MenuItem, { onClick: function() {
            resendMessage(message);
            closeDropdown();
          }, testID: "open_channel_thumbnail_message_menu_resend" }, stringSet.CONTEXT_MENU_DROPDOWN__RESEND),
          !isEphemeral && isFineDelete({ message, userId, status }) && import_react46.default.createElement(MenuItem, { onClick: function() {
            if (disabled) {
              return;
            }
            showRemove(true);
            closeDropdown();
          }, testID: "open_channel_thumbnail_message_menu_delete" }, stringSet.CONTEXT_MENU_DROPDOWN__DELETE)
        );
      } }))
    ),
    contextMenu && import_react46.default.createElement(OpenChannelMobileMenu, { message, parentRef: mobileMenuRef, hideMenu: function() {
      setContextMenu(false);
    }, showRemove: function() {
      setContextMenu(false);
      showRemove(true);
    }, resendMessage: function() {
      setContextMenu(false);
      resendMessage(message);
    } })
  );
}

// node_modules/@sendbird/uikit-react/ui/OpenchannelFileMessage.js
var import_react47 = __toESM(require_react(), 1);
var import_react_dom25 = __toESM(require_react_dom(), 1);
var checkFileType = function(fileUrl) {
  var audioFile = /(\.mp3)$/i;
  var gifFile = /(\.gif)$/i;
  if (audioFile.test(fileUrl)) {
    return IconTypes.FILE_AUDIO;
  }
  if (gifFile.test(fileUrl)) {
    return IconTypes.GIF;
  }
  return IconTypes.FILE_DOCUMENT;
};
var truncate = function(fullStr, strLen) {
  if (fullStr === null || fullStr === void 0)
    return "";
  if (fullStr.length <= strLen)
    return fullStr;
  var separator = "...";
  var sepLen = separator.length;
  var charsToShow = strLen - sepLen;
  var frontChars = Math.ceil(charsToShow / 2);
  var backChars = Math.floor(charsToShow / 2);
  return fullStr.substr(0, frontChars) + separator + fullStr.substr(fullStr.length - backChars);
};
function OpenChannelFileMessage(_a) {
  var className = _a.className, message = _a.message, isOperator2 = _a.isOperator, _b = _a.isEphemeral, isEphemeral = _b === void 0 ? false : _b, userId = _a.userId, disabled = _a.disabled, chainTop = _a.chainTop, showRemove = _a.showRemove, resendMessage = _a.resendMessage;
  var status = message === null || message === void 0 ? void 0 : message.sendingStatus;
  var _c = useLocalization(), dateLocale = _c.dateLocale, stringSet = _c.stringSet;
  var contextMenuRef = (0, import_react47.useRef)(null);
  var mobileMenuRef = (0, import_react47.useRef)(null);
  var avatarRef = (0, import_react47.useRef)(null);
  var _d = useUserProfileContext(), disableUserProfile = _d.disableUserProfile, renderUserProfile = _d.renderUserProfile;
  var isMobile = useMediaQueryContext().isMobile;
  var openFileUrl = function() {
    return openURL(message.url);
  };
  var isPending = checkIsPending(status);
  var isFailed = checkIsFailed(status);
  var sender = getSenderFromMessage(message);
  var _e = (0, import_react47.useState)(false), contextMenu = _e[0], setContextMenu = _e[1];
  var longPress = useLongPress({
    onLongPress: function() {
      if (isMobile) {
        setContextMenu(true);
      }
    },
    onClick: openFileUrl
  }, { delay: 300 });
  return import_react47.default.createElement(
    import_react47.default.Fragment,
    null,
    import_react47.default.createElement(
      "div",
      { className: __spreadArray(__spreadArray([], Array.isArray(className) ? className : [className], true), [
        "sendbird-openchannel-file-message"
      ], false).join(" "), ref: mobileMenuRef },
      import_react47.default.createElement("div", { className: "sendbird-openchannel-file-message__left" }, !chainTop && import_react47.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
        return import_react47.default.createElement(Avatar$1, { className: "sendbird-openchannel-file-message__left__avatar", src: sender.profileUrl || "", ref: avatarRef, width: "28px", height: "28px", onClick: function() {
          if (!disableUserProfile) {
            toggleDropdown();
          }
        } });
      }, menuItems: function(closeDropdown) {
        return renderUserProfile ? renderUserProfile({
          user: sender,
          close: closeDropdown,
          currentUserId: userId,
          avatarRef
        }) : import_react47.default.createElement(
          MenuItems,
          { parentRef: avatarRef, parentContainRef: avatarRef, closeDropdown, style: { paddingTop: "0px", paddingBottom: "0px" } },
          import_react47.default.createElement(UserProfile, { user: sender, onSuccess: closeDropdown, disableMessaging: true })
        );
      } })),
      import_react47.default.createElement(
        "div",
        { className: "sendbird-openchannel-file-message__right" },
        !chainTop && import_react47.default.createElement(
          "div",
          { className: "sendbird-openchannel-file-message__right__title" },
          import_react47.default.createElement(Label, { className: "sendbird-openchannel-file-message__right__title__sender-name", type: LabelTypography.CAPTION_2, color: isOperator2 ? LabelColors.SECONDARY_3 : LabelColors.ONBACKGROUND_2 }, sender && (sender.friendName || sender.nickname || sender.userId)),
          import_react47.default.createElement(Label, { className: "sendbird-openchannel-file-message__right__title__sent-at", type: LabelTypography.CAPTION_3, color: LabelColors.ONBACKGROUND_3 }, (message === null || message === void 0 ? void 0 : message.createdAt) && format(message.createdAt, stringSet.DATE_FORMAT__MESSAGE_CREATED_AT, {
            locale: dateLocale
          }))
        ),
        import_react47.default.createElement(
          "div",
          __assign({ className: "sendbird-openchannel-file-message__right__body" }, isMobile ? __assign({}, longPress) : {}),
          checkFileType(message.url) && import_react47.default.createElement(Icon, { className: "sendbird-openchannel-file-message__right__body__icon", type: checkFileType(message.url), fillColor: IconColors.PRIMARY, width: "48px", height: "48px" }),
          import_react47.default.createElement(
            TextButton,
            { className: "sendbird-openchannel-file-message__right__body__file-name", onClick: openFileUrl },
            import_react47.default.createElement(Label, { className: "sendbird-openchannel-file-message__right__body__file-name__label", type: LabelTypography.BODY_1, color: LabelColors.ONBACKGROUND_1 }, truncate(message.name || message.url, 40))
          )
        ),
        (isPending || isFailed) && import_react47.default.createElement(
          "div",
          { className: "sendbird-openchannel-file-message__right__tail" },
          isPending && import_react47.default.createElement(
            Loader,
            { width: "16px", height: "16px" },
            import_react47.default.createElement(Icon, { className: "sendbird-openchannel-file-message__right__tail__pending", type: IconTypes.SPINNER, fillColor: IconColors.PRIMARY, width: "16px", height: "16px" })
          ),
          isFailed && import_react47.default.createElement(Icon, { className: "sendbird-openchannel-file-message__right__tail__failed", type: IconTypes.ERROR, fillColor: IconColors.ERROR, width: "16px", height: "16px" })
        )
      ),
      !isMobile && import_react47.default.createElement("div", { className: "sendbird-openchannel-file-message__context-menu", ref: contextMenuRef }, (isFineResend({ message, userId, status }) || !isEphemeral) && import_react47.default.createElement(ContextMenu, { menuTrigger: function(toggleDropdown) {
        return showMenuTrigger({ message, userId, status }) && import_react47.default.createElement(
          IconButton,
          { className: "sendbird-openchannel-file-message__context-menu__icon", width: "32px", height: "32px", onClick: toggleDropdown },
          import_react47.default.createElement(Icon, { type: IconTypes.MORE, width: "24px", height: "24px" })
        );
      }, menuItems: function(closeDropdown) {
        return import_react47.default.createElement(
          MenuItems,
          { parentRef: contextMenuRef, parentContainRef: contextMenuRef, closeDropdown, openLeft: true },
          isFineResend({ message, userId, status }) && import_react47.default.createElement(MenuItem, { onClick: function() {
            if (disabled) {
              return;
            }
            resendMessage(message);
            closeDropdown();
          }, testID: "open_channel_file_message_context_menu_resend" }, stringSet.CONTEXT_MENU_DROPDOWN__RESEND),
          !isEphemeral && isFineDelete({ message, userId, status }) && import_react47.default.createElement(MenuItem, { onClick: function() {
            if (disabled) {
              return;
            }
            showRemove(true);
            closeDropdown();
          }, testID: "open_channel_file_message_context_menu_delete" }, stringSet.CONTEXT_MENU_DROPDOWN__DELETE)
        );
      } }))
    ),
    contextMenu && import_react47.default.createElement(OpenChannelMobileMenu, { message, hideMenu: function() {
      setContextMenu(false);
    }, parentRef: mobileMenuRef, showRemove: function() {
      setContextMenu(false);
      showRemove(true);
    } })
  );
}

// node_modules/@sendbird/uikit-react/OpenChannel/components/OpenChannelMessage.js
var import_react48 = __toESM(require_react(), 1);
var import_react_dom26 = __toESM(require_react_dom(), 1);
function RemoveMessageModal2(_a) {
  var message = _a.message, onCloseModal = _a.onCloseModal, onDeleteMessage = _a.onDeleteMessage;
  var stringSet = (0, import_react48.useContext)(LocalizationContext).stringSet;
  return import_react48.default.createElement(Modal, { onCancel: onCloseModal, onSubmit: onDeleteMessage, submitText: stringSet.MESSAGE_MENU__DELETE, titleText: getModalDeleteMessageTitle(stringSet, message) });
}
var MessageTypes = {
  ADMIN: "ADMIN",
  USER: "USER",
  FILE: "FILE",
  THUMBNAIL: "THUMBNAIL",
  OG: "OG",
  UNKNOWN: "UNKNOWN"
};
var SendingMessageStatus = {
  NONE: "none",
  SUCCEEDED: "succeeded",
  FAILED: "failed",
  PENDING: "pending"
};
var getMessageType = function(message, options) {
  var _a, _b;
  var isOgMessageEnabledInOpenChannel = options === null || options === void 0 ? void 0 : options.isOgMessageEnabledInOpenChannel;
  if (((_a = message === null || message === void 0 ? void 0 : message.isUserMessage) === null || _a === void 0 ? void 0 : _a.call(message)) || (message === null || message === void 0 ? void 0 : message.messageType) === "user") {
    return (message === null || message === void 0 ? void 0 : message.ogMetaData) && isOgMessageEnabledInOpenChannel ? MessageTypes.OG : MessageTypes.USER;
  }
  if ((_b = message === null || message === void 0 ? void 0 : message.isAdminMessage) === null || _b === void 0 ? void 0 : _b.call(message)) {
    return MessageTypes.ADMIN;
  }
  if ((message === null || message === void 0 ? void 0 : message.messageType) === "file") {
    return isImage(message.type) || isVideo(message.type) ? MessageTypes.THUMBNAIL : MessageTypes.FILE;
  }
  return MessageTypes.UNKNOWN;
};
function OpenChannelMessage(props) {
  var _a;
  var _b;
  var message = props.message, chainTop = props.chainTop, chainBottom = props.chainBottom, hasSeparator = props.hasSeparator, renderMessage = props.renderMessage;
  var _c = useOpenChannelContext(), currentOpenChannel = _c.currentOpenChannel, deleteMessage = _c.deleteMessage, updateMessage = _c.updateMessage, resendMessage = _c.resendMessage;
  var _d = useLocalization(), dateLocale = _d.dateLocale, stringSet = _d.stringSet;
  var editDisabled = currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isFrozen;
  var state = useSendbird().state;
  var currentUserId = (_b = state === null || state === void 0 ? void 0 : state.config) === null || _b === void 0 ? void 0 : _b.userId;
  var isOgMessageEnabledInOpenChannel = state.config.openChannel.enableOgtag;
  var sender;
  if ((message === null || message === void 0 ? void 0 : message.messageType) !== "admin") {
    sender = message === null || message === void 0 ? void 0 : message.sender;
  }
  var _e = (0, import_react48.useState)(false), showEdit = _e[0], setShowEdit = _e[1];
  var _f = (0, import_react48.useState)(false), showRemove = _f[0], setShowRemove = _f[1];
  var _g = (0, import_react48.useState)(false), showFileViewer = _g[0], setShowFileViewer = _g[1];
  var editMessageInputRef = (0, import_react48.useRef)(null);
  var isByMe = false;
  if (sender && (message === null || message === void 0 ? void 0 : message.messageType) !== "admin") {
    isByMe = currentUserId === sender.userId || (message === null || message === void 0 ? void 0 : message.sendingStatus) === SendingMessageStatus.PENDING || (message === null || message === void 0 ? void 0 : message.sendingStatus) === SendingMessageStatus.FAILED;
  }
  if (renderMessage) {
    return import_react48.default.createElement("div", { className: "sendbird-open-channel-msg-hoc sendbird-msg--scroll-ref", "data-testid": "sendbird-message-hoc" }, renderMessage({ message, chainTop, chainBottom }));
  }
  if ((message === null || message === void 0 ? void 0 : message.messageType) === "user" && showEdit) {
    return import_react48.default.createElement(MessageInput, { isEdit: true, channel: currentOpenChannel, disabled: editDisabled, ref: editMessageInputRef, message, onUpdateMessage: function(_a2) {
      var messageId = _a2.messageId, message2 = _a2.message;
      updateMessage(messageId, message2);
      setShowEdit(false);
    }, onCancelEdit: function() {
      setShowEdit(false);
    } });
  }
  return import_react48.default.createElement(
    "div",
    { className: "sendbird-open-channel-msg-hoc sendbird-msg--scroll-ref", "data-testid": "sendbird-message-hoc" },
    import_react48.default.createElement(
      import_react48.default.Fragment,
      null,
      hasSeparator && (message === null || message === void 0 ? void 0 : message.createdAt) && import_react48.default.createElement(
        DateSeparator,
        null,
        import_react48.default.createElement(Label, { type: LabelTypography.CAPTION_2, color: LabelColors.ONBACKGROUND_2 }, format(message === null || message === void 0 ? void 0 : message.createdAt, stringSet.DATE_FORMAT__MESSAGE_LIST__DATE_SEPARATOR, { locale: dateLocale }))
      ),
      (_a = {}, _a[MessageTypes.ADMIN] = function() {
        if ((message === null || message === void 0 ? void 0 : message.messageType) === "admin") {
          return import_react48.default.createElement(OpenChannelAdminMessage, { message });
        }
      }(), _a[MessageTypes.FILE] = function() {
        var _a2;
        if ((message === null || message === void 0 ? void 0 : message.messageType) === "file") {
          return import_react48.default.createElement(OpenChannelFileMessage, { message, isOperator: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isOperator((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId), isEphemeral: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isEphemeral, disabled: editDisabled, userId: currentUserId, showRemove: setShowRemove, resendMessage, chainTop, chainBottom });
        }
      }(), _a[MessageTypes.OG] = function() {
        var _a2;
        if ((message === null || message === void 0 ? void 0 : message.messageType) === "user" && isOgMessageEnabledInOpenChannel) {
          return import_react48.default.createElement(OpenChannelOGMessage, { message, isOperator: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isOperator((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId), isEphemeral: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isEphemeral, userId: currentUserId, showEdit: setShowEdit, disabled: editDisabled, showRemove: setShowRemove, resendMessage, chainTop, chainBottom });
        }
      }(), _a[MessageTypes.THUMBNAIL] = function() {
        var _a2;
        if ((message === null || message === void 0 ? void 0 : message.messageType) === "file") {
          return import_react48.default.createElement(OpenchannelThumbnailMessage, { message, isOperator: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isOperator((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId), isEphemeral: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isEphemeral, disabled: editDisabled, userId: currentUserId, showRemove: setShowRemove, resendMessage, onClick: setShowFileViewer, chainTop, chainBottom });
        }
      }(), _a[MessageTypes.USER] = function() {
        var _a2;
        if ((message === null || message === void 0 ? void 0 : message.messageType) === "user") {
          return import_react48.default.createElement(OpenchannelUserMessage, { message, isOperator: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isOperator((_a2 = message === null || message === void 0 ? void 0 : message.sender) === null || _a2 === void 0 ? void 0 : _a2.userId), isEphemeral: currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.isEphemeral, userId: currentUserId, disabled: editDisabled, showEdit: setShowEdit, showRemove: setShowRemove, resendMessage, chainTop, chainBottom });
        }
      }(), _a[MessageTypes.UNKNOWN] = /* @__PURE__ */ function() {
      }(), _a)[getMessageType(message, { isOgMessageEnabledInOpenChannel })],
      showRemove && import_react48.default.createElement(RemoveMessageModal2, { message, onCloseModal: function() {
        return setShowRemove(false);
      }, onDeleteMessage: function() {
        if ((message === null || message === void 0 ? void 0 : message.messageType) !== "admin") {
          deleteMessage(message);
        }
      } }),
      showFileViewer && (message === null || message === void 0 ? void 0 : message.messageType) === "file" && import_react48.default.createElement(FileViewer, { onClose: function() {
        return setShowFileViewer(false);
      }, message, onDelete: function() {
        return deleteMessage(message);
      }, isByMe })
    )
  );
}

// node_modules/@sendbird/uikit-react/OpenChannel/components/OpenChannelMessageList.js
var import_react49 = __toESM(require_react(), 1);
var import_react_dom27 = __toESM(require_react_dom(), 1);
function OpenChannelMessageList(props, ref) {
  var _a = useOpenChannelContext(), _b = _a.isMessageGroupingEnabled, isMessageGroupingEnabled = _b === void 0 ? true : _b, allMessages = _a.allMessages, hasMore = _a.hasMore, onScroll = _a.onScroll;
  var state = useSendbird().state;
  var stringSet = useLocalization().stringSet;
  var userId = state.config.userId;
  var localRef = (0, import_react49.useRef)(null);
  var scrollRef = ref || localRef;
  var _c = (0, import_react49.useState)(false), showScrollDownButton = _c[0], setShowScrollDownButton = _c[1];
  var scrollToBottom = function() {
    if (scrollRef && "current" in scrollRef && scrollRef.current) {
      scrollRef.current.scrollTo(0, scrollRef.current.scrollHeight);
      setShowScrollDownButton(false);
    }
  };
  var handleOnScroll = useHandleOnScrollCallback({
    setShowScrollDownButton,
    hasMore,
    onScroll,
    scrollRef
  });
  var memoizedMessageList = (0, import_react49.useMemo)(function() {
    var _a2;
    if (allMessages.length > 0) {
      return allMessages.map(function(message, index) {
        var _a3;
        var previousMessage = allMessages[index - 1];
        var nextMessage = allMessages[index - 1];
        var previousMessageCreatedAt = previousMessage && previousMessage.createdAt;
        var currentCreatedAt = message === null || message === void 0 ? void 0 : message.createdAt;
        var hasSeparator = !(previousMessageCreatedAt && isSameDay(currentCreatedAt, previousMessageCreatedAt));
        var _b2 = isMessageGroupingEnabled ? compareMessagesForGrouping(previousMessage, message, nextMessage, stringSet) : [false, false], chainTop = _b2[0], chainBottom = _b2[1];
        var isByMe = ((_a3 = message === null || message === void 0 ? void 0 : message.sender) === null || _a3 === void 0 ? void 0 : _a3.userId) === userId;
        var key = (message === null || message === void 0 ? void 0 : message.messageId) || (message === null || message === void 0 ? void 0 : message.reqId);
        return import_react49.default.createElement(
          MessageProvider,
          { message, isByMe, key },
          import_react49.default.createElement(OpenChannelMessage, { message, chainTop, chainBottom, hasSeparator, renderMessage: props === null || props === void 0 ? void 0 : props.renderMessage })
        );
      });
    }
    return ((_a2 = props === null || props === void 0 ? void 0 : props.renderPlaceHolderEmptyList) === null || _a2 === void 0 ? void 0 : _a2.call(props)) || import_react49.default.createElement(PlaceHolder, { className: "sendbird-openchannel-conversation-scroll__container__place-holder", type: PlaceHolderTypes.NO_MESSAGES });
  }, [allMessages]);
  return import_react49.default.createElement(
    "div",
    { className: "sendbird-openchannel-conversation-scroll" },
    import_react49.default.createElement(
      "div",
      { className: "sendbird-openchannel-conversation-scroll__container" },
      import_react49.default.createElement("div", { className: "sendbird-openchannel-conversation-scroll__container__padding" }),
      import_react49.default.createElement("div", { className: [
        "sendbird-openchannel-conversation-scroll__container__item-container",
        allMessages.length > 0 ? "" : "no-messages"
      ].join(" "), onScroll: handleOnScroll, ref: scrollRef }, memoizedMessageList)
    ),
    showScrollDownButton && import_react49.default.createElement(
      "div",
      { className: "sendbird-openchannel-conversation-scroll__container__scroll-bottom-button", onClick: scrollToBottom, onKeyDown: scrollToBottom, tabIndex: 0, role: "button" },
      import_react49.default.createElement(Icon, { width: "24px", height: "24px", type: IconTypes.CHEVRON_DOWN, fillColor: IconColors.CONTENT })
    )
  );
}
var OpenChannelMessageList$1 = import_react49.default.forwardRef(OpenChannelMessageList);

// node_modules/@sendbird/uikit-react/OpenChannelSettings/context.js
var import_react50 = __toESM(require_react(), 1);
var OpenChannelSettingsContext = import_react50.default.createContext(null);
var OpenChannelSettingsProvider = function(props) {
  var _a, _b, _c, _d;
  var children = props.children, channelUrl = props.channelUrl, onCloseClick = props.onCloseClick, onChannelModified = props.onChannelModified, onBeforeUpdateChannel = props.onBeforeUpdateChannel, onDeleteChannel = props.onDeleteChannel;
  var _e = useSendbird().state, stores = _e.stores, config = _e.config;
  var sdk = (_a = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _a === void 0 ? void 0 : _a.sdk;
  var isSDKInitialized = (_b = stores === null || stores === void 0 ? void 0 : stores.sdkStore) === null || _b === void 0 ? void 0 : _b.initialized;
  var logger = config === null || config === void 0 ? void 0 : config.logger;
  var currentUserId = (_c = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId;
  var _f = (0, import_react50.useState)(null), currentChannel = _f[0], setChannel = _f[1];
  var _g = (0, import_react50.useState)(false), isChannelInitialized = _g[0], setChannelInitialized = _g[1];
  (0, import_react50.useEffect)(function() {
    if (!channelUrl || !sdk.openChannel) {
      setChannel(null);
      return;
    }
    sdk.openChannel.getChannel(channelUrl).then(function(channel) {
      logger.info("open channel setting: fetched", channel);
      channel.enter().then(function() {
        setChannel(channel);
        logger.info("OpenChannelSettings | Succeeded to enter channel", channel === null || channel === void 0 ? void 0 : channel.url);
        setChannelInitialized(true);
      }).catch(function(error) {
        setChannel(null);
        logger.warning("OpenChannelSettings | Failed to enter channel", error);
      });
    }).catch(function(error) {
      logger.error("open channel setting: error fetching", error);
      setChannel(null);
    });
    return function() {
      if (currentChannel && currentChannel.exit) {
        currentChannel.exit().then(function() {
          logger.info("OpenChannelSettings | Succeeded to exit channel", currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url);
        }).catch(function(error) {
          logger.warning("OpenChannelSettings | Failed to exit channel", error);
        });
      }
    };
  }, [channelUrl, isSDKInitialized]);
  (0, import_react50.useEffect)(function() {
    var _a2;
    var channelHandlerId = uuidv4();
    if (currentChannel !== null && ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a2 === void 0 ? void 0 : _a2.addOpenChannelHandler)) {
      var channelHandlerParams = new Ae({
        onOperatorUpdated: function(channel) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(channel);
          }
        },
        onUserMuted: function(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onUserUnmuted: function(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onUserBanned: function(channel, user) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(null);
          }
        },
        onUserUnbanned: function(channel, user) {
          if ((user === null || user === void 0 ? void 0 : user.userId) === currentUserId) {
            setChannel(channel);
          }
        },
        onChannelChanged: function(channel) {
          if ((channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(channel);
          }
        },
        onChannelDeleted: function(channelUrl2) {
          if (channelUrl2 === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setChannel(null);
          }
        }
      });
      sdk.openChannel.addOpenChannelHandler(channelHandlerId, channelHandlerParams);
    }
    return function() {
      var _a3, _b2, _c2;
      if (((_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a3 === void 0 ? void 0 : _a3.removeOpenChannelHandler) && channelHandlerId) {
        logger.info("OpenChannelSettings | Removing channel handlers", channelHandlerId);
        (_c2 = (_b2 = sdk.openChannel).removeOpenChannelHandler) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, channelHandlerId);
      }
    };
  }, [channelUrl]);
  return import_react50.default.createElement(
    OpenChannelSettingsContext.Provider,
    { value: {
      channelUrl,
      channel: currentChannel,
      isChannelInitialized,
      setChannel,
      onCloseClick,
      onChannelModified,
      onBeforeUpdateChannel,
      onDeleteChannel
    } },
    import_react50.default.createElement(UserProfileProvider, { isOpenChannel: true, renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile, disableUserProfile: (_d = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _d !== void 0 ? _d : config === null || config === void 0 ? void 0 : config.disableUserProfile }, children)
  );
};
var useOpenChannelSettingsContext = function() {
  var context = import_react50.default.useContext(OpenChannelSettingsContext);
  if (!context)
    throw new Error("OpenChannelSettingsContext not found. Use within the OpenChannelSettings module.");
  return context;
};

// node_modules/@sendbird/uikit-react/ui/AccordionGroup.js
var import_react51 = __toESM(require_react(), 1);
var AccordionGroupContext = (0, import_react51.createContext)({
  openedListKeys: [],
  addOpenedListKey: noop,
  removeOpenedListKey: noop,
  clearOpenedListKeys: noop,
  allowMultipleOpen: false
});
var AccordionGroupProvider = function(_a) {
  var className = _a.className, children = _a.children, _b = _a.allowMultipleOpen, allowMultipleOpen = _b === void 0 ? false : _b;
  var _c = (0, import_react51.useState)([]), openedListKeys = _c[0], setOpenedListKeys = _c[1];
  var addOpenedListKey = function(key) {
    setOpenedListKeys(function(prevList) {
      if (!allowMultipleOpen) {
        return [key];
      }
      prevList.push(key);
      return prevList;
    });
  };
  var removeOpenedListKey = function(key) {
    setOpenedListKeys(function(prevList) {
      return prevList.filter(function(k) {
        return k !== key;
      });
    });
  };
  var clearOpenedListKeys = function() {
    setOpenedListKeys([]);
  };
  return import_react51.default.createElement(
    "div",
    { className: "sendbird-accordion-group-provider ".concat(className) },
    import_react51.default.createElement(AccordionGroupContext.Provider, { value: {
      openedListKeys,
      addOpenedListKey,
      removeOpenedListKey,
      clearOpenedListKeys,
      allowMultipleOpen
    } }, children)
  );
};
var useAccordionGroupContext = function() {
  var context = (0, import_react51.useContext)(AccordionGroupContext);
  if (!context)
    throw new Error("No accordion group context available. Make sure you are rending <AccordionGroupContext />.");
  return context;
};

// node_modules/@sendbird/uikit-react/useSendbirdStateContext.js
var import_react52 = __toESM(require_react(), 1);
function useSendbirdStateContext() {
  var _a = useSendbird(), state = _a.state, actions = _a.actions;
  return __assign(__assign({}, state), actions);
}

// node_modules/@sendbird/uikit-react/chunks/bundle-CzTsBLUn.js
var import_react53 = __toESM(require_react(), 1);
var import_react_dom28 = __toESM(require_react_dom(), 1);
var GroupChannelListUIView = function(_a) {
  var renderHeader = _a.renderHeader, renderPlaceHolderError = _a.renderPlaceHolderError, renderPlaceHolderLoading = _a.renderPlaceHolderLoading, renderPlaceHolderEmptyList = _a.renderPlaceHolderEmptyList, onChangeTheme = _a.onChangeTheme, onUserProfileUpdated = _a.onUserProfileUpdated, allowProfileEdit = _a.allowProfileEdit, channels = _a.channels, onLoadMore = _a.onLoadMore, initialized = _a.initialized, renderChannel = _a.renderChannel, renderAddChannel = _a.renderAddChannel, scrollRef = _a.scrollRef;
  var _b = (0, import_react53.useState)(false), showProfileEdit = _b[0], setShowProfileEdit = _b[1];
  var stores = useSendbird().state.stores;
  var renderer = {
    addChannel: renderAddChannel,
    channel: renderChannel,
    placeholder: {
      loading: function() {
        if (initialized)
          return null;
        if (renderPlaceHolderLoading)
          return renderPlaceHolderLoading();
        return import_react53.default.createElement(PlaceHolder, { type: PlaceHolderTypes.LOADING });
      },
      empty: function() {
        if (!initialized)
          return null;
        if (renderPlaceHolderEmptyList)
          return renderPlaceHolderEmptyList();
        return import_react53.default.createElement(PlaceHolder, { type: PlaceHolderTypes.NO_CHANNELS });
      },
      error: function() {
        if (!initialized || !stores.sdkStore.error)
          return null;
        if (renderPlaceHolderError)
          return renderPlaceHolderError();
        return import_react53.default.createElement(PlaceHolder, { type: PlaceHolderTypes.WRONG });
      }
    }
  };
  return import_react53.default.createElement(
    import_react53.default.Fragment,
    null,
    import_react53.default.createElement("div", { className: "sendbird-channel-list__header" }, (renderHeader === null || renderHeader === void 0 ? void 0 : renderHeader()) || import_react53.default.createElement(GroupChannelListHeader, { onEdit: function() {
      return allowProfileEdit && setShowProfileEdit(true);
    }, allowProfileEdit, renderIconButton: function() {
      return renderer.addChannel();
    } })),
    showProfileEdit && import_react53.default.createElement(EditUserProfile, { onThemeChange: onChangeTheme, onCancel: function() {
      return setShowProfileEdit(false);
    }, onEditProfile: function(user) {
      setShowProfileEdit(false);
      onUserProfileUpdated(user);
    } }),
    import_react53.default.createElement(ChannelListComponent, { data: channels, renderItem: renderer.channel, onLoadMore, placeholderLoading: renderer.placeholder.loading(), placeholderEmpty: renderer.placeholder.empty(), placeholderError: renderer.placeholder.error(), scrollRef })
  );
};
var ChannelListComponent = function(props) {
  var data = props.data, renderItem = props.renderItem, onLoadMore = props.onLoadMore, placeholderLoading = props.placeholderLoading, placeholderError = props.placeholderError, placeholderEmpty = props.placeholderEmpty, scrollRef = props.scrollRef;
  var onScroll = useOnScrollPositionChangeDetector({
    onReachedBottom: function() {
      return onLoadMore === null || onLoadMore === void 0 ? void 0 : onLoadMore();
    }
  });
  return import_react53.default.createElement(
    "div",
    { className: "sendbird-channel-list__body", onScroll, ref: scrollRef },
    placeholderError,
    import_react53.default.createElement("div", null, data.map(function(item, index) {
      return renderItem({ item, index });
    })),
    placeholderLoading,
    data.length === 0 && placeholderEmpty
  );
};
var filterUser = function(idsToFilter) {
  return function(currentId) {
    return idsToFilter === null || idsToFilter === void 0 ? void 0 : idsToFilter.includes(currentId);
  };
};
var setChannelType = function(params, type) {
  if (type === "broadcast") {
    params.isBroadcast = true;
  }
  if (type === "supergroup") {
    params.isSuper = true;
  }
  return params;
};
var createDefaultUserListQuery = function(_a) {
  var sdk = _a.sdk, userFilledApplicationUserListQuery = _a.userFilledApplicationUserListQuery;
  var params = sdk.createApplicationUserListQuery();
  if (userFilledApplicationUserListQuery) {
    Object.keys(userFilledApplicationUserListQuery).forEach(function(key) {
      params[key] = userFilledApplicationUserListQuery[key];
    });
  }
  return params;
};
var CHANNEL_TYPE;
(function(CHANNEL_TYPE2) {
  CHANNEL_TYPE2["GROUP"] = "group";
  CHANNEL_TYPE2["SUPERGROUP"] = "supergroup";
  CHANNEL_TYPE2["BROADCAST"] = "broadcast";
})(CHANNEL_TYPE || (CHANNEL_TYPE = {}));
var CreateChannelContext = import_react53.default.createContext(null);
var initialState7 = {
  sdk: void 0,
  userListQuery: void 0,
  onCreateChannelClick: void 0,
  onChannelCreated: void 0,
  onBeforeCreateChannel: void 0,
  pageStep: 0,
  type: CHANNEL_TYPE.GROUP,
  onCreateChannel: void 0,
  overrideInviteUser: void 0
};
var CreateChannelManager = function(props) {
  var onCreateChannelClick = props.onCreateChannelClick, onBeforeCreateChannel = props.onBeforeCreateChannel, onChannelCreated = props.onChannelCreated, userListQuery = props.userListQuery, onCreateChannel = props.onCreateChannel, overrideInviteUser = props.overrideInviteUser;
  var updateState = useCreateChannelStore().updateState;
  var config = useSendbird().state.config;
  var _userListQuery = userListQuery !== null && userListQuery !== void 0 ? userListQuery : config === null || config === void 0 ? void 0 : config.userListQuery;
  (0, import_react53.useEffect)(function() {
    updateState({
      onCreateChannelClick,
      onBeforeCreateChannel,
      onChannelCreated,
      userListQuery: _userListQuery,
      onCreateChannel,
      overrideInviteUser
    });
  }, [
    onCreateChannelClick,
    onBeforeCreateChannel,
    onChannelCreated,
    userListQuery,
    onCreateChannel,
    overrideInviteUser,
    _userListQuery
  ]);
  return null;
};
var CreateChannelProvider = function(props) {
  var children = props.children;
  return import_react53.default.createElement(
    InternalCreateChannelProvider,
    __assign({}, props),
    import_react53.default.createElement(CreateChannelManager, __assign({}, props)),
    children
  );
};
var createCreateChannelStore = function(props) {
  return createStore(__assign(__assign({}, initialState7), props));
};
var InternalCreateChannelProvider = function(props) {
  var children = props.children;
  var defaultProps = deleteNullish({
    userListQuery: props === null || props === void 0 ? void 0 : props.userListQuery,
    onCreateChannelClick: props === null || props === void 0 ? void 0 : props.onCreateChannelClick,
    onChannelCreated: props === null || props === void 0 ? void 0 : props.onChannelCreated,
    onBeforeCreateChannel: props === null || props === void 0 ? void 0 : props.onBeforeCreateChannel,
    onCreateChannel: props === null || props === void 0 ? void 0 : props.onCreateChannel,
    overrideInviteUser: props === null || props === void 0 ? void 0 : props.overrideInviteUser
  });
  var storeRef = (0, import_react53.useRef)(createCreateChannelStore(defaultProps));
  return import_react53.default.createElement(CreateChannelContext.Provider, { value: storeRef.current }, children);
};
var useCreateChannelStore = function() {
  return useStore(CreateChannelContext, function(state) {
    return state;
  }, initialState7);
};
var useCreateChannel = function() {
  var store = (0, import_react53.useContext)(CreateChannelContext);
  var sendbirdStore = useSendbirdStateContext();
  if (!store)
    throw new Error("useCreateChannel must be used within a CreateChannelProvider");
  var state = shimExports.useSyncExternalStore(store.subscribe, store.getState);
  var actions = (0, import_react53.useMemo)(function() {
    return {
      setPageStep: function(pageStep) {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { pageStep });
        });
      },
      setType: function(type) {
        return store.setState(function(state2) {
          return __assign(__assign({}, state2), { type });
        });
      },
      createChannel: getCreateGroupChannel(sendbirdStore)
    };
  }, [store]);
  return { state, actions };
};
var BUFFER = 50;
var InviteUsers = function(_a) {
  var onCancel = _a.onCancel, userListQuery = _a.userListQuery;
  var _b = useCreateChannel(), _c = _b.state, onCreateChannelClick = _c.onCreateChannelClick, onBeforeCreateChannel = _c.onBeforeCreateChannel, onChannelCreated = _c.onChannelCreated, onCreateChannel = _c.onCreateChannel, overrideInviteUser = _c.overrideInviteUser, type = _c.type, createChannel = _b.actions.createChannel;
  var _d = useSendbird().state, userId = _d.config.userId, sdk = _d.stores.sdkStore.sdk;
  var idsToFilter = [userId];
  var _e = (0, import_react53.useState)([]), users = _e[0], setUsers = _e[1];
  var _f = (0, import_react53.useState)({}), selectedUsers = _f[0], setSelectedUsers = _f[1];
  var stringSet = (0, import_react53.useContext)(LocalizationContext).stringSet;
  var _g = (0, import_react53.useState)(null), usersDataSource = _g[0], setUsersDataSource = _g[1];
  var selectedCount = Object.keys(selectedUsers).length;
  var titleText = stringSet.MODAL__CREATE_CHANNEL__TITLE;
  var submitText = stringSet.BUTTON__CREATE;
  var isMobile = useMediaQueryContext().isMobile;
  var _h = (0, import_react53.useState)(window.innerHeight), scrollableAreaHeight = _h[0], setScrollableAreaHeight = _h[1];
  (0, import_react53.useEffect)(function() {
    var applicationUserListQuery = userListQuery ? userListQuery() : createDefaultUserListQuery({ sdk });
    setUsersDataSource(applicationUserListQuery);
    if (!(applicationUserListQuery === null || applicationUserListQuery === void 0 ? void 0 : applicationUserListQuery.isLoading)) {
      applicationUserListQuery.next().then(function(it) {
        setUsers(it);
      });
    }
  }, []);
  (0, import_react53.useEffect)(function() {
    var scrollableAreaHeight2 = function() {
      setScrollableAreaHeight(window.innerHeight);
    };
    window.addEventListener("resize", scrollableAreaHeight2);
    return function() {
      window.removeEventListener("resize", scrollableAreaHeight2);
    };
  }, []);
  return import_react53.default.createElement(
    Modal,
    {
      isFullScreenOnMobile: true,
      titleText,
      submitText,
      type: ButtonTypes.PRIMARY,
      // Disable the create button if no users are selected,
      // but if there's only the logged-in user in the user list,
      // then the create button should be enabled
      disabled: users.length > 1 && Object.keys(selectedUsers).length === 0,
      onCancel,
      onSubmit: function() {
        var selectedUserList = Object.keys(selectedUsers).length > 0 ? Object.keys(selectedUsers) : [userId];
        var _onChannelCreated = onChannelCreated !== null && onChannelCreated !== void 0 ? onChannelCreated : onCreateChannel;
        var _onCreateChannelClick = onCreateChannelClick !== null && onCreateChannelClick !== void 0 ? onCreateChannelClick : overrideInviteUser;
        if (typeof _onCreateChannelClick === "function") {
          _onCreateChannelClick({
            users: selectedUserList,
            onClose: onCancel !== null && onCancel !== void 0 ? onCancel : noop,
            channelType: type
          });
          return;
        }
        if (onBeforeCreateChannel) {
          var params = onBeforeCreateChannel(selectedUserList);
          setChannelType(params, type);
          createChannel(params).then(function(channel) {
            return _onChannelCreated === null || _onChannelCreated === void 0 ? void 0 : _onChannelCreated(channel);
          });
        } else {
          var params = {};
          params.invitedUserIds = selectedUserList;
          params.isDistinct = false;
          if (userId) {
            params.operatorUserIds = [userId];
          }
          setChannelType(params, type);
          createChannel(params).then(function(channel) {
            return _onChannelCreated === null || _onChannelCreated === void 0 ? void 0 : _onChannelCreated(channel);
          });
        }
        onCancel === null || onCancel === void 0 ? void 0 : onCancel();
      }
    },
    import_react53.default.createElement(
      "div",
      null,
      import_react53.default.createElement(Label, { color: selectedCount > 0 ? LabelColors.PRIMARY : LabelColors.ONBACKGROUND_3, type: LabelTypography.CAPTION_1 }, "".concat(selectedCount, " ").concat(stringSet.MODAL__INVITE_MEMBER__SELECTED)),
      import_react53.default.createElement("div", { className: "sendbird-create-channel--scroll", style: isMobile ? { height: "calc(".concat(scrollableAreaHeight, "px - 200px)") } : {}, onScroll: function(e) {
        if (!usersDataSource)
          return;
        var eventTarget = e.target;
        var hasNext = usersDataSource.hasNext, isLoading = usersDataSource.isLoading;
        var fetchMore = eventTarget.clientHeight + eventTarget.scrollTop + BUFFER > eventTarget.scrollHeight;
        if (hasNext && fetchMore && !isLoading) {
          usersDataSource.next().then(function(usersBatch) {
            setUsers(__spreadArray(__spreadArray([], users, true), usersBatch, true));
          });
        }
      } }, users.map(function(user) {
        return !filterUser(idsToFilter)(user.userId) && import_react53.default.createElement(UserListItem, { key: user.userId, user, checkBox: true, checked: selectedUsers[user.userId], onChange: function(event) {
          var _a2;
          var modifiedSelectedUsers = __assign(__assign({}, selectedUsers), (_a2 = {}, _a2[event.target.id] = event.target.checked, _a2));
          if (!event.target.checked) {
            delete modifiedSelectedUsers[event.target.id];
          }
          setSelectedUsers(modifiedSelectedUsers);
        } });
      }))
    )
  );
};
var isBroadcastChannelEnabled = function(sdk) {
  var _a;
  var ALLOW_BROADCAST_CHANNEL = "allow_broadcast_channel";
  var applicationAttributes = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.applicationAttributes;
  if (Array.isArray(applicationAttributes)) {
    return applicationAttributes.includes(ALLOW_BROADCAST_CHANNEL);
  }
  return false;
};
var isSuperGroupChannelEnabled = function(sdk) {
  var _a;
  var ALLOW_SUPER_GROUP_CHANNEL = "allow_super_group_channel";
  var applicationAttributes = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.applicationAttributes;
  if (Array.isArray(applicationAttributes)) {
    return applicationAttributes.includes(ALLOW_SUPER_GROUP_CHANNEL);
  }
  return false;
};
var SelectChannelType = function(props) {
  var onCancel = props.onCancel;
  var state = useSendbird().state;
  var sdk = getSdk(state);
  var _a = useCreateChannel().actions, setPageStep = _a.setPageStep, setType = _a.setType;
  var stringSet = (0, import_react53.useContext)(LocalizationContext).stringSet;
  var isBroadcastAvailable = isBroadcastChannelEnabled(sdk);
  var isSupergroupAvailable = isSuperGroupChannelEnabled(sdk);
  return import_react53.default.createElement(
    Modal,
    { titleText: stringSet === null || stringSet === void 0 ? void 0 : stringSet.MODAL__CREATE_CHANNEL__TITLE, hideFooter: true, onCancel: function() {
      onCancel === null || onCancel === void 0 ? void 0 : onCancel();
    }, className: "sendbird-add-channel__modal" },
    import_react53.default.createElement(
      "div",
      { className: "sendbird-add-channel__rectangle-wrap" },
      import_react53.default.createElement(
        "div",
        { className: "sendbird-add-channel__rectangle", onClick: function() {
          setType(CHANNEL_TYPE.GROUP);
          setPageStep(1);
        }, role: "button", tabIndex: 0, onKeyDown: function() {
          setType(CHANNEL_TYPE.GROUP);
          setPageStep(1);
        } },
        import_react53.default.createElement(Icon, { className: "sendbird-add-channel__rectangle__chat-icon", type: IconTypes.CHAT, fillColor: IconColors.PRIMARY, width: "28px", height: "28px" }),
        import_react53.default.createElement(Label, { type: LabelTypography.SUBTITLE_1, color: LabelColors.ONBACKGROUND_1 }, stringSet.MODAL__CREATE_CHANNEL__GROUP)
      ),
      isSupergroupAvailable && import_react53.default.createElement(
        "div",
        { className: "sendbird-add-channel__rectangle", onClick: function() {
          setType(CHANNEL_TYPE.SUPERGROUP);
          setPageStep(1);
        }, role: "button", tabIndex: 0, onKeyDown: function() {
          setType(CHANNEL_TYPE.SUPERGROUP);
          setPageStep(1);
        } },
        import_react53.default.createElement(Icon, { className: "sendbird-add-channel__rectangle__supergroup-icon", type: IconTypes.SUPERGROUP, fillColor: IconColors.PRIMARY, width: "28px", height: "28px" }),
        import_react53.default.createElement(Label, { type: LabelTypography.SUBTITLE_1, color: LabelColors.ONBACKGROUND_1 }, stringSet.MODAL__CREATE_CHANNEL__SUPER)
      ),
      isBroadcastAvailable && import_react53.default.createElement(
        "div",
        { className: "sendbird-add-channel__rectangle", onClick: function() {
          setType(CHANNEL_TYPE.BROADCAST);
          setPageStep(1);
        }, role: "button", tabIndex: 0, onKeyDown: function() {
          setType(CHANNEL_TYPE.BROADCAST);
          setPageStep(1);
        } },
        import_react53.default.createElement(Icon, { className: "sendbird-add-channel__rectangle__broadcast-icon", type: IconTypes.BROADCAST, fillColor: IconColors.PRIMARY, width: "28px", height: "28px" }),
        import_react53.default.createElement(Label, { type: LabelTypography.SUBTITLE_1, color: LabelColors.ONBACKGROUND_1 }, stringSet.MODAL__CREATE_CHANNEL__BROADCAST)
      )
    )
  );
};
var CreateChannel$1 = function(props) {
  var onCancel = props.onCancel, renderStepOne = props.renderStepOne;
  var _a = useCreateChannel(), _b = _a.state, pageStep = _b.pageStep, userListQuery = _b.userListQuery, setPageStep = _a.actions.setPageStep;
  return import_react53.default.createElement(
    import_react53.default.Fragment,
    null,
    pageStep === 0 && ((renderStepOne === null || renderStepOne === void 0 ? void 0 : renderStepOne()) || import_react53.default.createElement(SelectChannelType, { onCancel })),
    pageStep === 1 && import_react53.default.createElement(InviteUsers, { userListQuery, onCancel: function() {
      setPageStep(0);
      onCancel === null || onCancel === void 0 ? void 0 : onCancel();
    } })
  );
};
var CreateChannel = function(props) {
  return import_react53.default.createElement(
    CreateChannelProvider,
    __assign({}, props),
    import_react53.default.createElement(CreateChannel$1, __assign({}, props))
  );
};
var AddGroupChannelView = function(_a) {
  var createChannelVisible = _a.createChannelVisible, onChangeCreateChannelVisible = _a.onChangeCreateChannelVisible, onBeforeCreateChannel = _a.onBeforeCreateChannel, onCreateChannelClick = _a.onCreateChannelClick, onChannelCreated = _a.onChannelCreated;
  var config = useSendbird().state.config;
  return import_react53.default.createElement(
    import_react53.default.Fragment,
    null,
    import_react53.default.createElement(
      IconButton,
      { height: "32px", width: "32px", disabled: !config.isOnline, onClick: function() {
        return onChangeCreateChannelVisible(true);
      } },
      import_react53.default.createElement(Icon, { type: IconTypes.CREATE, fillColor: IconColors.PRIMARY, width: "24px", height: "24px" })
    ),
    createChannelVisible && import_react53.default.createElement(CreateChannel, { onCancel: function() {
      return onChangeCreateChannelVisible(false);
    }, onChannelCreated: function(channel) {
      onChannelCreated === null || onChannelCreated === void 0 ? void 0 : onChannelCreated(channel);
      onChangeCreateChannelVisible(false);
    }, onBeforeCreateChannel, onCreateChannelClick })
  );
};
var AddGroupChannel = function() {
  var _a = (0, import_react53.useState)(false), createChannelVisible = _a[0], setCreateChannelVisible = _a[1];
  var _b = useGroupChannelList2().state, onChannelCreated = _b.onChannelCreated, onBeforeCreateChannel = _b.onBeforeCreateChannel, onCreateChannelClick = _b.onCreateChannelClick;
  return import_react53.default.createElement(AddGroupChannelView, { createChannelVisible, onChangeCreateChannelVisible: setCreateChannelVisible, onCreateChannelClick, onBeforeCreateChannel, onChannelCreated });
};
var GroupChannelListUI = function(props) {
  var renderHeader = props.renderHeader, renderChannelPreview = props.renderChannelPreview, renderPlaceHolderError = props.renderPlaceHolderError, renderPlaceHolderLoading = props.renderPlaceHolderLoading, renderPlaceHolderEmptyList = props.renderPlaceHolderEmptyList;
  var _a = useGroupChannelList2().state, onChannelSelect = _a.onChannelSelect, onThemeChange = _a.onThemeChange, allowProfileEdit = _a.allowProfileEdit, typingChannelUrls = _a.typingChannelUrls, groupChannels = _a.groupChannels, initialized = _a.initialized, selectedChannelUrl = _a.selectedChannelUrl, loadMore = _a.loadMore, onUserProfileUpdated = _a.onUserProfileUpdated, scrollRef = _a.scrollRef;
  var _b = useSendbird().state, stores = _b.stores, _c = _b.config, logger = _c.logger, isOnline = _c.isOnline;
  var sdk = stores.sdkStore.sdk;
  var renderListItem = function(renderProps) {
    var channel = renderProps.item, index = renderProps.index;
    var itemProps = {
      channel,
      tabIndex: index,
      isSelected: channel.url === selectedChannelUrl,
      isTyping: typingChannelUrls.includes(channel.url),
      renderChannelAction: function(props2) {
        return import_react53.default.createElement(GroupChannelPreviewAction, __assign({}, props2));
      },
      onClick: function() {
        if (isOnline || (sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled)) {
          logger.info("ChannelList: Clicked on channel:", channel);
          onChannelSelect(channel);
        } else {
          logger.warning("ChannelList: Inactivated clicking channel item during offline.");
        }
      },
      onLeaveChannel: function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                logger.info("ChannelList: Leaving channel", channel);
                return [4, channel.leave()];
              case 1:
                _a2.sent();
                logger.info("ChannelList: Leaving channel success");
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
    };
    if (renderChannelPreview) {
      return import_react53.default.createElement("div", { key: channel.url, onClick: itemProps.onClick }, renderChannelPreview(itemProps));
    }
    return import_react53.default.createElement(GroupChannelListItem, __assign({ key: channel.url }, itemProps));
  };
  return import_react53.default.createElement(GroupChannelListUIView, { renderHeader, renderChannel: renderListItem, renderPlaceHolderError, renderPlaceHolderLoading, renderPlaceHolderEmptyList, onChangeTheme: onThemeChange !== null && onThemeChange !== void 0 ? onThemeChange : noop, allowProfileEdit, onUserProfileUpdated: onUserProfileUpdated !== null && onUserProfileUpdated !== void 0 ? onUserProfileUpdated : noop, channels: groupChannels, onLoadMore: loadMore, initialized, renderAddChannel: function() {
    return import_react53.default.createElement(AddGroupChannel, null);
  }, scrollRef });
};
var GroupChannelList = function(props) {
  return import_react53.default.createElement(
    GroupChannelListProvider,
    __assign({}, props),
    import_react53.default.createElement(GroupChannelListUI, __assign({}, props))
  );
};
var AddChannel = function() {
  var _a = (0, import_react53.useState)(false), showModal = _a[0], setShowModal = _a[1];
  var _b = useChannelListContext(), overrideInviteUser = _b.overrideInviteUser, onBeforeCreateChannel = _b.onBeforeCreateChannel, onChannelSelect = _b.onChannelSelect;
  return import_react53.default.createElement(AddGroupChannelView, { createChannelVisible: showModal, onChangeCreateChannelVisible: setShowModal, onCreateChannelClick: overrideInviteUser, onBeforeCreateChannel, onChannelCreated: function(it) {
    return onChannelSelect === null || onChannelSelect === void 0 ? void 0 : onChannelSelect(it);
  } });
};
var ChannelListUI = function(props) {
  var renderHeader = props.renderHeader, renderChannelPreview = props.renderChannelPreview, renderPlaceHolderError = props.renderPlaceHolderError, renderPlaceHolderLoading = props.renderPlaceHolderLoading, renderPlaceHolderEmptyList = props.renderPlaceHolderEmptyList;
  var _a = useChannelListContext(), onThemeChange = _a.onThemeChange, allowProfileEdit = _a.allowProfileEdit, allChannels = _a.allChannels, currentChannel = _a.currentChannel, channelListDispatcher = _a.channelListDispatcher, typingChannels = _a.typingChannels, initialized = _a.initialized, fetchChannelList = _a.fetchChannelList, onProfileEditSuccess = _a.onProfileEditSuccess;
  var state = useSendbird().state;
  var stores = state.stores, config = state.config;
  var logger = config.logger, _b = config.isOnline, isOnline = _b === void 0 ? false : _b;
  var sdk = stores.sdkStore.sdk;
  var renderListItem = function(props2) {
    var channel = props2.item, index = props2.index;
    var previewProps = {
      channel,
      tabIndex: index,
      isSelected: (channel === null || channel === void 0 ? void 0 : channel.url) === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url),
      isTyping: typingChannels === null || typingChannels === void 0 ? void 0 : typingChannels.some(function(_a2) {
        var url = _a2.url;
        return url === (channel === null || channel === void 0 ? void 0 : channel.url);
      }),
      renderChannelAction: function(props3) {
        return import_react53.default.createElement(GroupChannelPreviewAction, __assign({}, props3));
      },
      onClick: function() {
        if (!isOnline && !(sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled)) {
          logger.warning("ChannelList: Inactivated clicking channel item during offline.");
          return;
        }
        logger.info("ChannelList: Clicked on channel:", channel);
        channelListDispatcher({
          type: SET_CURRENT_CHANNEL,
          payload: channel
        });
      },
      onLeaveChannel: function(channel2, cb) {
        return __awaiter(this, void 0, void 0, function() {
          var response, err_1;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                logger.info("ChannelList: Leaving channel", channel2);
                if (!channel2)
                  return [3, 4];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, channel2.leave()];
              case 2:
                response = _a2.sent();
                logger.info("ChannelList: Leaving channel success", response);
                if (cb && typeof cb === "function")
                  cb(channel2, null);
                channelListDispatcher({
                  type: LEAVE_CHANNEL_SUCCESS,
                  payload: channel2.url
                });
                return [3, 4];
              case 3:
                err_1 = _a2.sent();
                logger.error("ChannelList: Leaving channel failed", err_1);
                if (cb && typeof cb === "function")
                  cb(channel2, err_1);
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
    };
    if (renderChannelPreview) {
      return import_react53.default.createElement("div", { key: channel === null || channel === void 0 ? void 0 : channel.url, onClick: previewProps.onClick }, renderChannelPreview(previewProps));
    }
    return import_react53.default.createElement(ChannelPreview, __assign({ key: channel === null || channel === void 0 ? void 0 : channel.url }, previewProps));
  };
  return import_react53.default.createElement(GroupChannelListUIView, { renderHeader, renderChannel: renderListItem, renderPlaceHolderError, renderPlaceHolderLoading, renderPlaceHolderEmptyList, onChangeTheme: onThemeChange !== null && onThemeChange !== void 0 ? onThemeChange : noop, allowProfileEdit, onUserProfileUpdated: onProfileEditSuccess !== null && onProfileEditSuccess !== void 0 ? onProfileEditSuccess : noop, channels: allChannels, onLoadMore: fetchChannelList, initialized, renderAddChannel: function() {
    return import_react53.default.createElement(AddChannel, null);
  } });
};
var ChannelList = function(props) {
  return import_react53.default.createElement(
    ChannelListProvider,
    __assign({}, props),
    import_react53.default.createElement(ChannelListUI, __assign({}, props))
  );
};
var PANELS;
(function(PANELS2) {
  PANELS2["CHANNEL_LIST"] = "CHANNEL_LIST";
  PANELS2["CHANNEL"] = "CHANNEL";
  PANELS2["CHANNEL_SETTINGS"] = "CHANNEL_SETTINGS";
  PANELS2["MESSAGE_SEARCH"] = "MESSAGE_SEARCH";
  PANELS2["THREAD"] = "THREAD";
})(PANELS || (PANELS = {}));
var MobileLayout = function(props) {
  var _a, _b, _c;
  var replyType = props.replyType, isMessageGroupingEnabled = props.isMessageGroupingEnabled, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, allowProfileEdit = props.allowProfileEdit, isReactionEnabled = props.isReactionEnabled, showSearchIcon = props.showSearchIcon, onProfileEditSuccess = props.onProfileEditSuccess, currentChannel = props.currentChannel, setCurrentChannel = props.setCurrentChannel, startingPoint = props.startingPoint, setStartingPoint = props.setStartingPoint, threadTargetMessage = props.threadTargetMessage, setThreadTargetMessage = props.setThreadTargetMessage, highlightedMessage = props.highlightedMessage, setHighlightedMessage = props.setHighlightedMessage, enableLegacyChannelModules = props.enableLegacyChannelModules;
  var _d = (0, import_react53.useState)(PANELS.CHANNEL_LIST), panel = _d[0], setPanel = _d[1];
  var store = useSendbird().state;
  var sdk = (_b = (_a = store === null || store === void 0 ? void 0 : store.stores) === null || _a === void 0 ? void 0 : _a.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;
  var userId = (_c = store === null || store === void 0 ? void 0 : store.config) === null || _c === void 0 ? void 0 : _c.userId;
  var pause = useVoicePlayerContext().pause;
  var goToMessage = function(message, timeoutCb) {
    setStartingPoint === null || setStartingPoint === void 0 ? void 0 : setStartingPoint((message === null || message === void 0 ? void 0 : message.createdAt) || null);
    setTimeout(function() {
      timeoutCb === null || timeoutCb === void 0 ? void 0 : timeoutCb((message === null || message === void 0 ? void 0 : message.messageId) || null);
    }, 500);
  };
  (0, import_react53.useEffect)(function() {
    if (panel !== PANELS.CHANNEL) {
      goToMessage(null, function() {
        return setHighlightedMessage === null || setHighlightedMessage === void 0 ? void 0 : setHighlightedMessage(null);
      });
    }
  }, [panel]);
  (0, import_react53.useEffect)(function() {
    var _a2, _b2;
    var handlerId = uuidv4();
    if ((_a2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a2 === void 0 ? void 0 : _a2.addGroupChannelHandler) {
      var handler = new Ye({
        onUserBanned: function(groupChannel, user) {
          if (groupChannel.url === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === userId) {
            setPanel(PANELS.CHANNEL_LIST);
          }
        },
        onChannelDeleted: function(channelUrl) {
          if (channelUrl === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {
            setPanel(PANELS.CHANNEL_LIST);
          }
        },
        onUserLeft: function(groupChannel, user) {
          if (groupChannel.url === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) && (user === null || user === void 0 ? void 0 : user.userId) === userId) {
            setPanel(PANELS.CHANNEL_LIST);
          }
        }
      });
      (_b2 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b2 === void 0 ? void 0 : _b2.addGroupChannelHandler(handlerId, handler);
    }
    return function() {
      var _a3, _b3;
      (_b3 = (_a3 = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a3 === void 0 ? void 0 : _a3.removeGroupChannelHandler) === null || _b3 === void 0 ? void 0 : _b3.call(_a3, handlerId);
    };
  }, [sdk, currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);
  (0, import_react53.useEffect)(function() {
    if (panel === PANELS.THREAD) {
      setPanel(PANELS.CHANNEL);
    }
  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);
  var channelListProps = {
    allowProfileEdit,
    onProfileEditSuccess,
    disableAutoSelect: true,
    onChannelSelect: function(channel) {
      setCurrentChannel(channel !== null && channel !== void 0 ? channel : void 0);
      if (channel) {
        setPanel(PANELS.CHANNEL);
      } else {
        setPanel(PANELS.CHANNEL_LIST);
      }
    },
    // for GroupChannelList
    onChannelCreated: function(channel) {
      setCurrentChannel(channel);
      setPanel(PANELS.CHANNEL);
    },
    onUserProfileUpdated: onProfileEditSuccess
  };
  var channelProps = {
    channelUrl: (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) || "",
    onChatHeaderActionClick: function() {
      setPanel(PANELS.CHANNEL_SETTINGS);
    },
    onBackClick: function() {
      setPanel(PANELS.CHANNEL_LIST);
      pause(ALL);
    },
    onSearchClick: function() {
      setPanel(PANELS.MESSAGE_SEARCH);
    },
    onReplyInThread: function(_a2) {
      var message = _a2.message;
      if (replyType === "THREAD") {
        setPanel(PANELS.THREAD);
        setThreadTargetMessage(message);
      }
    },
    onQuoteMessageClick: function(_a2) {
      var message = _a2.message;
      if (replyType === "THREAD") {
        setThreadTargetMessage(message);
        setPanel(PANELS.THREAD);
      }
    },
    animatedMessage: highlightedMessage,
    onMessageAnimated: function() {
      return setHighlightedMessage === null || setHighlightedMessage === void 0 ? void 0 : setHighlightedMessage(null);
    },
    showSearchIcon,
    startingPoint: startingPoint !== null && startingPoint !== void 0 ? startingPoint : void 0,
    isReactionEnabled,
    replyType,
    isMessageGroupingEnabled,
    isMultipleFilesMessageEnabled,
    // for GroupChannel
    animatedMessageId: highlightedMessage,
    onReplyInThreadClick: function(_a2) {
      var message = _a2.message;
      if (replyType === "THREAD") {
        setPanel(PANELS.THREAD);
        setThreadTargetMessage(message);
      }
    }
  };
  return import_react53.default.createElement(
    "div",
    { className: "sb_mobile", id: APP_LAYOUT_ROOT },
    panel === PANELS.CHANNEL_LIST && import_react53.default.createElement("div", { className: "sb_mobile__panelwrap" }, enableLegacyChannelModules ? import_react53.default.createElement(ChannelList, __assign({}, channelListProps)) : import_react53.default.createElement(GroupChannelList, __assign({}, channelListProps))),
    panel === PANELS.CHANNEL && import_react53.default.createElement("div", { className: "sb_mobile__panelwrap" }, enableLegacyChannelModules ? import_react53.default.createElement(Channel, __assign({}, channelProps)) : import_react53.default.createElement(GroupChannel, __assign({}, channelProps))),
    panel === PANELS.CHANNEL_SETTINGS && import_react53.default.createElement(
      "div",
      { className: "sb_mobile__panelwrap" },
      import_react53.default.createElement(ChannelSettings, { channelUrl: (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) || "", onCloseClick: function() {
        setPanel(PANELS.CHANNEL);
      }, onLeaveChannel: function() {
        setPanel(PANELS.CHANNEL_LIST);
      } })
    ),
    panel === PANELS.MESSAGE_SEARCH && import_react53.default.createElement(
      "div",
      { className: "sb_mobile__panelwrap" },
      import_react53.default.createElement(MessageSearchPannel, { channelUrl: (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) || "", onCloseClick: function() {
        setPanel(PANELS.CHANNEL);
      }, onResultClick: function(message) {
        setPanel(PANELS.CHANNEL);
        goToMessage(message, function(messageId) {
          setHighlightedMessage === null || setHighlightedMessage === void 0 ? void 0 : setHighlightedMessage(messageId);
        });
      } })
    ),
    panel === PANELS.THREAD && import_react53.default.createElement(
      "div",
      { className: "sb_mobile__panelwrap" },
      import_react53.default.createElement(Thread, { channelUrl: (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) || "", message: threadTargetMessage, onHeaderActionClick: function() {
        setPanel(PANELS.CHANNEL);
        pause(ALL);
      }, onMoveToParentMessage: function(_a2) {
        var message = _a2.message, channel = _a2.channel;
        setCurrentChannel(channel);
        goToMessage(message, function(messageId) {
          setPanel(PANELS.CHANNEL);
          setHighlightedMessage === null || setHighlightedMessage === void 0 ? void 0 : setHighlightedMessage(messageId);
        });
      } })
    )
  );
};

export {
  pubSubFactory,
  useDeepCompareEffect,
  GroupChannel,
  useUnmount,
  useOnlineStatus,
  schedulerFactory,
  useMarkAsDeliveredScheduler,
  EmojiManager,
  mapColorKeys,
  cssVars,
  MessageSearchPannel,
  Thread,
  kFormatter,
  OpenChannelProvider,
  useOpenChannelContext,
  OpenChannelInput,
  OpenChannelMessageList$1,
  OpenChannelSettingsProvider,
  useOpenChannelSettingsContext,
  AccordionGroupProvider,
  useAccordionGroupContext,
  useSendbirdStateContext,
  GroupChannelList,
  ChannelList,
  MobileLayout
};
/*! Bundled license information:

css-vars-ponyfill/dist/css-vars-ponyfill.esm.js:
  (*!
   * css-vars-ponyfill
   * v2.4.9
   * https://jhildenbiddle.github.io/css-vars-ponyfill/
   * (c) 2018-2024 John Hildenbiddle <http://hildenbiddle.com>
   * MIT license
   *)
  (*!
   * get-css-data
   * v2.1.0
   * https://github.com/jhildenbiddle/get-css-data
   * (c) 2018-2022 John Hildenbiddle <http://hildenbiddle.com>
   * MIT license
   *)
  (**
   * Gets CSS data from <style> and <link> nodes (including @imports), then
   * returns data in order processed by DOM. Allows specifying nodes to
   * include/exclude and filtering CSS data using RegEx.
   *
   * @preserve
   * @param {object}   [options] The options object
   * @param {object}   [options.rootElement=document] Root element to traverse for
   *                   <link> and <style> nodes.
   * @param {string}   [options.include] CSS selector matching <link> and <style>
   *                   nodes to include
   * @param {string}   [options.exclude] CSS selector matching <link> and <style>
   *                   nodes to exclude
   * @param {object}   [options.filter] Regular expression used to filter node CSS
   *                   data. Each block of CSS data is tested against the filter,
   *                   and only matching data is included.
   * @param {boolean}  [options.skipDisabled=true] Determines if disabled
   *                   stylesheets will be skipped while collecting CSS data.
   * @param {boolean}  [options.useCSSOM=false] Determines if CSS data will be
   *                   collected from a stylesheet's runtime values instead of its
   *                   text content. This is required to get accurate CSS data
   *                   when a stylesheet has been modified using the deleteRule()
   *                   or insertRule() methods because these modifications will
   *                   not be reflected in the stylesheet's text content.
   * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
   *                   1) the XHR object, 2) source node reference, and 3) the
   *                   source URL as arguments.
   * @param {function} [options.onSuccess] Callback on each CSS node read. Passes
   *                   1) CSS text, 2) source node reference, and 3) the source
   *                   URL as arguments.
   * @param {function} [options.onError] Callback on each error. Passes 1) the XHR
   *                   object for inspection, 2) soure node reference, and 3) the
   *                   source URL that failed (either a <link> href or an @import)
   *                   as arguments
   * @param {function} [options.onComplete] Callback after all nodes have been
   *                   processed. Passes 1) concatenated CSS text, 2) an array of
   *                   CSS text in DOM order, and 3) an array of nodes in DOM
   *                   order as arguments.
   *
   * @example
   *
   *   getCssData({
   *     rootElement : document,
   *     include     : 'style,link[rel="stylesheet"]',
   *     exclude     : '[href="skip.css"]',
   *     filter      : /red/,
   *     skipDisabled: true,
   *     useCSSOM    : false,
   *     onBeforeSend(xhr, node, url) {
   *       // ...
   *     }
   *     onSuccess(cssText, node, url) {
   *       // ...
   *     }
   *     onError(xhr, node, url) {
   *       // ...
   *     },
   *     onComplete(cssText, cssArray, nodeArray) {
   *       // ...
   *     }
   *   });
   *)
  (**
   * Fetches, parses, and transforms CSS custom properties from specified
   * <style> and <link> elements into static values, then appends a new <style>
   * element with static values to the DOM to provide CSS custom property
   * compatibility for legacy browsers. Also provides a single interface for
   * live updates of runtime values in both modern and legacy browsers.
   *
   * @preserve
   * @param {object}   [options] Options object
   * @param {object}   [options.rootElement=document] Root element to traverse for
   *                   <link> and <style> nodes
   * @param {boolean}  [options.shadowDOM=false] Determines if shadow DOM <link>
   *                   and <style> nodes will be processed.
   * @param {string}   [options.include="style,link[rel=stylesheet]"] CSS selector
   *                   matching <link re="stylesheet"> and <style> nodes to
   *                   process
   * @param {string}   [options.exclude] CSS selector matching <link
   *                   rel="stylehseet"> and <style> nodes to exclude from those
   *                   matches by options.include
   * @param {object}   [options.variables] A map of custom property name/value
   *                   pairs. Property names can omit or include the leading
   *                   double-hyphen (), and values specified will override
   *                   previous values
   * @param {boolean}  [options.onlyLegacy=true] Determines if the ponyfill will
   *                   only generate legacy-compatible CSS in browsers that lack
   *                   native support (i.e., legacy browsers)
   * @param {boolean}  [options.preserveStatic=true] Determines if CSS
   *                   declarations that do not reference a custom property will
   *                   be preserved in the transformed CSS
   * @param {boolean}  [options.preserveVars=false] Determines if CSS custom
   *                   property declarations will be preserved in the transformed
   *                   CSS
   * @param {boolean}  [options.silent=false] Determines if warning and error
   *                   messages will be displayed on the console
   * @param {boolean}  [options.updateDOM=true] Determines if the ponyfill will
   *                   update the DOM after processing CSS custom properties
   * @param {boolean}  [options.updateURLs=true] Determines if relative url()
   *                   paths will be converted to absolute urls in external CSS
   * @param {boolean}  [options.watch=false] Determines if a MutationObserver will
   *                   be created that will execute the ponyfill when a <link> or
   *                   <style> DOM mutation is observed
   * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
   *                   1) the XHR object, 2) source node reference, and 3) the
   *                   source URL as arguments
   * @param {function} [options.onError] Callback after a CSS parsing error has
   *                   occurred or an XHR request has failed. Passes 1) an error
   *                   message, and 2) source node reference, 3) xhr, and 4 url as
   *                   arguments.
   * @param {function} [options.onWarning] Callback after each CSS parsing warning
   *                   has occurred. Passes 1) a warning message as an argument.
   * @param {function} [options.onSuccess] Callback after CSS data has been
   *                   collected from each node and before CSS custom properties
   *                   have been transformed. Allows modifying the CSS data before
   *                   it is transformed by returning any string value (or false
   *                   to skip). Passes 1) CSS text, 2) source node reference, and
   *                   3) the source URL as arguments.
   * @param {function} [options.onComplete] Callback after all CSS has been
   *                   processed, legacy-compatible CSS has been generated, and
   *                   (optionally) the DOM has been updated. Passes 1) a CSS
   *                   string with CSS variable values resolved, 2) an array of
   *                   output <style> node references that have been appended to
   *                   the DOM, 3) an object containing all custom properies names
   *                   and values, and 4) the ponyfill execution time in
   *                   milliseconds.
   * @param {function} [options.onFinally] Callback in modern and legacy browsers
   *                   after the ponyfill has finished all tasks. Passes 1) a
   *                   boolean indicating if the last ponyfill call resulted in a
   *                   style change, 2) a boolean indicating if the current
   *                   browser provides native support for CSS custom properties,
   *                   and 3) the ponyfill execution time in milliseconds.
   * @example
   *
   *   cssVars({
   *     rootElement   : document,
   *     shadowDOM     : false,
   *     include       : 'style,link[rel="stylesheet"]',
   *     exclude       : '',
   *     variables     : {},
   *     onlyLegacy    : true,
   *     preserveStatic: true,
   *     preserveVars  : false,
   *     silent        : false,
   *     updateDOM     : true,
   *     updateURLs    : true,
   *     watch         : false,
   *     onBeforeSend(xhr, node, url) {},
   *     onError(message, node, xhr, url) {},
   *     onWarning(message) {},
   *     onSuccess(cssText, node, url) {},
   *     onComplete(cssText, styleNode, cssVariables, benchmark) {},
   *     onFinally(hasChanged, hasNativeSupport, benchmark)
   *   });
   *)
*/
//# sourceMappingURL=chunk-IPWJWI74.js.map
